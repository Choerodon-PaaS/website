{"/docs/":{"url":"docs/","title":"文档","description":"","body":"欢迎使用 Choerodon 文档 Choerodon 猪齿鱼是一个开源企业服务平台，是基于 Kubernetes 的容器编排和管理能力，整合 DevOps 工具链、微服务和移动应用框架，来帮助企业实现敏捷化的应用交付和自动化的运营管理，并提供 IoT 、支付、数据、智能洞察、企业应用市场等业务组件，来帮助企业聚焦于业务，加速数字化转型。 Choerodon 提供一整套支撑 DevOps 最佳实践的工具链，从计划、编程、构建、测试、发布与运营等支撑敏捷管理；并且还提供了一套基于 Spring Cloud 微服务应用框架，以帮助企业更加快捷高效的进行微服务开发。Choerodon 文档将从Choerodon相关概念，DevOps 工具链 和 应用开发 等方面详细介绍 Choerodon 作为DevOps支撑平台的架构、安装、配置、部署，以及如何使用等，以及 Choerodon 微服务应用框架的开发、部署等。 了解和学习 Choerodon 的概念和安装 概念 01 - Choerodon是什么 02 - 平台概念 03 - 系统架构 更多 04 - 使用的开源组件 05 - 组织层次 06 - 安全 折叠 安装与配置 01 - 概述 02 - 安装开发区 03 - 安装运行区 更多 04 - 安装其他组件 05 - 迁移 06 - .deploy.yml文件说明 07 - .gitlab-ci.yml文件说明 08 - Dockerfile文件说明--> 折叠 了解和学习 Choerodon 的 DevOps 工具链 Choerodon 提供一整套 DevOps 的最佳实践，从计划、编程、构建、测试、发布与运营等。 快速入门 01 - 开发一个微服务前端 02 - 开发一个微服务后端 03 - 开发一个Web应用 更多 04 - 开发一个移动应用 05 - 从用户故事到运营监控 折叠 功能说明 01 - 系统配置 02 - 敏捷管理 03 - 持续集成 更多 04 - 持续部署 05 - 洞察监控 折叠 了解和学习 Choerodon 的开发应用 Choerodon 微服务应用框架是基于多年企业应用服务的经验，面向微服务架构思想和分布式应用架构研发的分布式应用开发平台，以满足应用微服务化和混合云IT架构分布式应用的开发。 快速入门 01 - 开发一个微服务前端 02 - 开发一个微服务后端 开发手册 01 - 后端开发 02 - 前端开发 03 - 后端环境部署 04 - 前端项目部署 "},"/docs/concept/":{"url":"docs/concept/","title":"概念","description":"","body":"概念 介绍Choerodon相关概念。Choerodon的用户可以通过此章节了解Choerodon的作用、系统架构、使用了哪些开源组件以及系统的组织层次和安全设计等，对Choerodon的有一个全貌的了解。 Choerodon 是什么 说明Choerodon的设计和开发的目的、特点，以及它能够解决的问题和给用户带来哪些价值等。 平台概念 介绍说明Choerodon平台的概念，关于平台涉及到的项目 应用 环境等概念解释。 系统架构 描述Choerodon的微服务系统架构，以及一般性企业系统架构的演进历程。 使用的开源组件 描述Choerodon使用到的开源工具集或者产品。分为两部分，其一是微服务应用框架使用的开源工具集或者产品，其二是DevOps业务流程使用的工具集。 组织层次 介绍说明Choerodon采用全局、组织和项目三个层次来组织系统资源。 安全 描述说明Choerodon的认证体系和权限控制。 "},"/docs/concept/choerodon-concept":{"url":"docs/concept/choerodon-concept","title":"Choerodon 是什么?","description":"","body":"Choerodon 是什么？ 企业级数字化服务平台 Choerodon 猪齿鱼是一个开源企业服务平台，是基于 Kubernetes 的容器编排和管理能力，整合 DevOps 工具链、微服务和移动应用框架，来帮助企业实现敏捷化的应用交付和自动化的运营管理，并提供 IoT、支付、数据、智能洞察、企业应用市场等业务组件，来帮助企业聚焦于业务，加速数字化转型。 Choerodon 使用 Kubernetes 来管理和部署服务。关于 Kubernetes，请参考 Kubernetes 概览。 同时，Choerodon 使用 Spring Cloud 作为微服务分布式系统，并且 Choerodon 还使用 Spring Boot 进行了通用性模块的封装，例如组织管理、用户管理、权限管理等；前端使用 React 作为开发组件。关于 Choerodon 的开发请参考 Choerodon 猪齿鱼微服务开发框架 开发。 有关 Choerodon 组件的详细概念信息，请参阅我们的其他概念指南。 为什么要使用 Choerodon ？ Choerodon 解决了开发人员和运维人员面临的许多挑战。随着企业或者组织业务模式不断的互联网化，尤其是对于一些有软件研发能力的公司或者组织，如何有效的应对开发和运维之间的关系，提高IT部门的总体运作效率，以支撑业务的快速发展，已成为了我们面临的重大挑战。 同时，现代企业或者组织对于软件系统的需求，也在随着互联网和大数据等新技术的进步在悄然发生变化，尤其是在数字化转型的思潮中，企业或者组织要求： 零宕机 部署松耦合的组件，通过冗余来避免故障，零停机的情况下完成升级 极短反馈周期 经常发布代码，缩短反馈回路，降低风险 移动和多设备 充分利用移动设备，用户能够在多种设备使用，系统能够适应扩展的需求 设备互联 互联网连接的设备导致数据量剧增和要求“边缘”的计算能力，需要新的软件设计和实践 数据驱动 使用数据，通过更智能的应用向客户提供极致的体验和更高的价值 Choerodon 采用 DevOps 的原则和敏捷模型来管理软件的开发和运维，可以有效提高软件交付的质量（比如：提高可用性，提高变更成功率，减少故障等），加快产品推向市场（比如：缩短开发周期时间和更高的部署频率），并且提高组织的有效性（比如：将时间花在价值增加活动中，减少浪费，同时交付更多的价值至客户手中），有效地帮助企业或者组织提升 IT 效能。 Choerodon 是将服务和应用构建在 Kubernetes 上，后端服务使用 Spring Boot 开发，前端使用 React 开发。Choerodon 分为两类环境，即应用 PaaS 环境和产品 PaaS 环境，应用 PaaS 环境为主要软件开发区，包括应用构建、敏捷管理、开发管理和持续发布管理等核心功能；产品 PaaS 环境主要软件运行区，包括测试环境、用户集成测试环境、正式环境等，用户可以根据自身需求定义。 以下是对 Choerodon 关键特性说明： 敏捷管理 通过故事地图、用户故事来管理用户故事和发布计划，通过迭代来管理冲刺，最后通过看板来可视化冲刺的执行，让需求、计划、执行一目了然，使整个软件开发流程管理规范化。 开发流水线 借助 Gitlab CI 作为持续集成工具，提供持续集成的流水线，简化应用开发、缩短应用生命周期，快速迭代。 部署流水线 方便地管理各种使用 Choerodon 开发部署的应用服务和资源，包括应用启停、状态监控，以及应用对应的版本控制、容器管理等。 微服务开发 基于 Spring Cloud 的微服务应用开发框架，方便快捷的构建应用服务，简化开发，提高IT系统对业务的支撑能力。 运营管理 提供一整套完整的运营管理工具，在软件交付生产的各个环节建立数据收集和度量，监控主要包含开发类指标、服务器日志、应用系统日志和微服务调用链等信息；同时，提供各种分析报告，帮助用户优化 IT 资源配置。 "},"/docs/concept/choerodon-opensource-component":{"url":"docs/concept/choerodon-opensource-component","title":"使用的开源组件","description":"","body":"Choerodon 使用的开源组件 Choerodon 完全基于开源产品打造。我们从两个方面来叙述 Choerodon 使用的开源产品或者工具。其一，Choerodon 的本身是使用 Spring Cloud 作为微服务架构，运行在 Docker 上，同时使用 Kubernetes 作为容器管理和编排工具；其二，它以 DevOps 为理论指导，实现了敏捷的最佳实践。以下我们从两个方面来阐述 Choerodon 使用了哪些开源产品和工具： 微服务应用框架使用的开源工具集 Choerodon 的微服务应用系统架构由五个不同的层组成，从应用程序代码到所需运行平台和连接服务。这些应用程序和服务通过一致的调度和编排和监督进行管理，所有这些应用程序和服务都运行在 K8s 提供的运行环境上。 应用前端 Choerodon 前端使用 react 和 mobx。 核心组件有： React：React 是一个用于构建用户界面的 JAVASCRIPT 库。 Mobo：Mobx 是一个功能强大，上手非常容易的状态管理工具。 微服务后端 Choerodon 的微服务后端采用 Spring Cloud 作为微服务框架，使用 Spring Boot 作为开发脚手架。 核心组件有： Spring Cloud：Spring Cloud 是一个集成了众多开源的框架，利用 Spring Boot 的开发便利性实现了服务治理、服务注册与发现、负载均衡、数据监控，REST API 发布方式等，基本囊括了分布式框架所需要的所有功能。是一套易开放、易部署、易维护的分布式开发工具包。 Spring Boot：Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。 消息中间件 Choerodon 使用 Kafka 作为消息中间件。 核心组件有： Kafka：Kafka 是由 Apache 软件基金会开发的一个开源流处理平台，由 Scala 和 Java 编写。Kafka 是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。 数据服务层 Choerodon 采用 MySQL 作为关系型数据存储库，Redis 作为缓存库。 核心组件有： MySQL：Mysql 是最流行的开源关系型数据库管理系统。 Redis：Redis 是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。 运行环境 Choerodon 运行在 Docker 上。 核心组件有： Docker：Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器编排 Choerodon 使用 Kubernetes 作为容器编排和管理工具。 核心组件有： Kubernetes：Kubernetes 是一个开源平台 用于跨主机群集自动部署 扩展和操作应用程序容器 提供以容器为中心的基础架构。 DevOps 平台使用的开源工具集 自动化是整个 DevOps 实现的核心，对应生命周期的每个阶段都可以选择开源工具框架。将 DevOps 工具集环境作为整体服务交付是一件非常有挑战的事情。Choerodon 融合了多个 DevOps 的开源工具，并且结合自身的能力。DevOps 不同阶段的工具使用不同的编程语言开发，需要不同的运行环境(OS、数据库、中间件服务器等)。我们选取了如下的工具集的组合来落地实施 DevOps，并且通过 Choerodon 平台融合能力，将不同的工具融合到 Choerodon 的 DevOps 流程中，用户仅需简单的配置即可使用，开始敏捷迭代之旅。 计划 Choerodon 使用自主开发的敏捷管理开完成 DevOps 的计划步骤的工作。Choerodon 敏捷管理的核心是需求，计划和执行。即通过用户故事地图来管理用户故事和发布计划，通过迭代来管理冲刺，最后通过看板来可视化冲刺的执行。 核心组件有： 用户故事地图：Choerodon 的用户故事地图可以将你的 Backlog 变成一张二维地图，而不是传统的简单列表。 迭代：迭代可以计划冲刺的用户故事数量、故事点、工时，并且拆分用户故事等。 看板：Choerodon 的看板是 Choerodon 敏捷管理中执行部分，它的核心作用是可视化整个迭代的计划执行，并且暴露开发执行过程中的短板或者瓶颈 关于敏捷管理的详情，请参考敏捷管理。 编码 Choerodon 采用主流的 Git 和 Gitlab 作为代码的管理和托管工具，同时使用 Maven 作为项目代码的组织和管理工具。 核心组件有： Git：Git 是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 Gitlab：GitLab 是一个基于 Git 的仓库管理程序 也是一个方便软件开发的强大完整应用。 Maven：Maven 项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具 构建 Choerodon 在构建阶段，采用 Gitlab CI 作为持续集成工具，Harbor 作为镜像的存放库，同时 Choerodon 融合了 Gitlab CI 和 Harbor 这两个工具，以实现自动化和版本的控制。 Gitlab CI：Gitlab CI 是 Gitlab 提供的一个持续集成工具。主要通过.gitlab-ci.yml 配置文件管理 CI 过程。 Harbor：Harbor 是一个企业级的 Docker Registry，可以实现 images 的私有存储和日志统计权限控制等功能，并支持创建多项目。 测试 Choerodon 采用多个代码检查和测试工具，其中，SonarQube 作为自动化代码检查工具；JUnit 作为后端 Java 代码的测试工具；Selenium 作为前端测试的工具。 核心组件有： SonarQube：SonarQube 是一个用于代码质量管理的开源平台，用于管理源代码的质量，可以从七个维度检测代码质量搜索。通过插件形式，可以支持包括 java，C#，C/C++，PL/SQL，Cobol，JavaScrip，Groovy 等等二十几种编程语言的代码质量管理与检测 JUnit：JUnit 是一个 Java 语言的单元测试框架。 Selenium：Selenium 是一套完整的 web 应用程序测试系统，包含了测试的录制（selenium IDE） 编写及运行（Selenium Remote Control）和测试的并行处理（Selenium Grid）。 部署和运营 Choerodon 融合使用 Docker、Kubernetes 和 Harbor 作为部署工具。 核心组件有： Docker：Docker 是一个开源的引擎 可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。 Kubernetes：Kubernetes 是一个开源平台 用于跨主机群集自动部署 扩展和操作应用程序容器 提供以容器为中心的基础架构。 Harbor：Harbor 是一个企业级的 Docker Registry，可以实现 images 的私有存储和日志统计权限控制等功能，并支持创建多项目。 监控 Choerodon 的监控包括了从用户故事开始到服务的运营全生命周期的状态、反馈、监控等，帮助开发和运营管理更好的提升效能。 核心组件有： Zipkin：Zipkin 为分布式链路调用监控系统 聚合各业务系统调用延迟数据 达到链路调用监控跟踪。 Grafana：Grafana 是一个开箱即用的可视化工具，具有功能齐全的度量仪表盘和图形编辑器，有灵活丰富的图形化选项，可以混合多种风格，支持多个数据源特点。 Promethues：Promethues 是由 SoundCloud 开发的开源监控报警系统和时序列数据库(TSDB)。 Micrometer：Micrometer 是一个监控指标的度量类库。 "},"/docs/concept/choerodon-org":{"url":"docs/concept/choerodon-org","title":"组织层次","description":"","body":"Choerodon 的组织架构 组织层次 Choerodon 中有三层组织层次，即全局层、组织层和项目层。Choerodon 使用三层组织结构来管理用户、权限、项目、环境资源、菜单，以及其他系统资源和功能。Choerodon 这样的设计其实是借用的 SaaS 组织管理概念，主要是 Choerodon 应用开发框架为了满足用户 SaaS 化的需求而设计的，在 Choerodon 的应用开发和运营管理中使用的不多。 下面我们将从如下几个方面来阐述 Choerodon 的组织层次： 全局层 Choerodon 的全局层中包含了系统的一些基本设置，例如组织管理、菜单管理、全局角色管理等。另外，在全局层还可以查看 Choerodon 系统中的服务和权限分配等。 全局层可以包含多个组织，例如运营组织。 关于全局的具体操作，请查看用户手册全局管理。 组织层 Choerodon 使用组织来管理用户、权限、项目、环境资源，以及其它系统资源和功能。在系统中有一个默认的组织运营组织，目前 Choerodon 中所有的服务、功能和资源都定义在整个组织下面。举个例子，有一个零售公司，想通过 Choerodon 搭建一个基于微服务的数字化服务平台，此平台涵盖了从门店、零售到库存等整个供应链的管理，需要开发门店管理服务、零售服务、支付服务、库存服务、商品服务等，此时我们可以整个公司看做一个组织，将数字服务平台中包含的所有服务放在这个组织下。当然，如何以项目的形式开发，我们将在项目层中说明。 一个组织可以包含多个项目，例如智能监控。 关于组织的具体操作，请查看用户手册组织管理。 运营组织是 Choerodon 自带的缺省组织，Choerodon 平台上所有的基础服务全部放在次组织下面。例如，用户服务、权限服务、看板服务、Gitlab 服务等。 项目层 Choerodon 通过项目来管理软件的开发，项目属于组织。Choerodon 中项目的含义和现实项目的含义相似。在组织层我们提到零售公司的例子，需要开发门店管理服务、零售服务、支付服务、库存服务、商品服务等五个服务，我们有两个项目组来完成五个服务的开发，A 项目组开发门店管理服务、零售服务、支付服务，B 项目组负责库存服务、商品服务的开发，我们可以在零售公司组织下创建两个项目，A 项目和 B 项目，在 A 项目中创建门店管理服务、零售服务、支付服务三个服务，在 B 项目下创建库存服务、商品服务两个服务。当然，根据具体的业务系统来定义项目，例如数字化服务平台项目，在此项目下创建门店管理服务、零售服务、支付服务、库存服务、商品服务等五个服务。 关于项目的具体操作，请查看用户手册项目管理。 "},"/docs/concept/choerodon-system-architecture":{"url":"docs/concept/choerodon-system-architecture","title":"系统架构","description":"","body":"技术架构 从总体技术架构上主要分为以下4个方面： 1，基础资源，主要指硬件基础资源，包括主机，存储，网络等 2，支撑组件，Kubernetes 运行在基础资源之上，支撑组件运行在 k8s 或基础资源之上，多为成熟的数据库，中间件，及工具。 3，应用框架，主要指基于 Spring Cloud 的微服务框架，提供多种类型的基础框架服务，以及支撑服务。 4，业务服务，Choerodon 的业务服务，目前主要包括用户故事，敏捷及 Devops 服务。 业务架构 如上图所示，业务架构总体上分为以下3个部分： 1，敏捷项目管理，实现基于 Scrum 的敏捷项目管理功能，主要包括用户故事地图，Issue Kanban，以及多维度报表分析。 2，应用开发管理，实现基于 Devops 理论的应用开发管理，主要包括应用管理，应用模板管理，CI流水线，分支管理，版本发布管理。 3，部署管理，基于 K8S 提供持续部署功能，主要包括，环境管理，部署管理，服务管理，对外网络管理。 "},"/docs/concept/platform-concept":{"url":"docs/concept/platform-concept","title":"平台概念","description":"","body":"平台概念 项目(Project) Choerodon 中项目是用来组织开发团队，团队在项目可以进行应用开发，版本发布，应用部署，应用运营。 应用(Application) 应用是满足用户某些需求的程序代码的集合，可以是某个解耦的微服务或是某个单体应用。用户可以创建应用，平台会为用户创建对应的git仓库以便管理该应用代码。应用是整个系统最小的实体单位，Choerodon 猪齿鱼中所有的开发、部署，以及运营等都是基于应用的。 应用版本(Application Version) 应用版本是应用通过一阶段开发，通过持续集成生成的一个可部署的应用增量 环境(Enviroment) 环境是指一个应用可以被部署的地方。 常见环境有开发测试环境、预生产环境、生产环境等。Choerodon 自动为您的项目生成一条环境流水线，用户可以根据需要调整顺序环境的顺序。通过环境流水线，用户可以清晰地定义和查看应用版本部署的顺序。 每一个环境对应了一个 Kubernetes 的 namespace。 应用实例(Application Instance) 部署实例是应用的某版本在具体环境运行产生的实例。 通过 Choerodon，用户可以方便的选择某一个应用，以及应用对应的版本，然后选择目标环境。同时，Choerodon 会帮助用户自动的检查部署相关的配置信息，如果检查通过，Choerodon 会自动的将应用对应的版本部署到目标环境中。 负载均衡服务(Service) 负载均衡服务运行中环境中，是将环境内部的访问请求转发到具体的1个或多个应用实例 Choerodon 中可以根据实际需求，定义应用实例的暴露方式。 接入路由器(Ingress) 接入路由器运行在具体的环境中，将环境外部的请求转发到环境内部的负载均衡服务。 "},"/docs/concept/security/RBAC":{"url":"docs/concept/security/RBAC","title":"角色控制访问(RBAC)","description":"","body":"Choerodon 角色控制访问权限(RBAC) Choerodon 的对资源的管理是基于角色控制的，并从组织层、项目层和用户层对角色进行划分。 包含如下的特点： 基于角色的权限访问控制 基于组织层、项目层和用户层的三层权限体系 自定义角色创建和绑定 架构 下图介绍了 Choerodon RBAC 的架构。 工作流 下图介绍了 RBAC 的流程图。 组成 Choerodon RBAC 包含资源、角色、用户。同时包含资源与角色的关联，角色与用户的关联。 资源 Choerodon 遵循REST 原则，视HTTP-based REST API 为一个或一组资源。 对资源的引用和操作则视为权限。 权限的级别对应全局、组织、项目。 角色 角色是资源的超集。 角色的级别对应为全局、组织、项目。 角色和资源之间通过 RBAC 关联起来。 一个角色严格遵循只能访问所属资源的原则。 角色支持自定义角色，通过标签将角色和第三方系统进行关联。 用户 用户是资源的实际使用者。 用户和角色之间通过 RBAC 关联起来。 "},"/docs/concept/security/":{"url":"docs/concept/security/","title":"安全","description":"","body":"安全 介绍Choerodon的认证体系和权限控制功能。 认证体系 介绍 Choerodon 的认证体系， Choerodon 采用 Spring Cloud Security 和 Spring Cloud OAuth2 作为认证技术框架。 权限控制 介绍 Choerodon 的权限控制功能， Choerodon 采用基于角色的权限访问控制（Role-Based Access Control）。 "},"/docs/concept/security/authentication":{"url":"docs/concept/security/authentication","title":"认证体系","description":"","body":"Choerodon 认证体系 身份验证的目的是增强微服务和保证微服务之间的通信安全。 主要负责如下功能： 提供给网关一个统一的认证入口。 提供微服务通信的统一的用户 session 保证。 提供 token 管理系统，用来生成 token ，存储 token ， 撤销 token 。 架构 下图介绍了Choerodon 认证体系的架构。 组成 认证服务器 认证服务器，即专门用来处理认证的服务器。 资源服务器 资源服务器，即存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。 在 Choerodon 中，资源服务器主要指系统中的一个个微服务。 工作流 认证流程包含三个阶段， 授权阶段，鉴权阶段和使用阶段。 授权阶段 资源拥有者根据用户名和密码，调用授权服务器。 授权服务器校验用户名和密码，生成对应的 token 返回给客户端，并将 token 存储下来，用于之后的鉴权。 客户端将 token 存储在本地，用于之后每次请求的鉴权。 鉴权阶段 客户端根据本地的 token 请求资源。 网关将根据 token 去授权服务器鉴权。 授权服务器将网关传来的 token 和存储的 token 进行对比，来确定本次操作是否是合法的。 使用阶段 鉴权通过，网关将 token 转化成包含用户信息的 JWT token，并将 JWT token 传给资源服务器。 资源服务器根据 JWT token 解析成用户信息，执行资源操作。 "},"/docs/development-guide/":{"url":"docs/development-guide/","title":"开发手册","description":"","body":"开发手册 本用户手册介绍了Choerodon 微服务开发框架的开发流程。Choerodon的用户可以通过此章节了解每个环节的流程。使用本教程，你可以了解： 后端开发手册 介绍了如何使用我们的Choerodon 微服务开发框架和docker来开发一个简单的微服务。 前端开发手册 介绍了如何使用我们的Choerodon 微服务开发框架和React来开发一个简单的前端。 平台开发手册 介绍了如何向我们报告Issues 和如何帮助我们改进我们的平台。 "},"/docs/development-guide/backend/":{"url":"docs/development-guide/backend/","title":"后端开发手册","description":"后端开发手册","body":"介绍 本页面介绍了使用Choerodon 微服务开发框架，来开发一个简单的微服务。包含了本地开发环境搭建，开发Demo程序，测试与集成。每个模块都包含了其主要功能、操作流程及其他注意事项。 功能 开发环境搭建 讲述了如何在本地搭建开发环境，以支撑我们在本地进行微服务开发。 开发Demo程序 讲述了如何创建一个简单的项目，实现记录待办事项的功能。 测试与集成 讲述了将demo 集成到Choerodon 平台中，并进行接口测试。 "},"/docs/development-guide/backend/demo/":{"url":"docs/development-guide/backend/demo/","title":"开发Demo程序","description":"","body":"前置条件 在开发之前，要保证环境已经安装正确，详见 开发环境搭建 介绍 创建一个简单的项目，实现记录待办事项的功能。 具体功能包括：创建任务、根据任务Id获取任务、根据ID删除任务、根据任务编号删除任务、根据任务ID更新任务信息。 表结构 todo_user 用户表，存储该项目中的用户信息 字段名 | 字段类型 | 字段说明 ---|--- | --- id | BIGINT UNSIGNED | 主键 employee_name | VARCHAR | 员工名 employee_number | VARCHAR | 员工号 email | VARCHAR | 邮箱 todo_task 任务表，存储该项目中所有的任务信息和任务与用户的关系 字段名 | 字段类型 | 字段说明 ---|--- | --- id | BIGINT UNSIGNED | 主键 employee_id | BIGINT | 员工ID task_number | VARCHAR | 任务编号 task_description | VARCHAR | 任务描述 state | VARCHAR | 状态 todo_swimlane 泳道表，存储该项目中的泳道信息 字段名 | 字段类型 | 字段说明 ---|--- | --- id | BIGINT UNSIGNED | 主键 state | VARCHAR | 状态 next_state | VARCHAR | 下一状态 项目结构 choerodon-todo-service-parent └─choerodon-todo-service └─src ├─main │ ├─java │ │ └─io │ │ └─choerodon │ │ └─todo │ │ ├─api │ │ │ ├─controller │ │ │ │ └─v1 │ │ │ └─dto │ │ ├─app │ │ │ └─service │ │ │ └─impl │ │ ├─domain │ │ │ ├─repository │ │ │ ├─service │ │ │ │ └─impl │ │ │ └─todo │ │ │ ├─convertor │ │ │ └─entity │ │ └─infra │ │ ├─dataobject │ │ ├─mapper │ │ └─repository │ │ └─impl │ └─resources │ ├─mapper │ └─script │ └─db └─test └─java "},"/docs/development-guide/backend/demo/api":{"url":"docs/development-guide/backend/demo/api","title":"编写api-展现层","date":"2018-04-27T13:47:28+08:00","body":"前置条件 在开发之前，请确保 本地项目已经创建成功，详见 新建项目 数据库创建成功，详见 初始化数据库 介绍 此demo需涉及api层的 dto 以及 controller 。 编写DTO DTO 类用来封装用户请求的数据信息，这里指的用户可以是另一个计算机系统，不一定是使用用户界面的人。 创建在 项目模块 的 xxx.api.dto 包下。 根据需要补充 domain 层对应的 convertor 类。 DTO代码（以taskDTO为例） package io.choerodon.todo.api.dto; public class TaskDTO { private Long id; private Long employeeId; private String state; private String taskNumber; private String taskDescription; private Long objectVersionNumber; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public Long getEmployeeId() { return employeeId; } public void setEmployeeId(Long employeeId) { this.employeeId = employeeId; } public String getState() { return state; } public void setState(String state) { this.state = state; } public String getTaskNumber() { return taskNumber; } public void setTaskNumber(String taskNumber) { this.taskNumber = taskNumber; } public String getTaskDescription() { return taskDescription; } public void setTaskDescription(String taskDescription) { this.taskDescription = taskDescription; } public Long getObjectVersionNumber() { return objectVersionNumber; } public void setObjectVersionNumber(Long objectVersionNumber) { this.objectVersionNumber = objectVersionNumber; } } 编写Controller Controller 负责对 Model 和 View 的处理，创建在 项目模块 的 xxx.api.controller.v_ 包下。如 xxx.api.controller.v1。 每一个 Controller 是对一个具体的 DTO 资源进行处理的，所以命名为 dto 类名尾缀替换为 Controler 。如： TaskController 对应 TaskDTO 类。 需要通过 @Controller 指定该类为一个 Controller 类。 Controller 类相关标签 @Permission ，设置API访问权限，有四种属性 permissionLogin ：设置是否需要登陆访问 level ：设置访问资源层级，包括site organization project，user四种层级 roles ：设置可访问用户角色，此为数组 permissionPublic ：设置任意访问。 @ApiOperation ，显示在swagger ui上的接口注释，同时与该接口对应的权限表中的描述字段对应(iam_permission.description) @GetMapping ，是一个组合注解，是@RequestMapping(mathod = RequestMethod.GET)的缩写 @PostMapping等同理。建议使用组合注解。 @CustomPageRequest ，用于分页。 Controller代码（以TaskController为例） Controller中的path以v1开头，需在bootstrap.yml中配置 ignored: /v2/api-docs。 Controller中的path不以v1开头，比如以app开头，则需配置 @Value(\"${choerodon.resource.pattern:/app/*}\") private String pattern package io.choerodon.todo.api.controller.v1; import io.choerodon.core.exception.CommonException; import io.choerodon.todo.api.dto.TaskDTO; import io.choerodon.todo.app.service.TaskService; import io.swagger.annotations.ApiOperation; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.*; import javax.validation.Valid; import java.util.Optional; @RestController @RequestMapping(value = \"/v1/task\") public class TaskController { private TaskService taskService; public TaskController(TaskService taskService) { this.taskService = taskService; } @ApiOperation(value = \"创建任务\") @PostMapping(value = \"/create\") public ResponseEntity create(@RequestBody @Valid TaskDTO task) throws CommonException { return Optional.ofNullable(taskService.create(task)) .map(result -> new ResponseEntity<>(result HttpStatus.OK)) .orElseThrow(() -> new CommonException(\"error.Task.create\")); } @ApiOperation(value = \"根据任务Id获取任务\") @GetMapping(value = \"/findTaskById/{id}\") public ResponseEntity findByNumber(@PathVariable @Valid Long id) throws CommonException { return Optional.ofNullable(taskService.queryById(id)) .map(result -> new ResponseEntity<>(result HttpStatus.OK)) .orElseThrow(() -> new CommonException(\"error.Task.notFound\")); } /** * 根据任务ID更新任务信息 * * 注意：更新task时需在json数据中添加objectVersionNumber属性及值才能更新成功。 * * @param id 任务ID * @param task 任务信息 * @return 更新后的任务信息 * @throws CommonException 更新失败 */ @ApiOperation(value = \"根据任务ID更新任务状态\") @PutMapping(value = \"/update/{id}\") public ResponseEntity updateUser(@PathVariable Long id) throws CommonException { return Optional.ofNullable(taskService.updateStateById(id)) .map(result -> new ResponseEntity<>(result HttpStatus.OK)) .orElseThrow(() -> new CommonException(\"error.Task.update\")); } @ApiOperation(value = \"根据任务ID删除任务\") @DeleteMapping(value = \"/{id}\") public ResponseEntity deleteByEmployeeId(@PathVariable Long id) throws CommonException { taskService.deleteById(id); return new ResponseEntity(HttpStatus.NO_CONTENT); } @ApiOperation(value = \"根据任务编号删除任务\") @DeleteMapping(value = \"/taskNumber/{taskNumber}\") public ResponseEntity deleteByTaskNumber(@PathVariable String taskNumber) throws CommonException { taskService.deleteByTaskNumber(taskNumber); return new ResponseEntity(HttpStatus.NO_CONTENT); } } "},"/docs/development-guide/backend/demo/app":{"url":"docs/development-guide/backend/demo/app","title":"编写app-应用层","date":"2018-04-27T11:40:28+08:00","body":"前置条件 在开发之前，请确保 本地项目已经创建成功，详见 新建项目 数据库创建成功，详见 初始化数据库 介绍 此demo需涉及到app层的service接口类与其实现类（根据需要补充api层的dto类 以及 domain 层的 convertor 类） Service 接口类 Service 接口类定义了业务操作的一系列接口，并不提供实现，具体实现需要通过服务实现层提供，所以属于供应方的服务接口层。创建在 项目模块 的 xxx.app.service 包下。 Service 接口类代码（以TaskService为例） package io.choerodon.todo.app.service; import io.choerodon.todo.api.dto.TaskDTO; import org.springframework.stereotype.Service; public interface TaskService { TaskDTO queryById(Long id); TaskDTO create(TaskDTO taskDTO); void deleteById(Long id); void deleteByTaskNumber(String taskNumber); TaskDTO updateStateById(Long id); } Service 实现类 Service 接口的具体实现通过服务实现层提供，所以属于供应方的服务实现层。创建在 项目模块 的 xxx.app.service.impl 包下。 实现类，需要用 @Component 标注 Service 实现类代码（以TaskServiceImpl为例） package io.choerodon.todo.app.service.impl; import io.choerodon.todo.api.dto.TaskDTO; import io.choerodon.todo.app.service.TaskService; import io.choerodon.todo.domain.repository.TaskRepository; import io.choerodon.todo.domain.service.ITaskService; import io.choerodon.todo.domain.todo.convertor.TaskConvertor; import org.springframework.stereotype.Component; @Component public class TaskServiceImpl implements TaskService { private TaskRepository taskRepository; private ITaskService iTaskService; public TaskServiceImpl(TaskRepository taskRepository ITaskService iTaskService) { this.taskRepository = taskRepository; this.iTaskService = iTaskService; } @Override public TaskDTO queryById(Long id) { return new TaskConvertor().entityToDto(taskRepository.queryById(id)); } @Override public TaskDTO create(TaskDTO taskDTO) { return new TaskConvertor().entityToDto(taskRepository.create(new TaskConvertor().dtoToEntity(taskDTO))); } @Override public void deleteById(Long id) { taskRepository.deleteById(id); } @Override public void deleteByTaskNumber(String taskNumber) { taskRepository.deleteByTaskNumber(taskNumber); } @Override public TaskDTO updateStateById(Long id) { return new TaskConvertor().entityToDto(iTaskService.updateTaskStateById(id)); } } "},"/docs/development-guide/backend/demo/application":{"url":"docs/development-guide/backend/demo/application","title":"编写Application类","date":"2018-04-27T11:40:28+08:00","body":"前置条件 在开发之前，请确保 本地项目已经创建成功，详见 新建项目 数据库创建成功，详见 初始化数据库 介绍 Choerodon 的微服务基于spring boot，所以需要有一个Application类作为入口程序。 编写TodoServiceApplication类 package io.choerodon.todo; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class TodoServiceApplication { public static void main(String[] args) { SpringApplication.run(TodoServiceApplication.class args); } } 结构 └─main ├─java │ └─io │ └─choerodon │ └─todo │ └─TodoServiceApplication.java └─resources 启动程序 进入./choerodon-todo-service/ 路径，执行mvn clean spring-boot:run。 控制台打印出如下信息，则表示启动成功。 Started TodoServiceApplication in 21.299 seconds (JVM running for 22.968) "},"/docs/development-guide/backend/demo/create_project":{"url":"docs/development-guide/backend/demo/create_project","title":"新建项目","date":"2018-04-26T13:44:28+08:00","body":"介绍 项目是基于spring boot的maven项目。 新建maven项目 添加项目依赖 添加默认配置文件 创建maven项目 本地新建一个空的maven 项目choerodon-todo-service-parent 进入项目中，创建子模块choerodon-todo-service 添加项目依赖 在父项目中添加一些公用的pom属性。修改父项目的pom文件。 4.0.0 choerodon-todo-service-parent choerodon-todo-service-parent pom 1.0.0 choerodon-todo-service 0.5.0.RELEASE io.choerodon choerodon-framework-parent 0.5.0.RELEASE 在子项目中添加一些子项目的依赖。修改子项目的pom文件。 choerodon-todo-service-parent choerodon-todo-service-parent 1.0.0 4.0.0 choerodon-todo-service org.springframework.boot spring-boot-starter-undertow org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-tomcat org.springframework.boot spring-boot-starter-actuator org.springframework.cloud spring-cloud-starter-eureka io.choerodon choerodon-starter-core ${choerodon.version} io.choerodon choerodon-starter-oauth-resource ${choerodon.version} io.choerodon choerodon-starter-mybatis-mapper ${choerodon.version} io.choerodon choerodon-starter-swagger ${choerodon.version} mysql mysql-connector-java org.springframework.boot spring-boot-starter-test test app 根据子级模块所需jar包添加需要的依赖。 (必须)choerodon-starter-core，核心工具包。提供了一些基础类用于开发过程中使用。以及主要帮助获取自定义的userDetail和一些通用的方法。 (必须)choerodon-starter-oauth-resource，oauth资源服务工具包，主要提供了服务controller的异常统一捕获，并转换成用户语言对应的描述信息，以及配置了服务在接受请求时对jwt token的验证规则。 choerodon-starter-mybatis-mapper，通用mapper和分页插件集成，扩展多语言、审计字段等功能。 添加默认配置文件 项目采用spring boot 进行管理。需要在子项目中配置默认的配置项。 在子模块resource文件夹中创建 bootstrap.yaml 包含如下内容： 项目基础配置，类如数据库、端口号等等 项目与choerodon进行集成，关联注册服务器、验证服务器、以及gateway bootstrap.yml 一定会执行的配置文件，声明项目的一些基本配置。 spring: application: name: choerodon-todo-service server: port: 8080 mybatis: mapperLocations: classpath*:/mapper/*.xml configuration: mapUnderscoreToCamelCase: true management: port: 8081 security: enabled: false feign: hystrix: enabled: true security: basic: enabled: false ignored: /v2/api-docs "},"/docs/development-guide/backend/demo/domain":{"url":"docs/development-guide/backend/demo/domain","title":"编写domain-领域模型层","date":"2018-04-27T11:40:28+08:00","body":"前置条件 在开发之前，请确保 本地项目已经创建成功，详见 新建项目 数据库创建成功，详见 初始化数据库 介绍 此demo需涉及到demain层的entity、convertor、多entity的service、repository接口类以及infra层的repository实现类 编写entity entity 类需提供属性及简单行为 创建在 项目模块 的 xxx.domain.[模块名称] 包下。如：xxx.domain.todo 每一个 entity 类对应一个 DO 类，所以命名为 DO 类名尾缀替换为 E。如：TaskE 对应 DO 为TaskDO。 属性规范 所有属性均为private属性。 每一个属性需要生成对应的 getter 方法，不允许生成 setter 方法。 需添加Long类型属性 objectVersionNumber ，用以更新数据时的版本控制。 entity代码（以 TaskE 为例） package io.choerodon.todo.domain.todo.entity; public class TaskE { private Long id; private Long employeeId; private String state; private String taskNumber; private String taskDescription; private Long objectVersionNumber; public TaskE(Long id Long employeeId String state String taskNumber String taskDescription Long objectVersionNumber) { this.id = id; this.employeeId = employeeId; this.state = state; this.taskNumber = taskNumber; this.taskDescription = taskDescription; this.objectVersionNumber = objectVersionNumber; } public Long getId() { return id; } public Long getEmployeeId() { return employeeId; } public String getState() { return state; } public String getTaskNumber() { return taskNumber; } public String getTaskDescription() { return taskDescription; } public Long getObjectVersionNumber() { return objectVersionNumber; } public TaskE updateState(TaskE taskE String state){ return new TaskE(taskE.getId() taskE.getEmployeeId() state taskE.getTaskNumber() taskE.getTaskDescription() taskE.getObjectVersionNumber()); } } 编写convertor convertor用于Entity、DO、DTO三者之间的转换，需继承ConvertorI接口，E、D、T对应具体的Entity、DO、DTO 每一个 convertor 类对应一组E、D、T，所以命名为同组类名尾缀替换为 Convertor。如：TaskConvertor。 需要通过@Component纳入spring管理 重写方法 重写doToEntity、entityToDo两个方法 convertor代码（以TaskConvertor为例） package io.choerodon.todo.domain.todo.convertor; import io.choerodon.core.convertor.ConvertorI; import io.choerodon.todo.infra.dataobject.TaskDO; import io.choerodon.todo.domain.todo.entity.TaskE; import org.springframework.beans.BeanUtils; import org.springframework.stereotype.Component; @Component public class TaskConvertor implements ConvertorI { @Override public TaskE doToEntity(TaskDO dataObject) { return new TaskE(dataObject.getId() dataObject.getEmployeeId() dataObject.getState() dataObject.getTaskNumber() dataObject.getTaskDescription() dataObject.getObjectVersionNumber()); } @Override public TaskDO entityToDo(TaskE entity) { TaskDO taskDO = new TaskDO(); BeanUtils.copyProperties(entity taskDO); return taskDO; } } 编写Repository Repository 接口类 Repository 接口类定义了数据操作的一系列接口，并不提供实现，具体实现需要通过Repository实现层提供。创建在项目模块的 xxx.domain.repository 包下。 每一个 Repository 对应一个 entity ，所以命名为 entity 类名尾缀替换为 Repository。如：TaskRepository 对应 TaskE 。 Repository 接口类代码（以TaskRepository为例） package io.choerodon.todo.domain.repository; import io.choerodon.todo.domain.todo.entity.TaskE; public interface TaskRepository { TaskE create(TaskE taskE); void deleteById(Long id); void deleteByTaskNumber(String taskNumber); TaskE update(TaskE taskE); TaskE queryById(Long id); } Repository 实现类 Repository 接口的集体实现。创建在项目模块的 xxx.infra.repository.impl 包下。 每一个 Repository 实现类对应一个 Repository 接口类，所以命名为 Repository 接口类名 + Impl。如：TaskRepositoryImpl 对应 TaskRepository 。 需要通过@Component纳入spring管理 Repository 实现类代码（以TaskRepositoryImpl为例） package io.choerodon.todo.infra.repository.impl; import io.choerodon.core.exception.CommonException; import io.choerodon.todo.domain.repository.TaskRepository; import io.choerodon.todo.domain.todo.convertor.TaskConvertor; import io.choerodon.todo.domain.todo.entity.TaskE; import io.choerodon.todo.infra.dataobject.TaskDO; import io.choerodon.todo.infra.mapper.TaskMapper; import org.springframework.stereotype.Component; import java.util.List; @Component public class TaskRepositoryImpl implements TaskRepository { private TaskMapper taskMapper; public TaskRepositoryImpl(TaskMapper taskMapper) { this.taskMapper = taskMapper; } @Override public TaskE create(TaskE taskE) { TaskDO taskDO = new TaskConvertor().entityToDo(taskE); List taskDOList = taskMapper.select(taskDO); if (!taskDOList.isEmpty()) { throw new CommonException(\"error.repo.create.task.exist\"); } if (taskMapper.insertSelective(taskDO) != 1) { throw new CommonException(\"error.repo.create.task.failed\"); } return new TaskConvertor().doToEntity(taskMapper.selectByPrimaryKey(taskDO.getId())); } @Override public TaskE queryById(Long id) { return new TaskConvertor().doToEntity(taskMapper.selectByPrimaryKey(id)); } @Override public void deleteById(Long id) { if (taskMapper.selectByPrimaryKey(id) == null) { throw new CommonException(\"error.task.not.exist\"); } if (taskMapper.deleteByPrimaryKey(id) != 1) { throw new CommonException(\"error.task.delete\"); } } @Override public void deleteByTaskNumber(String taskNumber) { if (taskMapper.queryByTaskNumber(taskNumber) == null) { throw new CommonException(\"error.task.not.exist\"); } if (taskMapper.deleteByPrimaryKey(taskMapper.queryByTaskNumber(taskNumber).getId()) != 1) { throw new CommonException(\"error.task.delete\"); } } @Override public TaskE update(TaskE taskE) { TaskDO taskDO = new TaskConvertor().entityToDo(taskE); if (taskMapper.updateByPrimaryKeySelective(taskDO) != 1) { throw new CommonException(\"error.task.update\"); } return new TaskConvertor().doToEntity( taskMapper.selectByPrimaryKey(taskDO.getId())); } } 编写Service Service 接口类 Service 接口类定义了业务操作的一系列接口，并不提供实现，具体实现需要通过服务实现层提供，所以属于供应方的服务接口层。创建在 项目模块 的 xxx.domain.service 包下。 每一个 Service 对应一个或多个 entity 类，因需要与app层service区分，所以规定命名为 I + 涉及主要entity类名 + Service。如：ITaskService。代码（以 ITaskService 为例） package io.choerodon.todo.domain.service; import io.choerodon.todo.domain.todo.entity.TaskE; public interface ITaskService { TaskE updateTaskStateById(Long id); } Service 实现类 Service 接口的具体实现通过服务实现层提供，所以属于供应方的服务实现层。创建在 项目模块 的 xxx.domian.service.impl 包下。 实现类，如无特殊情况，需要用 @Service 标注，以自动扫描注册 代码(以 ITaskServiceImpl 为例) package io.choerodon.todo.domain.service.impl; import io.choerodon.todo.domain.repository.SwimlaneRepository; import io.choerodon.todo.domain.repository.TaskRepository; import io.choerodon.todo.domain.service.ITaskService; import io.choerodon.todo.domain.todo.entity.SwimlaneE; import io.choerodon.todo.domain.todo.entity.TaskE; import org.springframework.stereotype.Service; @Service public class ITaskServiceImpl implements ITaskService { private TaskRepository taskRepository; private SwimlaneRepository swimlaneRepository; public ITaskServiceImpl(TaskRepository taskRepository SwimlaneRepository swimlaneRepository) { this.taskRepository = taskRepository; this.swimlaneRepository = swimlaneRepository; } @Override public TaskE updateTaskStateById(Long id) { TaskE taskE = taskRepository.queryById(id); SwimlaneE swimlaneE = swimlaneRepository.selectByState(taskE.getState()); return taskRepository.update(taskE.updateState(taskE swimlaneE.getNextState())); } } "},"/docs/development-guide/backend/demo/infra":{"url":"docs/development-guide/backend/demo/infra","title":"编写infra-基础设施层","date":"2018-04-27T11:01:28+08:00","body":"前置条件 在开发之前，请确保 本地项目已经创建成功，详见 新建项目 数据库创建成功，详见 初始化数据库 介绍 此demo需涉及到infra层的 dataobject 类以及 mapper 类。 编写dataobject类 DO 类不需要提供任何实现，所以属于供应方的服务接口层。创建在 项目模块 的 xxx.infra.dataobject 包下。 每一个 DO 类即为一个实体类，对应数据库中的一个具体表。 名称=表具体名称+DO，表名中 _ 替换为驼峰命名法，首字母大写。如：TaskDO 对应表为 todo_task。 指定对应表 @Table(name = “table_name”) 指定 DO 对应数据库中表的名称。 每一个 DO 对应数据库中的一个具体表，一般都需要继承 AuditDomain 类。 属性规范 所有属性均为private属性。 每一个属性需要生成对应的 getter 和 setter 方法。 字段名称应根据驼峰命名规则从数据库列名转换过来。例如：数据库列名为 USER_NAME ，则字段名为 UserName，特殊字段名称，可以在字段在添加 @Column(name = “xxx”) 注解，指定数据库列名。 属性的的类型与字段的 type 对应 不使用基本类型，全部使用基本类型的包装类，如 Long 对应数据库中的 INTEGER，而不是使用 long 数字类型主键统一采用 Long 金额、数量 等精度严格浮点类型采用 BigDecimal 注意：BigDecimal 在计算、比较方面的特殊性 所有的主键字段都需要用@Id标注 对于自增张、序列（SEQUENCE）类型的主键，需要添加注解@GeneratedValue 序列命名规范：表名_S。例如：表 SYS_USER 对应的序列为 SYS_USER_S 非数据库字段 需要用 @Transient 标注 javax.persistence.Transient TaskDO.java 代码 package io.choerodon.todo.infra.dataobject; import io.choerodon.mybatis.annotation.ModifyAudit; import io.choerodon.mybatis.annotation.VersionAudit; import io.choerodon.mybatis.domain.AuditDomain; import javax.persistence.GeneratedValue; import javax.persistence.Id; import javax.persistence.Table; @ModifyAudit //在类上使用，启用审计字段支持，实体类加上该注解后，插入和更新会启动对creationDate、createdBy、lastUpdateDate、lastUpdatedBy自维护字段支持 @VersionAudit //在类上使用，启用objectVersionNumber自维护支持，插入一条数据objectVersionNumber默认为1，每次update后objectVersionNumber自增1 @Table(name = \"todo_task\") public class TaskDO extends AuditDomain { //AuditDomain包含5个自维护字段，使用@ModifyAudit和@VersionAudit的实体类要继承该类 @Id @GeneratedValue //对于自增张、序列（SEQUENCE）类型的主键，需要添加该注解 private Long id; private Long employeeId; private String state; private String taskNumber; private String taskDescription; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public Long getEmployeeId() { return employeeId; } public void setEmployeeId(Long employeeId) { this.employeeId = employeeId; } public String getState() { return state; } public void setState(String state) { this.state = state; } public String getTaskNumber() { return taskNumber; } public void setTaskNumber(String taskNumber) { this.taskNumber = taskNumber; } public String getTaskDescription() { return taskDescription; } public void setTaskDescription(String taskDescription) { this.taskDescription = taskDescription; } } Mapper mapper接口类 Mapper 接口类即为传统意义上的 DAO，但与 interface 不同，Mapper 本身就是对数据访问的具体实现，所以属于供应方的服务实现层。创建在 项目模块 的 xxx.infra.mapper 包下。 每一个 Mapper 接口类封装了对数据库表的操作，每一个 Mapper 对应一个 DO 类，所以命名为 DO 类名尾缀替换为 Mapper 。如：TaskMapper 对应DO为 TaskDO 类。 基础的 CRUD 操作不需要再次实现，通过继承 BaseMapper 类实现。其中 T 为 对应 DO 的泛型。 复杂的数据库操作需要定义具体的接口方法。 mapper.xml Mapper的xml文件 是数据库的的具体映射，与 Mapper 接口同级，创建在 项目模块 resources 目录的 xxx..mapper 包下。 Mapper的xml文件，与 Mapper 接口对应。所以命名 Mapper 接口类相同。 Mapper的xml文件非必须，由于继承BaseMapper类后基本的 CRUD 不需要进行配置，所以只有CRUD操作时不需要创建对应的 xml 文件。 对于自定义的数据库方法，需要创建对应的 Mapper.xml 文件。 Mapper的xml 中的操作 id 对应 Mapper 接口类的方法名。 以下为一个示例，不在本项目中使用: package io.choerodon.iam.infra.mapper; import java.util.List; import io.choerodon.iam.infra.dataobject.MenuDO; import io.choerodon.mybatis.common.BaseMapper; public interface MenuMapper extends BaseMapper { List queryIncludeTl(); List queryMenusWithPermissions(); } SELECT * tl1.name as zh_name tl2.name as en_name FROM iam_menu m LEFT JOIN iam_menu_tl tl1 ON m.id = tl1.id AND tl1.lang = 'zh_CN' LEFT JOIN iam_menu_tl tl2 ON m.id = tl2.id AND tl2.lang = 'en_US' SELECT im.* ip.id permission_id ip.code permission_code ip.path ip.method ip.level permission_level ip.action ip.resource ip.public_access ip.login_access ip.service_name FROM iam_menu im LEFT JOIN iam_menu_permission imp on im.id = imp.menu_id LEFT JOIN iam_permission ip on imp.permission_id = ip.id WHERE im.type = \"menu\" 以下为本项目中使用的mappper接口 UserMapper.java ，未定义额外的sql所以无需创建对应xml： package io.choerodon.todo.infra.mapper; import io.choerodon.mybatis.common.BaseMapper; import io.choerodon.todo.infra.dataobject.UserDO; public interface UserMapper extends BaseMapper { } "},"/docs/development-guide/backend/demo/init_db":{"url":"docs/development-guide/backend/demo/init_db","title":"初始化数据库","date":"2018-04-26T15:38:28+08:00","body":"前置条件 在开发之前，请确保本地项目已经创建成功，详见 新建项目 介绍 项目创建成功之后，需要初始化本地数据库。 创建用户 创建数据库 编写表结构对应的groovy脚本 初始化表结构 验证表结构 创建用户 确保数据库启动成功 创建项目访问的用户，执行如下命令： CREATE USER 'choerodon'@'%' IDENTIFIED BY \"123456\"; 创建数据库 用户创建成功之后，创建项目对应的数据库，执行如下命令： CREATE DATABASE choerodon_demo_service_todo DEFAULT CHARACTER SET utf8; 将新创建的数据库权限赋予用户 GRANT ALL PRIVILEGES ON choerodon_demo_service_todo.* TO choerodon@'%'; FLUSH PRIVILEGES; 在项目的bootstarp.yaml 文件中添加数据库连接信息： spring: datasource: url: jdbc:mysql://localhost/choerodon_demo_service_todo?useUnicode=true&characterEncoding=utf-8&useSSL=false username: choerodon password: 123456 编写表结构对应的groovy脚本 Choerodon 采用Liquibase + groovy 的方式对数据库管理。 更多有关Liguibase的资料见 Liquibase 官网。 在./choerodon-todo-service/src/resources/db/script 路径下创建todo_swimlane.groovy todo_user.groovy todo_task.groovy。 编写groovy 脚本。 todo_user.groovy // todo_user.groovy package script.db databaseChangeLog(logicalFilePath: 'todo_user.groovy') { changeSet(id: '2017-05-29-todo_user' author: 'your.email@email.com') { createTable(tableName: \"todo_user\") { column(name: 'id' type: 'BIGINT UNSIGNED' remarks: 'ID' autoIncrement: true) { constraints(primaryKey: true) } column(name: 'employee_name' type: 'VARCHAR(32)' remarks: '员工名') column(name: 'employee_number' type: 'VARCHAR(32)' remarks: '员工号') { constraints(unique: true) } column(name: 'email' type: 'VARCHAR(32)' remarks: '邮箱') column(name: \"OBJECT_VERSION_NUMBER\" type: \"BIGINT\" defaultValue: \"1\") column(name: \"CREATED_BY\" type: \"BIGINT\" defaultValue: \"-1\") column(name: \"CREATION_DATE\" type: \"DATETIME\" defaultValueComputed: \"CURRENT_TIMESTAMP\") column(name: \"LAST_UPDATED_BY\" type: \"BIGINT\" defaultValue: \"-1\") column(name: \"LAST_UPDATE_DATE\" type: \"DATETIME\" defaultValueComputed: \"CURRENT_TIMESTAMP\") } } } todo_task.groovy // todo_task.groovy package script.db databaseChangeLog(logicalFilePath: 'todo_task.groovy') { changeSet(id: '2017-05-29-todo_task' author: 'your.email@email.com') { createTable(tableName: \"todo_task\") { column(name: 'id' type: 'BIGINT UNSIGNED' remarks: 'ID' autoIncrement: true) { constraints(primaryKey: true) } column(name: 'employee_id' type: 'BIGINT' remarks: '员工ID') column(name: 'state' type: 'VARCHAR(36)' remarks: '状态') column(name: 'task_number' type: 'VARCHAR(64)' remarks: '任务编号') { constraints(unique: true) } column(name: 'task_description' type: 'VARCHAR(256)' remarks: '任务描述') column(name: \"OBJECT_VERSION_NUMBER\" type: \"BIGINT\" defaultValue : \"1\") column(name: \"CREATED_BY\" type: \"BIGINT\" defaultValue : \"-1\") column(name: \"CREATION_DATE\" type: \"DATETIME\" defaultValueComputed : \"CURRENT_TIMESTAMP\") column(name: \"LAST_UPDATED_BY\" type: \"BIGINT\" defaultValue : \"-1\") column(name: \"LAST_UPDATE_DATE\" type: \"DATETIME\" defaultValueComputed : \"CURRENT_TIMESTAMP\") } } } todo_swimlane.groovy // todo_swimlane.groovy package script.db databaseChangeLog(logicalFilePath: 'todo_swimlane.groovy') { changeSet(id: '2017-05-29-todo_swimlane' author: 'your.email@email.com') { createTable(tableName: \"todo_swimlane\") { column(name: 'id' type: 'BIGINT UNSIGNED' remarks: 'ID' autoIncrement: true) { constraints(primaryKey: true) } column(name: 'state' type: 'VARCHAR(36)' remarks: '状态') { constraints(unique: true) } column(name: 'next_state' type: 'VARCHAR(36)' remarks: '下一状态') } } } 初始化表结构 在./choerodon-todo-service 路径下，创建init-local-database.sh 文件。 #!/bin/bash mkdir -p target if [ ! -f target/choerodon-tool-liquibase.jar ] then curl https://oss.sonatype.org/content/groups/public/io/choerodon/choerodon-tool-liquibase/0.5.0.RELEASE/choerodon-tool-liquibase-0.5.0.RELEASE.jar -o target/choerodon-tool-liquibase.jar fi java -Dspring.datasource.url=\"jdbc:mysql://localhost/choerodon_demo_service_todo?useUnicode=true&characterEncoding=utf-8&useSSL=false\" \\ -Dspring.datasource.username=choerodon \\ -Dspring.datasource.password=123456 \\ -Ddata.drop=false -Ddata.init=true \\ -Ddata.dir=src/main/resources \\ -jar target/choerodon-tool-liquibase.jar 进入./choerodon-todo-service 执行如下命令： sh init-local-database.sh 脚本执行程序会自动扫描resources中的groovy数据库初始化文件以及excel初始化数据。 执行 init-local-database.sh 脚本，若出现错误： Error: Invalid or corrupt jarfile target/choerodon-tool-liquibase.jar 则自行下载 choerodon-tool-liquibase.jar 并重命名覆盖./choerodon-todo-service/target/choerodon-tool-liquibase.jar 并重新执行init-local-database.sh 脚本 验证表结构 登录数据库，查询现有的表结构。 mysql> show tables; +---------------------------------------+ | Tables_in_choerodon_demo_service_todo | +---------------------------------------+ | DATABASECHANGELOG | | DATABASECHANGELOGLOCK | | todo_swimlane | | todo_task | | todo_user | +---------------------------------------+ 5 rows in set (0.00 sec) "},"/docs/development-guide/backend/develop-env/":{"url":"docs/development-guide/backend/develop-env/","title":"开发环境搭建","description":"开发环境搭建","body":"介绍 本章节介绍了基于开发的基本工具与其具体安装配置。通过此章节，用户可完成基本开发环境的搭建。 功能 开发环境搭建(Windows) 讲述了如何在windows 环境下搭建本地开发环境。 "},"/docs/development-guide/backend/develop-env/install_windows":{"url":"docs/development-guide/backend/develop-env/install_windows","title":"开发环境搭建(Windows)","description":"开发环境搭建(Windows)","body":"开发环境搭建 本章节讲述了使用Choerodon 微服务框架开发微服务的一些软件依赖，以及如何在Windows 环境下进行安装使用。 开发工具 Git JDK 1.8.0 及以上 maven 3.3 及以上 Docker for Windows IDE Mysql Kafka Phpmyadmin (可选) Git 安装 在 Git 官网 下载对应平台的 Git。 本地执行安装文件，安装 Git 环境。 配置完成后打开 git bash 执行 git ，有提示则说明环境安装成功。 配置本地git。 打开git bash 执行如下命令： # 请将下面命令按实际情况进行执行 git config --global user.name \"Your Name\" git config --global user.email \"Your Email\" Java 安装 在 Oracle 官网 下载对应平台的 JDK 1.8.0 以上的环境。 本地执行安装文件，安装 JDK 环境。 Win 在环境变量系统变量中 配置环境变量 JAVA_HOME 指向JDK安装目录，并将 path 配置 JDK 的环境变量 指向 JDK 安装目录下 JDK/bin， 配置完成后打开 git bash 执行 java ，有提示则说明环境安装成功。(git bash执行会有乱码，cmd则正常) Maven 安装 在 Maven 官网 下载对应平台的合适的 maven 版本的压缩包。 本地解压压缩包。 Win 在环境变量中系统变量的 path 配置 maven 的环境变量指向 maven 解压目录下的 /bin 。 配置完成后打开 git bash 执行 mvn -v ，有提示则说明环境安装成功。 Docker for Windows 安装 在 Docker for Windows 下载安装包 本地执行安装文件，安装Docker 启动Docker，然后会提示启用Hyper-V需要重启 重启后Docker会自动启动 打开 git bash 执行 docker --version ，有提示则说明环境安装成功。 打开 docker for windows，并在General 中勾选 Expose daemon on tcp://localhost:2375 without TLS 注意要使用Docker for Windows，机器必须开启虚拟化支持，部分机型默认禁用，需进入bios进行设置，因各机型设置不相一致，在此不做详细说明 IDE 安装 这里以idea 为例 在IDEA官网下载安装包 本地执行安装文件，安装IDEA 菜单栏File > Setting打开设置 Editor > Code Style > Line separator (for new lines): Unix and OS X (n) 确保idea使用utf-8编码 安装Docker插件。在File-Settings-Plugins中，搜索Docker integration，点击Install安装，并重启软件加载插件 IDEA中配置Docker，在File-Settings-Build Execution Deployment-Clouds中，点击加号新建，会自动读取docker信息，直接保存即可 其他软件安装 除了基本的软件之外，其他基础软件可以通过官网下载安装包，也可以通过docker启动镜像。choerodon建议通过docker 启动。 在本地创建docker-compose的运行路径 编写docker-compose.yaml 文件 打开git bash 执行docker-compose up -d 执行docker ps 或docker-compose ps 查看容器是否启动 这里提供一份默认的mysql 配置和docker-compose.yaml 配置。 # mysql_db.cnf [mysqld] lower_case_table_names=1 character_set_server=utf8 max_connections=500 # docker-compose.yaml version: \"3\" services: zookeeper-0: container_name: zookeeper-0 image: registry.cn-hangzhou.aliyuncs.com/choerodon-tools/zookeeper:3.4.10 hostname: zookeeper-0 environment: - ZK_REPLICAS=1 - ZK_HEAP_SIZE=2G - ZK_TICK_TIME=2000 - ZK_INIT_LIMIT=10 - ZK_SYNC_LIMIT=5 - ZK_MAX_CLIENT_CNXNS=60 - ZK_SNAP_RETAIN_COUNT=3 - ZK_PURGE_INTERVAL=1 - ZK_LOG_LEVEL=INFO - ZK_CLIENT_PORT=2181 - ZK_SERVER_PORT=2888 - ZK_ELECTION_PORT=3888 ports: - \"2181:2181\" - \"2888:2888\" - \"3888:3888\" command: - sh - -c - zkGenConfig.sh && exec zkServer.sh start-foreground volumes: - \"./kafka/zk:/var/lib/zookeeper\" kafka-0: container_name: kafka-0 image: registry.cn-hangzhou.aliyuncs.com/choerodon-tools/kafka:1.0.0 hostname: 127.0.0.1 depends_on: - zookeeper-0 links: - zookeeper-0 ports: - \"9092:9092\" command: - sh - -c - \"/opt/kafka/bin/kafka-server-start.sh config/server.properties \\ --override zookeeper.connect=zookeeper-0:2181 \\ --override log.dirs=/opt/kafka/data/logs \\ --override broker.id=0 \" volumes: - \"./kafka/kafka:/opt/kafka/data\" mysql: container_name: mysql image: registry.cn-hangzhou.aliyuncs.com/choerodon-tools/mysql:5.7.17 ports: - \"3306:3306\" environment: MYSQL_ROOT_PASSWORD: root volumes: - ./mysql/mysql_data:/var/lib/mysql - ./mysql/mysql_db.cnf:/etc/mysql/conf.d/mysql_db.cnf 停止容器通过命令docker-compose down。 有关Docker的更多信息请见此处 有关Docker-Compose的更多信息请见此处 "},"/docs/development-guide/backend/intergration/":{"url":"docs/development-guide/backend/intergration/","title":"测试与集成","description":"","body":"前置条件 在集成之前，要保证： 环境已经安装正确，详见 开发环境搭建 Demo已正确编写，详见 开发Demo程序 介绍 在Demo编写完成之后，本章介绍了如何将Demo与Choerodon 集成，并介绍了如何使用swagger 进行接口测试。 "},"/docs/development-guide/backend/intergration/init":{"url":"docs/development-guide/backend/intergration/init","title":"数据初始化","date":"2018-04-25T11:00:28+08:00","body":"启动容器 首先确保 mysql 容器已经启动，详见 开发环境搭建 介绍 本小节介绍了如何初始化Choerodon 的数据库 创建Mysql数据库 1.查看容器，确认存在容器名为mysql的容器 2.用choerodon用户命令行登陆 mysql 容器，密码为 123456 docker exec -ti mysql mysql -u choerodon -p 3.创建用户和数据库: CREATE DATABASE iam_service DEFAULT CHARACTER SET utf8; CREATE DATABASE manager_service DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON iam_service.* TO choerodon@'%'; GRANT ALL PRIVILEGES ON manager_service.* TO choerodon@'%'; FLUSH PRIVILEGES; 查看用户与数据库 mysql> select User from mysql.user; +-----------+ | User | +-----------+ | choerodon | | root | | mysql.sys | +-----------+ 3 rows in set (0.00 sec) mysql> show databases; +-----------------------------+ | Database | +-----------------------------+ | information_schema | | iam_service | | manager_service | | choerodon_demo_service_todo | | mysql | | performance_schema | | sys | +-----------------------------+ 7 rows in set (0.01 sec) 初始化数据库 需初始化manager-service，iam-service两个数据库，此处以manager-service为例。 新建初始化数据库临时目录，如：managerInit cd managerInit，新建sh脚本init-local-database，以下提供脚本示例，具体请根据本地配置修改。 init-local-database.sh: #!/usr/bin/env bash mkdir -p target curl https://oss.sonatype.org/content/groups/public/io/choerodon/choerodon-tool-liquibase/0.5.0.RELEASE/choerodon-tool-liquibase-0.5.0.RELEASE.jar -o target/choerodon-tool-liquibase.jar curl https://oss.sonatype.org/content/groups/public/io/choerodon/choerodon-tool-liquibase/0.5.0.RELEASE/choerodon-tool-liquibase-0.5.0.RELEASE.jar -o target/manager-service.jar java -Dspring.datasource.url=\"jdbc:mysql://localhost/manager_service?useUnicode=true&characterEncoding=utf-8&useSSL=false\" \\ -Dspring.datasource.username=choerodon \\ -Dspring.datasource.password=123456 \\ -Ddata.drop=false -Ddata.init=init \\ -Ddata.jar=target/manager-service.jar \\ -jar target/choerodon-tool-liquibase.jar 执行命令:sh init-local-database.sh 命令执行成功之后，刷新 manager_service 数据库，会出现初始化脚本中的表以及初始化数据 "},"/docs/development-guide/backend/intergration/intergration_swagger":{"url":"docs/development-guide/backend/intergration/intergration_swagger","title":"集成与测试","date":"2018-04-27T15:58:28+08:00","body":"前提 在开发之前，请确保 Demo程序已经开发完毕，详见 开发Demo程序 数据库创建成功，详见 初始化数据库 Choerodon 的其他服务已经启动，详见模块运行 Eureka服务发现 如需添加Eureka服务发现，需在CHOERODON-TODO-SERVICE中进行两步修改： 在TodoServiceApplication 上添加@EnableEurekaClient 注解 在TodoServiceApplication 上添加@ChoerodonRoute注解 @EnableEurekaClient @ChoerodonRoute(name = \"dev\" path = \"/todo/**\" serviceId = \"choerodon-todo-service\") 在bootstrap.yml中添加关于Eureka的配置 eureka: instance: preferIpAddress: true leaseRenewalIntervalInSeconds: 1 leaseExpirationDurationInSeconds: 3 client: serviceUrl: defaultZone: ${EUREKA_DEFAULT_ZONE:http://localhost:8000/eureka/} 重启Todo服务 如果上述步骤执行无误，可在本地的 http://localhost:8000/ 查看注册成功的服务: OAUTH-SERVER API-GATEWAY-TEST CHOERODON-TODO-SERVICE REGISTER-SERVER GATEWAY-HELPER swagger Api服务 使用swagger测试需启动manager-service模块，在docker-compose.yaml中加入此容器并重启所有模块 manager-service: container_name: manager-service image: registry.choerodon.io/choerodon-framework/manager-service:0.1.0 ports: - \"8963:8963\" Note. 启动顺序：基础软件mysql、kafka等 ，eureka-server服务，manager-service，api-gateway，其余模块。 打开 http://localhost:8963/swagger-ui.html 该地址端口号为Eurake上对应端口号 打开任意一个api，点击右边红色的叹号对调用该api进行授权（勾选default scope） 在弹出界面输入用户名密码，本地默认为admin/admin 在这里便可以对controller中声明的api进行测试，这一步需启动gateway-helper "},"/docs/development-guide/backend/intergration/run":{"url":"docs/development-guide/backend/intergration/run","title":"模块运行","date":"2018-04-25T11:00:28+08:00","body":"前置条件 开发环境配置：开发环境安装 数据环境准备：数据初始化 Demo程序已经开发完毕，详见 开发Demo程序 启动 mysql，redis，kafka等容器 介绍 本小节介绍如何在本地使用docker compose运行choerodon 微服务开发框架，并启动demo程序 启动相关服务 要使功能完整可用，在本地至少启动如下模块 register api-gateway gateway-helper oauth 编写docker-compose.yaml 文件 打开git bash 执行docker-compose up -d 执行docker ps 或docker-compose ps 查看容器是否启动 这里提供一份docker-compose.yaml以供参考，具体根据本地配置进行修改 # docker-compose.yaml version: \"3\" services: eureka-server: container_name: eureka-server image: registry.choerodon.io/choerodon-framework/eureka-server:0.1.0 hostname: 127.0.0.1 ports: - \"8000:8000\" api-gateway: container_name: api-gateway image: registry.choerodon.io/choerodon-framework/api-gateway:0.1.0 ports: - \"8080:8080\" environment: - zuul.addHostHeader=true - zuul.routes.dev.path=/todo/** - zuul.routes.dev.serviceId=choerodon-todo-service oauth-server: container_name: oauth-server image: registry.choerodon.io/choerodon-framework/oauth-server:0.1.0 ports: - \"8020:8020\" gateway-helper: container_name: gateway-helper image: registry.choerodon.io/choerodon-framework/gateway-helper:0.1.0 ports: - \"9180:9180\" 停止容器通过命令docker-compose down。 有关Docker的更多信息请见此处 有关Docker-Compose的更多信息请见此处 启动todo服务 进入choerodon-todo-service目录下，运行以下命令启动本地项目 mvn clean spring-boot:run "},"/docs/development-guide/front/":{"url":"docs/development-guide/front/","title":"前端开发手册","description":"前端开发手册","body":"介绍 本页面介绍了使用Choerodon 微服务开发框架，来开发一个简单的前端服务。包含了本地开发环境搭建，基础环境搭建，开发新功能。每个模块都包含了其主要功能、操作流程及其他注意事项。 功能 开发环境搭建 讲述了如何在本地搭建开发环境，以支撑我们在本地进行前端服务开发。 基础环境搭建 讲述了前端代码运行情况和目录结构的说明介绍。 开发新功能 介绍了如何开发新的页面，如何建立并开发新的模块和系统平台的相关配置项。 "},"/docs/development-guide/front/basic-env/":{"url":"docs/development-guide/front/basic-env/","title":"基础环境准备","description":"基础环境准备","body":"前置条件 在开发之前，要保证环境已经安装正确，详见 开发环境搭建 介绍 本章节介绍了软件环境安装准备，代码运行情况和目录结构的说明介绍。 功能 软件准备 讲述了安装nodejs 之后，需要通过nodejs 安装Choerodon需要的软件。 代码运行 讲述了如何在本地获取Choerodon 的前端代码，并运行起来。 结构说明 讲述了Choerodon 的前端目录结构，并对每一层进行了说明。 "},"/docs/development-guide/front/basic-env/run":{"url":"docs/development-guide/front/basic-env/run","title":"代码运行","description":"代码运行","body":"前置条件 在开发之前，要保证环境已经安装正确，详见 开发环境搭建 克隆代码 可以新建一个 choerodon-cloud-front 的目录，进入到该目录下，在终端执行 git clone https://xxxx@choerodon.io/gitlab/HAPCloud/HAPCloudFront.git --recursive 其中 xxxx 是你的github账号。 运行代码 进入到项目根目录，打开终端，键入sh boot/structure/moduleCi.sh boot iam。 在终端中执行命令 npm run gulp [15:35:03] Starting 'watch'... [15:35:03] Finished 'watch' after 91 ms 不要关闭该终端(在iam等其他模块项目中源文件发生修改时，gulp会自动检测修改并同步)，新开一个git bash同样在该目录下执行 npm run dev 启动项目，看到如图所示效果说明启动成功 npm run dev 运行成功如下显示: Hash: cfe31cfb37f523377d0c Version: webpack 2.7.0 Time: 54546ms Entrypoint main = app/vendor_cfe31cfb.js app/main_cfe31cfb.js webpack: Compiled successfully. 提示: (可以通过 npm run gulp:clean 删除所有自动生成的文件 再通过 npm run gulp 来重新生成，再重新启动 npm start，这样可以解决有时页面未更新的状态) 查看效果 在浏览器中键入 localhost:9090，查看页面效果。 "},"/docs/development-guide/front/basic-env/software":{"url":"docs/development-guide/front/basic-env/software","title":"软件准备","description":"软件准备","body":"前置条件 在开发之前，要保证环境已经安装正确，详见 开发环境搭建 包管理工具 npm是Node.js的包管理工具（package manager），可以根据依赖关系，把前端所有依赖的包都下载下来并管理起来。 npm已经在Node.js安装的时候顺带装好了。 提示 npm 需要跟上命令。这样确保npm正确安装了，能运行就行。 可以自行安装cnpm 和 yarn 进行包管理控制 全局安装 yeoman yeoman 是一个通用的脚手架系统允许创建任何类型的应用程序。它允许迅速开始新的项目 简化了维护现有项目。 在项目中，yeoman 用于自动生成与boot同级的模块目录和文件。 使用 npm -g install yo 安装yeoman 安装成功后，在终端里运行 yo --version 应该可以看到yeoman的相关信息。 全局安装 gulp Gulp 是一个自动化构建工具 开发者可以使用它在项目开发过程中自动执行常见任务。 使用 npm -g install Gulp 安装Gulp 安装成功后，在终端里运行 Gulp --version 应该可以看到Gulp的相关信息。 "},"/docs/development-guide/front/basic-env/structure":{"url":"docs/development-guide/front/basic-env/structure","title":"结构说明","description":"结构说明","body":"前置条件 请确保已经将代码clone 到本地。详见 代码运行 结构说明 目录划分 开发仿照iam项目结构（推荐通过yo命令自动生成目录结构，节省自动建立目录时间），源文件目录在 iam/src/app/iam ，主要目录结构如下： ├── src │ └── app │ └── iam │ ├── assets │ │ ├── css │ │ └── images │ ├── components │ │ ├── loadingBar │ │ ├── memberRole │ │ └── menuType │ ├── config │ │ ├── Menu.yml │ │ └── language │ ├── containers │ │ ├── Home.js │ │ ├── IAMIndex.js │ │ ├── Masters.js │ │ ├── global │ │ ├── master.css │ │ ├── organization │ │ ├── project │ │ └── user │ ├── locale │ │ ├── en.js │ │ └── zh.js │ ├── stores │ │ ├── globalStores │ │ ├── organization │ │ ├── project │ │ └── user │ └── test │ └── util ├── package-lock.json ├── package.json ├── tsconfig.json └── yarn.lock assets 中css存放模块通用样式表 images存放图片资源 containers 存放前端的页面 stores 存放前端页面所需的数据 common 存放公共的配置文件 components 存放的是公共的组件 local 存放模块多语言文件 config 存放Menu.yml配置文件(包括菜单的code icon 跳转Route 菜单的权限)和language中的中英文yml(zh.yml en.yml) test 存放测试文件 "},"/docs/development-guide/front/develop-env/":{"url":"docs/development-guide/front/develop-env/","title":"开发环境搭建","description":"开发环境搭建","body":"介绍 本章节介绍了基于开发的基本工具与其具体安装配置。通过此章节，用户可完成前端基本开发环境的搭建。 功能 软件安装(mac) 讲述了如何在Mac OS 环境下搭建本地开发环境。 软件安装(Windows) 讲述了如何在windows 环境下搭建本地开发环境。 "},"/docs/development-guide/front/develop-env/install_mac":{"url":"docs/development-guide/front/develop-env/install_mac","title":"开发环境搭建(Mac)","description":"开发环境搭建(Mac)","body":"开发环境搭建(Mac) 本章节讲述了使用Choerodon 做前端开发所需要的一些软件依赖，以及如何在Mac OS 环境下进行安装使用。 开发工具 Git Node.js 8.11.1及以上版本 python 安装提前准备 在HomeBrew官网下载或者根据文档安装homebrew。 Git 安装 在 Git 官网下载Mac平台的Git。 运行 brew install git 安装git。 安装完成后打开终端后执行 git --version ，有提示则说明环境安装成功。 node 安装 在 Node.js官网下载用于Mac平台的安装包。 运行 brew install node 安装node。 配置完成后打开终端执行 node --version，有提示则说明环境安装成功。 在Macn上安装python 在项目中 python(2.7.X)用于执行功能性脚本。 在python 官网 下载2.7版本的python 安装包。 运行brew install python@2 安装python。 配置完成后打开 git bash 执行 python，有提示则说明环境安装成功。 "},"/docs/development-guide/front/develop-env/install_windows":{"url":"docs/development-guide/front/develop-env/install_windows","title":"开发环境搭建(Windows)","description":"开发环境搭建(Windows)","body":"开发环境搭建(Windows) 本章节讲述了使用Choerodon 做前端开发所需要的一些软件依赖，以及如何在Windows 环境下进行安装使用。 开发工具 Git Node.js 8.11.1及以上版本 python Git 安装 在 Git 官网 下载对应平台的 Git。 本地执行安装文件，安装 Git 环境。 配置完成后打开 git bash 执行 git --version ，有提示则说明环境安装成功。 对于 Windows，安装 Git 以后，你可以在任意目录右键，选择Git Bash Here。 打开的 MINGW 命令窗口可以执行兼容 linux 系统的命令。 node 安装 在 Node.js官网 下载用于Windows平台的安装包。 本地执行安装文件。 配置完成后打开 git bash 执行 node --version，有提示则说明环境安装成功。 在Windows上安装python Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。 在项目中，python用于执行功能性脚本。 在python 官网 下载2.7版本的python 安装包。 本地执行安装文件。 配置完成后打开 git bash 执行 python，有提示则说明环境安装成功。 "},"/docs/development-guide/front/new-func/":{"url":"docs/development-guide/front/new-func/","title":"开发新功能","description":"开发新功能","body":"前置条件 在开发之前，要保证： 环境已经安装正确，开发环境搭建 基础环境已经准备完成，基础环境准备 介绍 本章节介绍了如何开发新的页面，如何建立并开发新的模块和系统平台的相关配置项。 功能 开发新模块 讲述了如何使用Choerodon 和React 开发一个新的模块。 开发新页面 讲述了如何使用Choerodon 和React 开发一个全新的页面。 项目配置项 对Choerodon 微服务开发框架前端的配置项进行了说明。 "},"/docs/development-guide/front/new-func/new_module":{"url":"docs/development-guide/front/new-func/new_module","title":"开发新模块","description":"开发新模块","body":"介绍 本章节讲述了如何使用Choerodon 和React 开发一个全新的模块。 开发新模块 切换到boot/generator-hap的目录下，运行 npm link 。 在项目根目录，运行 yo hap 则会出现需要输入和选择的信息。 注意: 在后面文档中 模块名默认输入的是demo 如果输入的其他的模块名 相应替换便可。此时会自动构建模块的结构 进入到 boot 的目录下 运行 npm run gulp 之后运行 npm start 启动项目 在 localhost:9090/#/demo 便可以查看页面。 其中 输入的模块名 + Index 文件是必须的，该文件的命名规则为 模块名的大写 + Index ，如若模块名为test，则该文件应命名为TESTIndex.js，这是在gulp的配置文件中规定的。 在继续开发新页面，请查看开发新页面文档 如果开发模块需要其他的第三方安装包 可以直接在当前模块添加安装。 "},"/docs/development-guide/front/new-func/new_page":{"url":"docs/development-guide/front/new-func/new_page","title":"开发新页面","description":"开发新页面","body":"前置条件 在开发新页面之前，要确保已经在本地创建了新的模块。详见 开发新模块 介绍 本章节讲述了如何使用Choerodon 和React 开发一个全新的页面。包含如下内容： 菜单配置 页面编写 配置路由 获取后台数据 前台数据渲染 菜单配置 前端新加模块和页面，想在菜单中显示需要跟后端沟通各种事宜与配置，大大增加了开发效率与成本。在此版本中，只需要简单配置，菜单数据完全由前端控制。 在模块内部创建config文件夹，目录结构为: ├── language | ├── en.yml | └── zh.yml | └── Menu.yml language 菜单中英文配置文件夹 en.yml 英文菜单 zh.yml 中文菜单 Menu.yml 菜单配置项 Menu.yml文件内容看起来是这样的: \"iam\": # 此处为最外层的模块服务字段 icon: account_circle # 服务的图标 global: # global层的菜单 - \"role\": # 菜单字段 icon: assignment_ind # 菜单图标 Routes: /iam/role # 菜单对应路由 permission: # 菜单内容具有的权限 - 'iam-service.role.update' organization: # 组织层的菜单 - \"client\": icon: laptop_mac Routes: /iam/client permission: - 'iam-service.client.create' - 'iam-service.client.update' - 'iam-service.client.delete' - 'iam-service.client.select' project: # 项目层的菜单 - \"member-role-project\": icon: person_add Routes: /iam/projectMemberRole permission: - 'iam-service.member-role-project.create' - 'iam-service.member-role-project.delete' - 'iam-service.member-role-project.select' - 'iam-service.member-role-project.update' user: # 个人中心层的菜单 - \"user-info\": icon: more Routes: /iam/user/info permission: - 'iam-service.user-info.querySelf' - 'iam-service.user-info.updateSelf' en.yml文件内容: \"iam\": IAM \"iam.client\": \"Client\" \"iam.member-role-project\": \"Role Assignment\" \"iam.role\": \"Role\" \"iam.user-info\": \"User Information Maintenance\" 模板为[服务字段].[菜单字段]: [菜单英文名] zh.yml文件内容: \"iam\": \"用户服务\" \"iam.client\": \"客户端\" \"iam.member-role-project\": \"角色分配\" \"iam.role\": \"角色\" \"iam.user-info\": \"用户信息维护\" 在项目根目录下，执行python .\\boot\\structure\\configAuto.py iam(确保python版本为2.7.x 以及本地安装pyyaml包)脚本。 成功之后在项目根目录会生成config.yml文件。 然后再执行python ./boot/structure/pythonsql.py -i ip地址 -p 端口号 -u 用户名 -s 密码 在部署时候也可通过环境变量进行传递参数 变量名 说明 DB_HOST 用户名 DB_PORT 端口 DB_USER 用户名 DB_PASS 密码 成功后，会将前端配置的菜单信息插入后端数据库中。 如果要显示插入的菜单，需要在全局层的菜单配置下，进行页面操作，将数据已有的菜单展示在菜单列。 页面编写 此例子在组织层创建新页面 如果需要在其他层级创建页面，同理自行创建 在 /iam/src/app/iam/containers/organization(project user global)目录下新建一个新的功能文件夹demo及其相关的JS文件: // Demo.js文件 import React { Component } from 'react'; import { withRouter } from 'react-router-dom'; class Demo extends Component { render() { return ( {'Hello it is a demo!'} ); } } export default withRouter(Demo); // DemoIndex.js文件 import React from 'react'; import { Route Switch } from 'react-router-dom'; import asyncRouter from '../../../../../util/asyncRouter'; const Demo = asyncRouter(()=>import('./Demo')); const DemoIndex = ({ match }) => ( ); export default DemoIndex; 配置路由 在/iam/sr/app/iam/containers/IAMIndex.js文件中配置新建文件的访问路径： ... // 在头部引入异步路由模块 const DemoIndex = asyncRouter(()=>import('./organization/demo/DemoIndex')); //在下面路由中进行编写设置 ... ... 注意： 本次demo的访问路径应该为： /iam/demo ，因为在gulp自动生成路由配置时，IAMIndex的路由被映射为iam，配置完路由信息后就可以使用url访问刚刚新建的文件了。 获取后台数据 文件可以被访问后，接下来就是完善界面信息，从后台获取数据。获取数据的方法都写在和文件对应的store文件中。 axios()函数 axios()可以设置全局的配置，例如请求头信息，拦截器等，这样的好处是可以避免重复配置。 // store/organization/demo/DemoStore.js文件 import { observable action computed } from 'mobx'; // 该axios是封装过的，设置了请求头信息和响应拦截器 import axios from 'Axios'; import store from 'Store'; // store注解符令组件可以通过DemoStore来找到该store @store('DemoStore') class DemoStore { @observable roles = []; @computed get getRoles() { return this.roles.slice(); } @action setRoles(data) { this.roles = data; } loadRole() { axios.get('uaa/v1/roles?page=0&size=100').then((data) => { if (data) { this.setRoles(data.content); } }); } } const demoStore = new DemoStore(); export default demoStore; 更多关于axios()的相关信息可以参考：https://www.npmjs.com/package/axios 前端数据渲染 拿到后台数据后就可以将数据渲染到界面了，下面将介绍如何将数据渲染到前端界面： 加载DemoStore 修改/iam/src/app/iam/containers/organization/demo/DemoIndex.js，添加添加异步加载DemoStore： // DemoIndex.js文件 import React from 'react'; import { Route Switch } from 'react-router-dom'; import asyncRouter from '../../../../../util/asyncRouter'; // DemoIndex.js文件中异步加载DemoStore const Demo = asyncRouter(() => import('./Demo') () => import('../../../stores/organization/demo/DemoStore')); const DemoIndex = ({ match }) => ( ); export default DemoIndex; 获取数据并渲染 在 react 的状态处理函数 componentDidMount() 中调用 loadRoles 函数获取数据，此时才真正拿到后台的数据。数据被存储在了组件的 props.DemoStore.roles 中。我们可以在 render() 中（或者在任何 componentDidMount() 函数之后执行的函数中）通过console.log(this.props.DemoStore.getRoles())查看拿到的数据。 componentDidMount(){ this.props.DemoStore.loadRoles(); } 最终的demo界面源码如下： import React { Component } from 'react'; import { Table } from 'antd'; import { observer } from 'mobx-react'; import { withRouter } from 'react-router-dom'; @observer class Demo extends Component { componentDidMount() { this.props.DemoStore.loadRole(); } render() { const columns = [{ title: HAP.languageChange('role.name') dataIndex: 'name' key: 'name' } { title: HAP.languageChange('role.level') dataIndex: 'roleLevel' key: 'roleLevel' } { title: HAP.languageChange('role.description') dataIndex: 'description' key: 'description' } { title: HAP.languageChange('role.serviceName') dataIndex: 'serviceName' key: 'serviceName' }]; return ( ); } } // withRouter添加history支持 export default withRouter(Demo); -->"},"/docs/development-guide/front/new-func/project_setting":{"url":"docs/development-guide/front/new-func/project_setting","title":"项目配置项","description":"项目配置项","body":"前置条件 在开发新页面之前，要确保已经在本地创建了新的模块。详见 开发新模块 介绍 本章节介绍了choerodon 的默认配置项，并对配置项进行了说明。 新建或覆盖全局配置 在项目根目录右键git bash here 输入yo choerodon:1.3.0，根据提示 键入各个配置项参数，完成后将会覆盖原有config文件。 配置项详解 为了应对不同开发环境和不同项目需求，可以对choerodon框架多个配置进行个性化。 配置项文件在项目根目录的config.js文件中。看起来是这样的 const config = { local: false clientId: 'localhost' titlename: 'choerodon-framework' favicon: 'a.png' theme: true mainCss: JSON.stringify('boot') Masters: JSON.stringify('boot') Home: JSON.stringify('iam') themeSetting: { antdTheme: { 'primary-color': '#3b78e7' } header: '#3F51B5' backgroundColor: 'white' } server: '' }; module.exports = config; 参数 说明 local 是否本地开发，如果是true，点击本地开发没有的模块菜单，会跳转到404，否则会跳转已发布的线上域名 clientId 认证成功之后的回调参数，对应后端的回调地址 titlename 标签页名称 favicon 标签页图标 theme 是否开启主题色设定 mainCss 选择哪个模块的主css文件 Masters 选择哪个模块的master.js文件作为入口文件 Home 选择哪个模块的Home.js文件作为Home页 primary-color antd的主体颜色设定 header 头部主题色 backgroundColor 背景色 server 后端的api host地址 "},"/docs/development-guide/platform/":{"url":"docs/development-guide/platform/","title":"平台开发手册","description":"平台开发手册","body":"介绍 本手册介绍了如何向我们报告Issues，和如何帮助我们改进我们的程序。 Reporting Issues Choerodon 使用GitHub 来记录bugs 和feature requests，如果你想要提出一个issue，请遵循如下建议： 在你记录一个bug之前，请先在Github中检索是有已经有人提过同样的问题 如果这个issue不存在，请创建一个新的issue 请尽可能地提供多的信息和问题说明，同时提供您正在使用的版本，以及您的操作系统和JVM版本 如果你要提供代码，请使用Markdown格式 贡献 如果想要向我们贡献您的代码，您可以将代码fork 到自己的Git库中，然后向我们发起pull request。本地开发请遵循如下规范： 后端文件结构规范 Java 开发规范 SQL 规范 Restful Api 规范 前端开发规范 后端文件结构规范 Choerodon 的微服务，采用DDD 的设计思想，整体架构如下图所示： 从上往下整体分为四层： 展现层： 主要用于用户显示信息，处理用户发送的Restful请求信息（用户命令），并将信息传递给Application层的接口。这里指的用户可以是另一个计算机系统，不一定是使用用户界面的人。 在本系统实现程序上主要包括： controller 接受用户restful请求 dto 封装用户请求的数据信息 validator 验证用户请求信息的合法性 eventhandler 领域事件接收处理器 应用层： 完成展现层指定的任务，并且调用领域对象或服务来解决问题。这一层所负责的工作对业务来说意义重大，也是与其它系统的应用层进行交互的必要渠道。应用层要尽量简单，不包含业务规则或者知识，而只为下一层中的领域对象协调任务，分配工作，使它们互相协作。 在本系统实现程序上主要包括： service 调用领域对象或服务来解决问题，应用层Service主要有以下特性： 1. 负责事务处理，所以事务的注解可以在这一层的service中使用。 2. 只处理非业务逻辑，重点是调度业务处理流程。业务逻辑处理一定要放在领域层处理。 3. 不做单元测试，只做验收测试。 4. 可能会有比较多的依赖组件(领域服务)，使用field注入依赖的组件。 5. 方法要求无状态，只接受dto和元数据类型作为参数。 领域模型层： 负责表达业务概念，业务状态信息以及业务规则。尽管保存业务状态的技术细节是由基础设施层实现的，但是反映业务情况的状态是由本层控制并且使用的。领域层是业务软件的核心，领域模型位于这一层。 在本系统实现程序上主要包括： entity convertor event reposity 基础设施层： 向其他层提供通用的技术能力，为应用层传递消息，为领域层提供持久化机制，为用户界面层绘制屏幕组件，等等。基础设施层还能够通过架构框架来支持四个层次间的交互模式。 在本系统实现程序上主要包括： mapper dataobject fegin common config Java 开发规范 Choerodon 的后端主要以Java 为主，您所开发的Java 程序需要生效SonarQube的规范检查和CheckStyle的规范检查： SonarQube 的规范检查，SonarQube提供应用程序的能力，可以通过SonarQube 显示程序的健康程度和质量。你可以修复泄漏，系统地提高代码质量。Choerodon 使用sonarlint作为SonarQube的检查。 CheckStyle 的规范检查，Checkstyle是一个开发工具来帮助程序员编写Java代码 提供了统一的编码标准。Choerodon 提供一份自己的checkStyle 文件。choerodon_checkStyle.xml SQL 规范 Choerodon 的数据库采用MySql，同时使用Liquibase 和groovy 作为数据库管理工具。如果您的提交涉及到表结构的修改，请遵循如下规范： SQL 规范 groovy 规范 Choerodon 采用groovy 来编写数据库初始化脚本。需要遵循如下规范： 每一张表对应一个groovy文件 groovy文件的路径应存放在服务的/src/resources/db/script 路径下 groovy changeSet 的id ：'yyyy-MM-dd-table_name'，author：`your@gmail.com` groovy 遵循liquibase语法。更多有关liquibase的信息请参照liquibase官网 Restful Api 规范 Choerodon 的微服务之间，采用HTTP/REST 的请求作为数据传输。接口需要遵循Rest 原则: Restful Api 规范 前端开发规范 CSS 规范：Choerodon 的前端采用 stylelint 作为CSS 语法检查。同时遵循如下规范： 选择Sass作为预处理 禁止使用CSS in JS CSS命名规范 .choerodon-元素块-修饰符 test JavaScript规范: Choerodon 的前端采用 Eslint 作为JavaScript 的语法规范。同时命名遵循如下规范： 常量全部大写： const ENV = 'production' 变量全都小写: const tablename = 'table' 函数首字母小写其余首字母大写：fixColor(id color) {} 类名驼峰： class ClientEdit{} 其他规范： HTML 使用语义化标签，禁止滥用Div，Span 不在覆盖第三方开源UI库的样式 尽量使用lodash函数工具包 函数功能单一，且在每个函数必须写明注释，注释包含函数功能 参数说明。 /* 修改节点的颜色 id:节点id color: 颜色 */ function fixColor(id color) { id.style.color = color } 文件结构：所有页面和组件目录结构使用如下结构 ├── ClientIndex.js ├── clientCreate │ ├── ClientCreate.js │ ├── ClientCreate.scss │ └── index.js ├── clientDetail │ ├── ClientDetail.js │ ├── ClientDetail.scss │ └── index.js ├── clientEdit │ ├── EditClient.js │ ├── EditClient.scss │ └── index.js ├── clientHome │ ├── Client.js │ ├── Client.scss │ └── index.js ├── components └── index.js "},"/docs/development-guide/platform/restful":{"url":"docs/development-guide/platform/restful","title":"Restful Api 规范","description":"Restful Api 规范","body":"Restful Api 规范 Choerodon 符合 REST 原则，它是一个RESTful 架构。 RESTful API Design 名词定义 Resource: 一个简单的实例。有一些属性或者一些子资源，子资源可以是 一个简单的资源或者一组资源例如：book user Collection: 一组同类的资源对象。例如：books users HTTP: 网络协议 HTTP Verbs GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新完整的资源（客户端提供改变后的完整资源）。 DELETE（DELETE）：从服务器删除资源。 Resource Oriented Design 设计流程 确定一个api提供什么类型的资源 确定资源之间的依赖关系 基于类型和依赖关系确定资源的命名 确定资源的结构 为资源添加最少的方法 Resource Names 资源是一个实体对象，那么资源名就是这个资源的标识。 一个资源名应该由Resource ID，Collection ID 和API Service 名组成。 例1：存储服务有 buckets 的集合 其中每个桶包含一个 objects 集合。 API Service Name Collection ID Resource ID Sub-Collection ID Sub-Resource ID //gateway.com.cn/storage /buckets /bucket-id /objects /object-id 例2：电子邮件服务用户的集合。sub-resource 每个用户都有一个设置 设置 sub-resource 有许多其他的子资源 包括 customFrom: API Service Name Collection ID Resource ID Sub-Collection ID Sub-Resource ID //gateway.com.cn/mails /users /name@example.com /settings /customFrom 全名：//gateway.com.cn/storage/buckets/1/materials/wood 相对名：buckets/1/materials/wood HTTP URL：http://gateway.com.cn/storage/v1/buckets/1/materials/wood Resource ID Resource ID 标识着资源属于父资源中。 Resource ID 可能不止一个单词，也有可能是一个相对路径。 Resource ID 必须清楚地被记录，无论是客户端 服务器 或第三方。 Collection ID Collection ID 必须是有效的程序标识符。 Collection ID 必须是驼峰形式的复数结构，如果没有复数形式，应使用单数。 Collection ID 必须是清晰简洁的英文单词。 Collection ID 避免使用笼统的表示，例如objects、values、types。 Action 命名规范 基本规范 使用\"/\"表示层级关系 url 不能以\"/\"结尾 url 中不能包含空格\"\" url 中不能以文件后缀结尾 url 中字母小写，单词间加下划线 不要再url中添加CRUD 类别 Description Action Name HTTP Mapping HTTP Request Body HTTP Response Body 查询所有 list GET N/A Resource* list 获取单个资源 query GET N/A Resource* 创建单个资源 create POST Resource Resource* 更新单个资源 update PUT Resource Resource* 删除单个资源 delete DELETE N/A Empty List List 方法接受一个 Collection id 和0或多个参数作为输入 并返回一个列表的资源。 List 必须使用 GET 方法 接口必须以 collection id 结尾。 其他的请求字段必须作为 url 查询参数。 没有请求体，接口上必须不能包含request body。 响应体应该包含一组资源和一些可选项元数据。 Query Query 方法接受一个 Resource name 和0或多个参数 并返回指定的资源。 Query 必须使 GET 方法。 请求url 必须包含 Resource name。 其他的请求字段必须作为 url 查询参数。 没有请求体，接口上必须不能包含request body。 响应体应该返回整个资源对象。 Create Create 方法接受一个 Collection id 一个资源 和0或多个参数。它创建一个新的资源在指定的父资源下 并返回新创建的资源。 Create 必须使用 POST 方法。 应该包含父资源名用于指定资源创建的位置。 创建的资源应该对应在request body。 响应体应该返回整个资源对象。 Create 必须传递一个resource，这样即使resource 的结构发生变化，也不需要去更新方法或者资源结构，那些弃用的字段则需要标识为“只读”。 Update Update 方法接受一个资源和0或多个参数。更新指定的资源和其属性 并返回更新的资源。 除了Resource Name 和其父资源之外，这个资源的所有属性应该是可以更新的。资源的重命名和移动则需要自定义方法。 如果只支持一个完整对象的更新，Update 必须使用 PUT 方法。 Resource Name必须包含在请求的url中。 资源应该对应在request body。 Delete Delete 方法接受一个Resource Name 和0或多个参数 并删除指定的资源。 Delete 必须使用 DELETE 方法。 Resource Name 必须包含在请求的url中。 没有请求体，接口上必须不能包含request body。 如果是立即删除，应该返回空 如果是启动一个删除操作，应该返回一个删除操作。 如果只是标识某个资源是“被删除的”，应该返回一个更新后的资源。 如果多个删除请求删除同一资源，那么只有第一个请求才应该成功，其他的返回not found。 自定义方法 自定义的方法应该参考5个基本方法。应该用于基本方法不能实现的功能性方法。可能需要一个任意请求并返回一个任意的响应 也可能是流媒体请求和响应。 可以对应a resource a collection 甚至 a service。 自定义方法应该使用 POST 方法。不应该使用PATCH 方法。 自定义方法对应的 Resource Name 或者 Collection id 必须包含在请求的url中。 如果使用的HTTP 方法接受request body，则需要对应一个请求体。 如果使用的HTTP 方法不接受request body，则需要声明不使用body，并且参数应该作为url查询参数。 批量添加 Description Action Name HTTP Mapping HTTP Request Body HTTP Response Body 批量添加 batchCreate POST /batch_create Resource* list Resource IDS 批量删除 Description Action Name HTTP Mapping HTTP Request Body HTTP Response Body 批量删除 batchDelete POST /batch_delete Resource IDS Empty 更新单个资源中的属性 Description Action Name HTTP Mapping HTTP Request Body HTTP Response Body 更新资源的状态 updateAttribute POST /:attribute?value= N/A {\"key\":\"\" \"value\":\"\"} 更新用户的年龄 updateAge POST /v1/users/1/age?value=20 N/A {\"key\":\"age\" \"value\":\"20\"} 对资源执行某一动作 比如发送消息，启用什么功能。 如果是针对资源，则Action Name为动词。 如果是针对资源的属性，则Action Name为动词+属性名。请求以动词结尾，属性作为参数。 Description Action Name HTTP Mapping HTTP Request Body HTTP Response Body 对资源执行某一动作 customVerb POST /custom_verb N/A * 取消某种操作 cancel POST /cancel N/A Boolean 从回收站中恢复一个资源 undelete POST /v1/projects/1/undelete N/A Boolean 检查项目是否重名 checkName POST /v1/projects/1/check?name= N/A 查询某一资源的单个属性 对于单个资源的所有的查询Action Name，都需要以query开头。 Action Name以query+属性名结尾 Description Action Name HTTP Mapping HTTP Request Body HTTP Response Body 查询资源的某属性 queryAttribute GET /:attribute N/A {\"key\":\"\" \"value\":\"\"} 查询用户的年龄 queryAge GET /v1/users/1/age N/A {\"key\":\"age\" \"value\":\"25\"} 查询用户下的项目 queryProjects GET /v1/users/1/projects N/A {\"key\":\"projects\" \"value\":[]} 查询collection 的数量 计算集合自身的数量，使用count作为Action Name 计算资源中子集合的数量，使用count+集合名作为Action Name Description Action Name HTTP Mapping HTTP Request Body HTTP Response Body 查询Collection 的数量 count GET /count N/A {\"key\":\"\" \"count\":\"\"} 查询组织的数目 count GET /v1/organizations/count N/A {\"key\":\"organizations\" \"count\":\"100\"} 查询用户下的所有项目数量 countProjects GET /v1/users/1/projects/count N/A {\"key\":\"projects\" \"count\":\"100\"} 复杂条件查询 对于collection的所有查询Action Name，都需要以list开头。 查询的条件中，如果条件为一到两个，使用By和And。eg.: listByUserIdAndName 如果查询条件大于3个，则使用ByOptions，查询条件作为请求体传入。eg.: listByOptions 版本控制 主版本号必须作为包名的最后一个字符。如：com.hand.controller.v1。 版本兼容的修改： 添加一个服务接口 添加一个api方法 添加一个请求字段 添加一个相应字段 添加一个字段的枚举值 版本不兼容的修改： 删除或重命名一个服务，接口，方法，枚举值 改变一种HTTP method 改变字段的类型 改变一个resource name Demo @RestController(\"/v1/users\") public class UserController { @GetMapping(\"/\") public ResponseEntity list() { return null; } @GetMapping(\"/{id}\") public User query(@PathVariable(\"id\") String id) { return null; } @PostMapping(\"/\") public ResponseEntity create(@RequestBody User user) { return null; } @PutMapping(\"/{id}\") public ResponseEntity update(@PathVariable(\"id\") String id @RequestBody User user) { return null; } @DeleteMapping(\"/{id}\") public ResponseEntity delete(@PathVariable(\"id\") String id) { return null; } @PostMapping(\"/batch_create\") public ResponseEntity batchCreate(@RequestBody List users) { return null; } @PostMapping(\"/batch_delete\") public ResponseEntity batchDelete(@RequestBody List users) { return null; } @PostMapping(\"/age\") public ResponseEntity updateAge(@RequestParam(\"value\") Integer age) { return null; } @PostMapping(\"/{:id}/undelete\") public ResponseEntity undelete(@PathVariable(\"id\") String id) { return null; } @PostMapping(\"/check\") public ResponseEntity checkName(@RequestParam(\"name\") String name) { return null; } @GetMapping(\"/{:id}/age\") public ResponseEntity queryAge(@PathVariable(\"id\") String id) { return null; } @GetMapping(\"/{:id}/name\") public ResponseEntity queryByUserIdAndName(@PathVariable(\"id\") String id @RequestParam(\"name\") String name) { return null; } @GetMapping(\"/{:id}/projects/count\") public ResponseEntity countProjects(@PathVariable(\"id\") String id @RequestParam(\"name\") String name) { return null; } @GetMapping(\"/\") public ResponseEntity listByOptions(@RequestBody Map options) { return null; } } "},"/docs/development-guide/platform/sql":{"url":"docs/development-guide/platform/sql","title":"SQL 规范","description":"SQL 规范","body":"SQL 规范 建表规约 强制要求 表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint （1 表示是， 0 表示否）。 说明： 任何字段如果为非负数，必须是 unsigned。 正例： 表达逻辑删除的字段名 is_deleted， 1 表示删除， 0 表示未删除。 表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。 数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 说明： MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。 正例： choerodon_admin， level3_name 反例： choerodonAdmin，level_3_name 表名不使用复数名词。 说明： 表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。 禁用保留字，如 desc、 range、 match、 delayed 等， 请参考 MySQL 官方保留字。 主键索引名为 pk_字段名； 唯一索引名为 uk_字段名； 普通索引名则为 idx_字段名。 说明： pk_ 即 primary key； uk_ 即 unique key； idx_ 即 index 的简称。 小数类型为 decimal，禁止使用 float 和 double。 说明： float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。 如果存储的字符串长度几乎相等，使用 char 定长字符串类型。 varchar 是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。 说明： 该表的命名以 原表名_字段缩写 的格式命名。 表必备字段： id create_date last_update_date create_by last_update_by object_version_number。 说明： 其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。 create_date last_update_date 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被动更新。 column(name: \"object_version_number\" type: \"BIGINT UNSIGNED\" defaultValue: \"1\") column(name: \"created_by\" type: \"BIGINT UNSIGNED\" defaultValue: \"0\") column(name: \"creation_date\" type: \"DATETIME\" defaultValueComputed: \"CURRENT_TIMESTAMP\") column(name: \"last_updated_by\" type: \"BIGINT UNSIGNED\" defaultValue: \"0\") column(name: \"last_update_date\" type: \"DATETIME\" defaultValueComputed: \"CURRENT_TIMESTAMP\") 表的命名最好是加上“业务名称_表的作用”。 正例： kanban_task / devops_project / website_config 推荐规约 库名与应用名称尽量一致。 如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。 字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循： 不是频繁修改的字段。 不是 varchar 超长字段，更不能是 text 字段。 正例： 商品类目名称使用频率高， 字段长度短，名称基本一成不变， 可在相关联的表中冗余存储类目名称，避免关联查询。 单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 说明： 如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 规约参考 合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。 正例： 如下表，其中无符号值可以避免误存负数，且扩大了表示范围。 |对象|年龄区间|类型|字节|表示范围| |----|--------|----|----|--------| |人|150岁之内|unsigned tinyint|1|无符号值： 0 到 255| |龟|数百岁|unsigned smallint|2|无符号值： 0 到 65535| |恐龙化石|数千万年|unsigned int|4|无符号值： 0 到约 42.9 亿| |太阳|约 50 亿年|unsigned bigint|8|无符号值： 0 到约 10 的 19 次方| 索引规约 强制要求 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。 超过三个表禁止join。需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。 说明：即使双表join也要注意表索引、SQL性能。 在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。 说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达90%以上，可以使用 count(distinct left(列名 索引长度))/count(*)的区分度来确定。 页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。 说明：索引文件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。 推荐规约 如果有order by的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。 正例： where a=? and b=? order by c; 索引： a_b_c 反例： 索引中有范围查找，那么索引有序性无法利用，如： WHERE a>10 ORDER BY b; 索引a_b无法排序。 利用覆盖索引来进行查询操作， 避免回表。 说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。 正例：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用explain 的结果，extra 列会出现： using index。 利用延迟关联或者子查询优化超多分页场景。 说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前offset行，返回N行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。 正例：先快速定位需要获取的 id 段，然后再关联： SELECT a.* FROM 表 1 a (select id from 表 1 where 条件 LIMIT 100000 20 ) b where a.id=b.id SQL 性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。 说明： consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 ref 指的是使用普通的索引（normal index） 。 range 对索引进行范围检索。 反例： explain 表的结果， type=index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。 建组合索引的时候，区分度最高的在最左边。 正例： 如果 where a=? and b=? ， a列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。 说明： 存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如： where a>? and b=? 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。 防止因字段类型不同造成的隐式转换，导致索引失效。 规约参考 创建索引时避免有如下极端误解： 宁滥勿缺。 认为一个查询就需要建一个索引。 宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。 抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。 SQL 语句 强制要求 不要使用 count(列名)或 count(常量)来替代 count(\\*)， count(*)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。 说明： count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。 count(distinct col) 计算该列除 NULL 之外的不重复行数， 注意 count(distinct col1 col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。 当某一列的值全是 NULL 时， count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。 正例： 可以使用如下方式来避免 sum 的 NPE 问题： SELECT IF(ISNULL(SUM(g)) 0 SUM(g)) FROM table; 使用 ISNULL()来判断是否为 NULL 值。 说明： NULL 与任何值的直接比较都为 NULL。 NULL<>NULL 的返回结果是 NULL， 而不是 false。 NULL=NULL 的返回结果是 NULL， 而不是 true。 NULL<>1 的返回结果是 NULL，而不是 true。 在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。 不得使用外键与级联，一切外键概念必须在应用层解决。 说明：以学生和成绩的关系为例，学生表中的 student_id是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新， 即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险:外键影响数据库的插入速度。 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。 数据订正（特别是删除、 修改记录操作） 时，要先 select，避免出现误删除，确认无误才能执行更新语句。 推荐规约 in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。 规约参考 如果有全球化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数的区别。 说明： SELECT LENGTH(\"轻松工作\")；\\\\返回为 12 SELECT CHARACTER_LENGTH(\"轻松工作\")；\\\\返回为 4 如果需要存储表情，那么选择 utf8mb4 来进行存储，注意它与 utf-8 编码的区别。 不建议在开发代码中使用此语句 TRUNCATE TABLE TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。 说明： TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。 ORM 映射 强制要求 在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。 说明： 增加查询分析器解析成本. 增减字段容易与 resultMap 配置不一致。 POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行 字段与属性之间的映射。 不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。 说明： 配置映射关系，使字段与 DO 类解耦，方便维护。 sql.xml 配置参数使用： #{}， #param# 不要使用${} 此种方式容易出现 SQL 注入。 iBATIS 自带的 queryForList(String statementName int start int size)不推荐使用。 说明：其实现方式是在数据库取到 statementName对应的SQL语句的所有记录，再通过 subList 取 start size 的子集合。 正例： Map map = new HashMap(); map.put(\"start\" start); map.put(\"size\" size); 不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。 说明： resultClass=”Hashtable”， 会置入字段名和属性值，但是值的类型不可控。 更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。 推荐规约 不要写一个大而全的数据更新接口。 传入为 POJO 类，不管是不是自己的目标更新字 段，都进行 update table set c1=value1 c2=value2 c3=value3; 这是不对的。执行 SQL时， 不要更新无改动的字段，一是易出错； 二是效率低； 三是增加 binlog 存储。 规约参考 @Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。 中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带上此条件； 表示不为空且不为 null 时执行；表示不为 null 值时执行。 "},"/docs/installation-configuration/":{"url":"docs/installation-configuration/","title":"安装与配置","date":"2018-03-30T05:06:38.000Z","description":"安装与配置","body":"安装与配置 Choerodon采用Spring Cloud作为微服务框架，运行在Docker上，以Kubernetes作为容器的编排工具。理论上只要服务器资源允许，可以运行Kubernetes，就可以运行Choerodon。Choerodon不是一个单体应用系统，而是一个包含多个微服务的分布式系统，所以安装相对比较复杂。目前，我们提供基于Helm的安装方式，以提高安装效率。 前置要求与约定 节点信息： 系统版本：CentOS7.2及以上版本 CPU数量：4C 内存信息：16G 节点数量：4 注意： 只要现有节点内存与CPU总和大于上述节点要求即可。 约定：安装教程以nfs类型的PV为例进行创建，所有非集群级对象都创建在io-choerodon命名空间下。 系统组件图 在部署之前 我们先来看一下Choerodon的系统组件图。关于Choerodon的详细系统架构，请参考系统架构。 开始部署 Kubernetes集群部署 Helm安装 Chartmuseum安装 Minio安装 Redis安装 Mysql安装 Zookeeper安装 kafka安装 Harbor安装 Gitlab安装 Choerodon安装 "},"/docs/installation-configuration/chartmuseum":{"url":"docs/installation-configuration/chartmuseum","title":"Chartmuseum安装","description":"Chartmuseum安装","body":"Chartmuseum安装 仓库设置 本地添加远程仓库 helm repo add c7n http://helm-charts.choerodon.io/c7n/base/ 更新本地仓库信息 helm repo update 安装Chartmuseum 注意： 启用持久化存储请执行提前创建PV和PVC，也可使用以下语句进行创建；由于choerodon-devops-service的储存必须与chartmuseum存储路径相同，在此我们一并创建。可在安装命令最后添加--debug --dry-run参数，进行渲染预览不进行安装。 创建PV helm install c7n/create-pv \\ --set type=nfs \\ --set pv.name=chartmuseum-pv \\ --set nfs.path=/u01/nfs/exports/io-choerodon/chartmuseum \\ --set nfs.server=nfs.exmple.choerodon.io \\ --set pvc.name=chartmuseum-pvc \\ --set size=3Gi \\ --set \"accessModes[0]=ReadWriteOnce\" \\ --name chartmuseum-pv --namespace=io-choerodon helm install c7n/create-pv \\ --set type=nfs \\ --set pv.name=devops-service-pv \\ --set nfs.path=/u01/nfs/exports/io-choerodon/chartmuseum \\ --set nfs.server=nfs.exmple.choerodon.io \\ --set pvc.name=devops-service-pvc \\ --set size=3Gi \\ --set \"accessModes[0]=ReadWriteOnce\" \\ --name devops-service-pv --namespace=io-choerodon 进行安装部署 helm install c7n/chartmuseum \\ --set persistence.enabled=true \\ --set persistence.existingClaim=chartmuseum-pvc \\ --set ingress.enabled=true \\ --set ingress.host=charts.exmple.choerodon.io \\ --set env.open.DISABLE_API=false \\ --set env.open.DEPTH=2 \\ --name chartmuseum --namespace=io-choerodon 参数解释： | 参数 | 含义 | --- | --- | persistence.enabled|是否启用持久化存储 persistence.existingClaim|PVC的名称 ingress.enabled|是否启用ingress ingress.host|域名 env.open.DISABLE_API|是否禁用API env.open.DEPTH|大于0则表示开启多租户，数值代表层级 "},"/docs/installation-configuration/choerodon":{"url":"docs/installation-configuration/choerodon","title":"Choerodon安装","description":"Choerodon安装","body":"部署Choerodon 创建value.sh文件，定义以下变量及值。注意正式搭建时请替换以下值为真实值。 # 仅debug不安装，删除此变量则进行安装 DEBUG=\"--debug --dry-run\" # 设置部署的namespace NAMESPACE=\"io-choerodon\" # 域名配置 CHOERODON_API_URL=\"api.exmple.choerodon.io\" CHOERODON_FRONT_URL=\"choerodon.exmple.choerodon.io\" # 组件信息 CHARTS_URL=\"http://charts.exmple.choerodon.io\" # minio信息 MINIO_URL=\"http://minio.exmple.choerodon.io\" MINIO_USERNAME=\"admin\" MINIO_PASSWORD=\"password\" # gitlab信息 GITLAB_URL=\"http://git.exmple.choerodon.io\" GITLAB_TOKEN=\"sw1W4jywyxsvkHYRGBBp\" # harbor信息 HARBOR_URL=\"https://registry.exmple.choerodon.io\" HARBOR_USERNAME=\"admin\" HARBOR_PASSWORD=\"Password123\" # 定义Redis FRAMEWORK_REDIS_HOST='framework-redis' DEVOPS_REDIS_HOST='devops-redis' # 定义zookeeper、kafka ZOOKEEPER_URL=\"zookeeper-0.zookeeper-headless.io-choerodon.svc.cluster.local:2181\" KAFKA_URL=\"kafka-0.kafka-headless.io-choerodon.svc.cluster.local:9092\" # 存储配置设置 此路径需要与charts DEVOPS_SERVICE_PVC=\"devops-service-pvc\" # 定义数据库 # 格式为（数据库地址 数据库端口号 数据库用户名 数据库用户密码 数据库名） # choerodon-iam-service数据库 IAM_SERVICE_DB=(\"choerodon-mysql\" \"3306\" \"iam_service\" \"choerodon\" \"password\") # choerodon-manager-service数据库 MANAGER_SERVICE_DB=(\"choerodon-mysql\" \"3306\" \"manager_service\" \"choerodon\" \"password\") # choerodon-event-store-service数据库 EVENT_STORE_SERVICE_DB=(\"choerodon-mysql\" \"3306\" \"event_store_service\" \"choerodon\" \"password\") # choerodon-devops-service数据库 DEVOPS_SERVICE_DB=(\"choerodon-mysql\" \"3306\" \"devops_service\" \"choerodon\" \"password\") # choerodon-gitlab-service数据库 GITLAB_SERVICE_DB=(\"choerodon-mysql\" \"3306\" \"gitlab_service\" \"choerodon\" \"password\") 执行以下命令进行安装 curl -o choerodon-install.sh \\ https://choerodon.io/gitlab/io.choerodon/choerodon-docs/raw/master/content/docs/infra/installation/install.sh && \\ sh choerodon-install.sh value.sh 添加前端Client 在访问搭建好的Choerodon的api，api.exmple.choerodon.io/manager/swagger-ui.html，选择iam_service -> client-controller -> 创建client 认证请使用用户名：admin，密码：admin 提交以下数据，注意正式搭建时请替换以下值为真实值 ```json { \"accessTokenValidity\": 60 \"additionalInformation\": \"\" \"authorizedGrantTypes\": \"implicit client_credentials authorization_code refresh_token\" \"autoApprove\": \"default\" \"name\": \"choerodonparent\" \"objectVersionNumber\": 0 \"organizationId\": 1 \"refreshTokenValidity\": 60 \"resourceIds\": \"default\" \"scope\": \"default\" \"secret\": \"secret\" \"webServerRedirectUri\": \"http://choerodon.exmple.choerodon.io\" } ``` 部署失败操作 请执行以下语句后重试 helm del --purge api-gateway helm del --purge choerodon-front-parent helm del --purge config-server helm del --purge devops-service helm del --purge event-store-service helm del --purge file-service helm del --purge gateway-helper helm del --purge gitlab-service helm del --purge hystrix-dashboard helm del --purge hystrix-turbine helm del --purge iam-service helm del --purge manager-service helm del --purge oauth-server helm del --purge register-server kubectl delete job -n io-choerodon --all "},"/docs/installation-configuration/gitlab":{"url":"docs/installation-configuration/gitlab","title":"Gitlab安装","description":"Gitlab安装","body":"Gitlab安装 仓库设置 本地添加远程仓库 helm repo add c7n http://helm-charts.choerodon.io/c7n/base/ 更新本地仓库信息 helm repo update 安装Gitlab 注意：启用持久化存储请执行提前创建所指向的物理地址，PV和PVC可使用以下语句进行创建；可在安装命令中添加--debug --dry-run参数，进行渲染预览不进行安装。 创建gitlab所需PV和PVC helm install c7n/create-pv \\ --set type=nfs \\ --set pv.name=gitlab-pv \\ --set nfs.path=/u01/nfs/exports/io-choerodon/gitlab \\ --set nfs.server=nfs.exmple.choerodon.io \\ --set pvc.name=gitlab-pvc \\ --set size=3Gi \\ --set \"accessModes[0]=ReadWriteOnce\" \\ --name gitlab-pv --namespace=io-choerodon 创建数据库 CREATE USER 'gitlab'@'%' IDENTIFIED BY \"password\"; CREATE DATABASE gitlabhq_production DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON gitlabhq_production.* TO choerodon@'%'; FLUSH PRIVILEGES; 部署gitlab helm install c7n/gitlab \\ --set persistence.enabled=true \\ --set persistence.existingClaim=gitlab-pvc \\ --set env.config.GITLAB_EXTERNAL_URL=http://gitlab.exmple.choerodon.io \\ --set env.config.GITLAB_TIMEZONE=Asia/Shanghai \\ --set env.config.GITLAB_DEFAULT_CAN_CREATE_GROUP=true \\ --set env.config.MYSQL_HOST=mysql \\ --set env.config.MYSQL_PORT=3306 \\ --set env.config.MYSQL_USERNAME=gitlab \\ --set env.config.MYSQL_PASSWORD=password \\ --set env.config.MYSQL_DATABASE=gitlabhq_production \\ --set env.config.REDIS_HOST=redis \\ --set env.config.REDIS_PORT=6379 \\ --set env.config.SMTP_ENABLE=true \\ --set env.config.SMTP_ADDRESS=smtp.mxhichina.com \\ --set env.config.SMTP_PORT=465 \\ --set env.config.SMTP_USER_NAME=git.sys@example.com \\ --set env.config.SMTP_PASSWORD=password \\ --set env.config.SMTP_DOMAIN=smtp.mxhichina.com \\ --set env.config.SMTP_AUTHENTICATION=login \\ --set env.config.GITLAB_EMAIL_FROM=git.sys@example.com \\ --set env.config.SMTP_ENABLE_STARTTLS_AUTO=true \\ --set env.config.SMTP_TLS=true \\ --set env.config.PROMETHEUS_ENABLE=false \\ --set env.config.NODE_EXPORTER_ENABLE=false \\ --set ingress.enabled=true \\ --set ingress.hosts[0]=gitlab.exmple.choerodon.io \\ --name=gitlab --namespace=io-choerodon 参数 参数 | 含义 --- | --- persistence.enabled|是否启用持久化存储 persistence.existingClaim|PVC的名称 env.config.GITLAB_EXTERNAL_URL|gitlab的域名 env.config.GITLAB_TIMEZONE|时区 env.config.GITLAB_DEFAULT_CAN_CREATE_GROUP|用户是否可以创建组 env.config.CHOERODON_OMNIAUTH_ENABLED|是否开启第三方认证 env.config.OMNIAUTH_BLOCK_AUTO_CREATED_USERS|是否自动创建用户 env.config.CHOERODON_API_URL|choerodon的Api地址 env.config.CHOERODON_CLIENT_ID|在choerodon上申请的client id env.config.MYSQL_HOST|mysql地址 env.config.MYSQL_PORT|mysql端口号 env.config.MYSQL_USERNAME|mysql用户名 env.config.MYSQL_PASSWORD|mysql用户密码 env.config.REDIS_HOST|redis地址 env.config.REDIS_PORT|redis端口号 env.config.SMTP_ENABLE|是否开启smtp env.config.SMTP_ADDRESS|smtp地址 env.config.SMTP_PORT|smtp端口号 env.config.SMTP_USER_NAME|stmp用户 env.config.SMTP_PASSWORD|stmp用户密码 env.config.SMTP_DOMAIN|smtp地址 env.config.SMTP_AUTHENTICATION|认证方式 env.config.GITLAB_EMAIL_FROM|设置发件人email env.config.SMTP_ENABLE_STARTTLS_AUTO|是否自动启用TLS env.config.SMTP_TLS|是否启用TLS env.config.PROMETHEUS_ENABLE|是否开启prometheus env.config.NODE_EXPORTER_ENABLE|是否开启node_exporter_enable ingress.enabled|是否开启ingress ingress.hosts[0]|gitlab的域名 使用Choerodon进行认证登陆 执行以下语句更新Gitlab部署 helm upgrade gitlab c7n/gitlab \\ --set persistence.enabled=true \\ --set persistence.existingClaim=gitlab-pvc \\ --set env.config.GITLAB_EXTERNAL_URL=http://gitlab.exmple.choerodon.io \\ --set env.config.GITLAB_TIMEZONE=Asia/Shanghai \\ --set env.config.GITLAB_DEFAULT_CAN_CREATE_GROUP=true \\ --set env.config.CHOERODON_OMNIAUTH_ENABLED=true \\ --set env.config.OMNIAUTH_AUTO_SIGN_IN_WITH_PROVIDER=oauth2_generic \\ --set env.config.OMNIAUTH_BLOCK_AUTO_CREATED_USERS=false \\ --set env.config.CHOERODON_API_URL=http://choerodon.exmple.choerodon.io \\ --set env.config.CHOERODON_CLIENT_ID=gitlab \\ --set env.config.MYSQL_HOST=mysql \\ --set env.config.MYSQL_PORT=3306 \\ --set env.config.MYSQL_USERNAME=gitlab \\ --set env.config.MYSQL_PASSWORD=password \\ --set env.config.MYSQL_DATABASE=gitlabhq_production \\ --set env.config.REDIS_HOST=redis \\ --set env.config.REDIS_PORT=6379 \\ --set env.config.SMTP_ENABLE=true \\ --set env.config.SMTP_ADDRESS=smtp.mxhichina.com \\ --set env.config.SMTP_PORT=465 \\ --set env.config.SMTP_USER_NAME=git.sys@example.com \\ --set env.config.SMTP_PASSWORD=password \\ --set env.config.SMTP_DOMAIN=smtp.mxhichina.com \\ --set env.config.SMTP_AUTHENTICATION=login \\ --set env.config.GITLAB_EMAIL_FROM=git.sys@example.com \\ --set env.config.SMTP_ENABLE_STARTTLS_AUTO=true \\ --set env.config.SMTP_TLS=true \\ --set env.config.PROMETHEUS_ENABLE=false \\ --set env.config.NODE_EXPORTER_ENABLE=false \\ --set ingress.enabled=true \\ --set ingress.hosts[0]=gitlab.exmple.choerodon.io \\ 添加Gitlab Client 在访问搭建好的Choerodon的api，api.exmple.choerodon.io/manager/swagger-ui.html，选择iam_service -> client-controller -> 创建client 认证请使用用户名：admin，密码：admin 提交以下数据，注意正式搭建时请替换以下值为真实值 ```json { \"accessTokenValidity\": 60 \"additionalInformation\": \"\" \"authorizedGrantTypes\": \"implicit client_credentials authorization_code refresh_token\" \"autoApprove\": \"default\" \"name\": \"gitlab\" \"objectVersionNumber\": 0 \"organizationId\": 1 \"refreshTokenValidity\": 60 \"resourceIds\": \"default\" \"scope\": \"default\" \"secret\": \"secret\" \"webServerRedirectUri\": \"http://gitlab.exmple.choerodon.io\" } ``` "},"/docs/installation-configuration/harbor":{"url":"docs/installation-configuration/harbor","title":"Harbor安装","description":"Harbor安装","body":"Harbor安装 仓库设置 本地添加远程仓库 helm repo add c7n http://helm-charts.choerodon.io/c7n/base/ 更新本地仓库信息 helm repo update 安装Harbor 注意：启用持久化存储请执行提前创建所指向的物理地址，PV和PVC可使用以下语句进行创建；可在安装命令中添加--debug --dry-run参数，进行渲染预览不进行安装。 创建harbor所需PV和PVC helm install c7n/create-pv \\ --set type=nfs \\ --set pv.name=harbor-adminserver-pv \\ --set nfs.path=/u01/nfs/exports/io-choerodon/harbor-adminserver \\ --set nfs.server=nfs.exmple.choerodon.io \\ --set pvc.enable=false \\ --set size=3Gi \\ --set \"accessModes[0]=ReadWriteOnce\" \\ --name harbor-adminserver-pv --namespace=io-choerodon helm install c7n/create-pv \\ --set type=nfs \\ --set pv.name=harbor-mysql-pv \\ --set nfs.path=/u01/nfs/exports/io-choerodon/harbor-mysql \\ --set nfs.server=nfs.exmple.choerodon.io \\ --set pvc.enable=false \\ --set size=3Gi \\ --set \"accessModes[0]=ReadWriteOnce\" \\ --name harbor-mysql-pv --namespace=io-choerodon helm install c7n/create-pv \\ --set type=nfs \\ --set pv.name=harbor-registry-pv \\ --set nfs.path=/u01/nfs/exports/io-choerodon/harbor-registry \\ --set nfs.server=nfs.exmple.choerodon.io \\ --set pvc.enable=false \\ --set size=3Gi \\ --set \"accessModes[0]=ReadWriteOnce\" \\ --name harbor-registry-pv --namespace=io-choerodon helm install c7n/create-pv \\ --set type=nfs \\ --set pv.name=harbor-notary-pv \\ --set nfs.path=/u01/nfs/exports/io-choerodon/harbor-notary \\ --set nfs.server=nfs.exmple.choerodon.io \\ --set pvc.enable=false \\ --set size=5Gi \\ --set \"accessModes[0]=ReadWriteOnce\" \\ --name harbor-notary-pv --namespace=io-choerodon helm install c7n/create-pv \\ --set type=nfs \\ --set pv.name=harbor-postgresql-pv \\ --set nfs.path=/u01/nfs/exports/io-choerodon/harbor-postgresql \\ --set nfs.server=nfs.exmple.choerodon.io \\ --set pvc.name=harbor-postgresql-pvc \\ --set size=1Gi \\ --set \"accessModes[0]=ReadWriteOnce\" \\ --name harbor-postgresql-pv --namespace=io-choerodon 部署harbor helm install c7n/harbor \\ --set persistence.enabled=true \\ --set externalDomain=harbor.my.domain \\ --set adminserver.adminPassword=Harbor12345 \\ --set adminserver.volumes.config.selector.pv=\"harbor-adminserver-pv\" \\ --set mysql.volumes.config.selector.pv=\"harbor-mysql-pv\" \\ --set registry.volumes.config.selector.pv=\"harbor-registry-pv\" \\ --set notary.db.volumes.data.selector.pv=\"harbor-notary-pv\" \\ --set postgresql.persistence.enabled=true \\ --set postgresql.persistence.existingClaim=\"harbor-postgresql-pvc\" \\ --set insecureRegistry=true \\ --name=harbor --namespace=io-choerodon 参数： 参数 | 含义 --- | --- externalDomain|Harbor域名 adminserver.adminPassword|admin用户密码 persistence.enabled|是否起启用数据持久化 adminserver.volumes.config.selector|adminserver创建的pvc选pv的选择器值，为pv的label mysql.volumes.config.selector|mysql创建的pvc选pv的选择器值，为pv的label registry.volumes.config.selector|registry创建的pvc选pv的选择器值，为pv的label postgresql.persistence.enabled|是否启用postgresql数据持久化 postgresql.persistence.existingClaim|postgresql将要绑定的pvc的name notary.volumes.config.selector|notary创建的pvc选pv的选择器值，为pv的label clair.enabled|是否启用clair notary.enabled|是否启用notary "},"/docs/installation-configuration/helm-chart":{"url":"docs/installation-configuration/helm-chart","title":"Helm Chart","description":"Helm Chart","body":"--> Helm Chart 应用 版本 APP版本 依赖 redis 0.1.0 3.2.9 mysql 0.1.0 5.6 harbor 0.1.0 1.4.0 kafka 0.1.0 1.0.0 zookeeper 0.1.0 3.4.10 gitlab 0.1.0 10.2.1 安装说明 baseUrl: 泛解析到集群的基础域名 移除*. 如*.example.com写作example.com storageType: 指定存储类型，包括glusterfs nfs和host 创建一个pv helm install create-pv --set pv.name=test-pv-01 --set glusterfs.path=gv1/alpha 参数(等号后边为默认值)： --set type=glusterfs 指定pv类型可选glusterfs、nfs --set \"endpoint.ip[0]\"=80.0.0.111 endpoint.ip[1]\"=80.0.0.112 指定endpoint ip --set glusterfs.path= 指定glusterfs路径 --set glusterfs.endpoints=glusterfs-cluster 指定glusterfs endpoints --set glusterfs.endpoints=glusterfs-cluster 指定glusterfs endpoints --set size=40Gi 指定大小 --set pvc.enable=true 是否创建pvc --set endpoints.enable=true 是否创建endpoints --set labels.xxx=aaa yyy=bbb pv添加额外的标签 --set accessModes[0]=ReadWriteMany 访问模式 微服务 cloud框架 默认以sit配置进行部署。sit为staging环境配置。 如需要替换启动环境请按如下配置替换\"sit\"字样： --set \"env.open.SPRING_PROFILES_ACTIVE\"=sit 替换环境变量需按如下格式修改： --set \"env.open.FOO_BAR\"=value --set 指令可以替换的参数如下： 参数 含义 replicaCount 服务副本数 image.repository 镜像地址 image.tag 镜像标签 image.pullPolicy 镜像拉取策略 deployment.managementPort 管理端口地址 service.type svc类型 service.port 服务启动端口地址 resources.limits.memory 最大内存 resources.requests.memory 请求内存 下列参数根据服务不同可能需要： 参数 含义 preJob.preConfig.configFile 初始化配置文件 preJob.preConfig.mysql.host 初始化配置数据库地址 preJob.preConfig.mysql.port 初始化配置数据库端口 preJob.preConfig.mysql.database 初始化配置数据库名 preJob.preConfig.mysql.username 初始化配置数据库用户名 preJob.preConfig.mysql.password 初始化配置数据库用户密码 preJob.preInitDB.mysql.host 初始化表数据库地址 preJob.preInitDB.mysql.port 初始化表数据库端口 preJob.preInitDB.mysql.database 初始化表数据库名 preJob.preInitDB.mysql.username 初始化表数据库用户名 preJob.preInitDB.mysql.password 初始化表数据库用户密码 register-server helm install go-register-server/chart/register-server --namespace=io-choerodon 注册服务可使用 KAFKA_ADDRESSES 环境变量配置Kafka地址。 manager服务 helm install manager-service/chart/manager-service --namespace=framework manager服务需初始化配置。 manager服务需初始化表。 config-server helm install config-server/chart/config-server --namespace=framework api-gateway api-gateway服务需初始化配置。 helm install api-gateway/chart/api-gateway --namespace=framework gateway-helper gateway-helper服务需初始化配置。 helm install gateway-helper/chart/gateway-helper --namespace=framework iam服务 iam服务需初始化配置。 iam服务需初始化表。 helm install iam-service/chart/iam-service --namespace=framework oauth-server oauth-server需初始化配置。 helm install oauth-server/chart/oauth-server --namespace=framework event-store服务 event-store服务需初始化配置。 event-store服务需初始化表。 helm install event-store-service/chart/event-store-service --namespace=framework file服务 file服务需初始化配置。 helm install file-service/chart/file-service --namespace=framework hystrix-dashboard hystrix-dashboard服务需初始化配置。 helm install hystrix-dashboard/chart/hystrix-dashboard --namespace=framework hystrix-turbine hystrix-turbine服务需初始化配置。 helm install hystrix-turbine/chart/hystrix-turbine --namespace=framework usermap-service 创建一个数据库名称为 usermap_service CREATE USER 'root'@'%' IDENTIFIED BY \"password\"; CREATE DATABASE usermap_service DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON usermap_service.* TO root@'%'; FLUSH PRIVILEGES; 注意默认环境变量，一般情况下CHOERODON_GATEWAY_DOMAIN，CHOERODON_SWAGGER_OAUTH_URL需要修改，其他变量根据实际情况确定是否需要修改 EUREKA_DEFAULT_ZONE: http://register-server.io-choerodon:8000/eureka/ SPRING_DATASOURCE_URL: jdbc:mysql://kanban-mysql.db.svc:3308/usermap_service?useUnicode=true&characterEncoding=utf-8&useSSL=false SPRING_DATASOURCE_USERNAME: root SPRING_DATASOURCE_PASSWORD: password CHOERODON_EVENT_CONSUMER_KAFKA_BOOTSTRAP_SERVERS: kafka-0.kafka-headless.kafka.svc.cluster.local:9092 kafka-1.kafka-headless.kafka.svc.cluster.local:9092 kafka-2.kafka-headless.kafka.svc.cluster.local:9092 SPRING_CLOUD_STREAM_KAFKA_BINDER_BROKERS: kafka-0.kafka-headless.kafka.svc.cluster.local:9092 kafka-1.kafka-headless.kafka.svc.cluster.local:9092 kafka-2.kafka-headless.kafka.svc.cluster.local:9092 SPRING_CLOUD_STREAM_KAFKA_BINDER_ZK_NODES: zookeeper-0.zookeeper-headless.zookeeper.svc.cluster.local:2181 zookeeper-1.zookeeper-headless.zookeeper.svc.cluster.local:2181 zookeeper-2.zookeeper-headless.zookeeper.svc.cluster.local:2181 SPRING_KAFKA_PRODUCER_VALUE_SERIALIZER: org.apache.kafka.common.serialization.ByteArraySerializer SPRING_CLOUD_CONFIG_URI: http://config-server.framework:8010/ ZUUL_ROUTES_MANAGER_PATH: \"/usermap/**\" ZUUL_ROUTES_MANAGER_SERVICE_ID: usermap-service CHOERODON_GATEWAY_DOMAIN: api.exmple.choerodon.io CHOERODON_SWAGGER_OAUTH_URL: http://api.exmple.choerodon.io/iam/oauth/authorize SPRING_PROFILES_ACTIVE: default 安装 helm install . --debug --namespace=scrum --name=usermap_service --set env.open.CHOERODON_GATEWAY_DOMAIN=\"gateway.alpha.exmple.choerodon.io\" --set env.open.CHOERODON_SWAGGER_OAUTH_URL=\"http://gateway.staging.exmple.choerodon.io/iam/oauth/authorize\" scrum-service 创建一个数据库名称为 scrum_service CREATE USER 'root'@'%' IDENTIFIED BY \"password\"; CREATE DATABASE scrum_service DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON scrum_service.* TO root@'%'; FLUSH PRIVILEGES; 注意默认环境变量根据实际情况确定是否需要修改 EUREKA_DEFAULT_ZONE: http://register-server.io-choerodon:8000/eureka/ SPRING_DATASOURCE_URL: jdbc:mysql://kanban-mysql.db.svc:3308/scrum_service?useUnicode=true&characterEncoding=utf-8&useSSL=false SPRING_DATASOURCE_USERNAME: root SPRING_DATASOURCE_PASSWORD: password CHOERODON_EVENT_CONSUMER_KAFKA_BOOTSTRAP_SERVERS: kafka-0.kafka-headless.kafka.svc.cluster.local:9092 kafka-1.kafka-headless.kafka.svc.cluster.local:9092 kafka-2.kafka-headless.kafka.svc.cluster.local:9092 SPRING_CLOUD_STREAM_KAFKA_BINDER_BROKERS: kafka-0.kafka-headless.kafka.svc.cluster.local:9092 kafka-1.kafka-headless.kafka.svc.cluster.local:9092 kafka-2.kafka-headless.kafka.svc.cluster.local:9092 SPRING_CLOUD_STREAM_KAFKA_BINDER_ZK_NODES: zookeeper-0.zookeeper-headless.zookeeper.svc.cluster.local:2181 zookeeper-1.zookeeper-headless.zookeeper.svc.cluster.local:2181 zookeeper-2.zookeeper-headless.zookeeper.svc.cluster.local:2181 SPRING_KAFKA_PRODUCER_VALUE_SERIALIZER: org.apache.kafka.common.serialization.ByteArraySerializer SPRING_CLOUD_CONFIG_URI: http://config-server.framework:8010/ ZUUL_ROUTES_MANAGER_PATH: \"/usermap/**\" ZUUL_ROUTES_MANAGER_SERVICE_ID: usermap-service CHOERODON_GATEWAY_DOMAIN: api.exmple.choerodon.io CHOERODON_SWAGGER_OAUTH_URL: http://api.exmple.choerodon.io/iam/oauth/authorize SPRING_PROFILES_ACTIVE: default 安装 helm install . --namespace=scrum --name=scrum-service "},"/docs/installation-configuration/helm":{"url":"docs/installation-configuration/helm","title":"Helm安装","description":"Helm安装","body":"Helm安装 前置要求 安装helm客户端的主机可以通过kubectl命令管理kubernetes集群。 创建ServiceAccount 服务端端执行 kubectl create serviceaccount --namespace kube-system helm-tiller kubectl create clusterrolebinding helm-tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:helm-tiller 安装客户端 客户端执行 根据系统下载所需版本 https://github.com/kubernetes/helm/releases/tag/v2.8.2 解压压缩包（以linux-amd64为例） tar -zxvf helm-v2.8.2-linux-amd64.tar.gz 将文件移动到PATH目录中（以linux-amd64为例） mv linux-amd64/helm /usr/local/bin/helm 初始化Helm helm init --tiller-image=registry.cn-shanghai.aliyuncs.com/choerodon/tiller:v2.8.2 --service-account=helm-tiller --stable-repo-url https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts "},"/docs/installation-configuration/kafka":{"url":"docs/installation-configuration/kafka","title":"Kafka安装","description":"Kafka安装","body":"Kafka安装 仓库设置 本地添加远程仓库 helm repo add c7n http://helm-charts.choerodon.io/c7n/base/ 更新本地仓库信息 helm repo update 安装Kafka 注意：启用持久化存储请执行提前创建所指向的物理地址，PV和PVC可使用以下语句进行创建；特别注意： 创建建的PV数量应与kafka副本数量一致！可在安装命令中添加--debug --dry-run参数，进行渲染预览不进行安装。 创建kafka所需PV和PVC helm install c7n/create-pv \\ --set type=nfs \\ --set pv.name=kafka-pv-00 \\ --set labels.app=kafka \\ --set nfs.path=/u01/nfs/exports/io-choerodon/kafka-00 \\ --set nfs.server=nfs.exmple.choerodon.io \\ --set pvc.enable=false \\ --set size=3Gi \\ --set \"accessModes[0]=ReadWriteOnce\" \\ --name kafka-pv-00 --namespace=io-choerodon helm install c7n/create-pv \\ --set type=nfs \\ --set pv.name=kafka-pv-01 \\ --set labels.app=kafka \\ --set nfs.path=/u01/nfs/exports/io-choerodon/kafka-01 \\ --set nfs.server=nfs.exmple.choerodon.io \\ --set pvc.enable=false \\ --set size=3Gi \\ --set \"accessModes[0]=ReadWriteOnce\" \\ --name kafka-pv-01 --namespace=io-choerodon helm install c7n/create-pv \\ --set type=nfs \\ --set pv.name=kafka-pv-02 \\ --set labels.app=kafka \\ --set nfs.path=/u01/nfs/exports/io-choerodon/kafka-02 \\ --set nfs.server=nfs.exmple.choerodon.io \\ --set pvc.enable=false \\ --set size=3Gi \\ --set \"accessModes[0]=ReadWriteOnce\" \\ --name kafka-pv-02 --namespace=io-choerodon 部署kafka helm install c7n/kafka \\ --set replicaCount=3 \\ --set persistence.enabled=true \\ --set persistence.selector.app=\"kafka\" \\ --set zookeeperConnect=\"zookeeper-0.zookeeper-headless.io-choerodon.svc.cluster.local:2181\\ zookeeper-1.zookeeper-headless.io-choerodon.svc.cluster.local:2181\\ zookeeper-2.zookeeper-headless.io-choerodon.svc.cluster.local:2181\" \\ --name=kafka --namespace=io-choerodon 参数： 参数 | 含义 --- | --- replicaCount|设置副本数量 persistence.enabled|是否启用Kafka数据持久化 persistence.selector|Kafka创建的pvc选pv的选择器值，为pv的label zookeeperConnect|访问zookeeper的链接地址 "},"/docs/installation-configuration/kubernetes":{"url":"docs/installation-configuration/kubernetes","title":"Kubernetes集群部署","description":"Kubernetes集群部署","body":"简化模式 linux/osx 环境准备 安装Virtualbox 5.1.34 安装Vagrant 2.0.1 搭建Kubernetes集群 克隆搭建脚本 并进入项目中 git clone https://choerodon.io/gitlab/rdc_hip/kubeadm-ansible.git && cd kubeadm-ansible 默认启动3个虚拟机，若PC内存不足，请降低Vagrantfile中第6行循环次数。 启动虚拟机 vagrant up 进入虚拟机node1 vagrant ssh node1 在node1中安装ansible环境 sudo yum install -y epel-release && \\ sudo yum install -y \\ ansible \\ git \\ httpd-tools \\ pyOpenSSL \\ python-cryptography \\ python-lxml \\ python-netaddr \\ python-passlib \\ python-pip # 查看ansible版本（version>=2.4.0.0） ansible --version 若修改了Vagrantfile中启动的虚拟机数量，请删除kubeadm-ansible/inventory/hosts文件中未启动的虚拟机信息。 在node1中部署集群 cd /vagrant ansible-playbook -i inventory/hosts -e @inventory/vars cluster.yml windows 使用Virtualbox启动 使用Virtualbox启动请参照linux/osx启动方式运行。 测试环境模式 环境准备 在要执行ansible脚本的机器上安装ansible运行需要的环境： sudo yum install -y epel-release && \\ sudo yum install -y \\ ansible \\ git \\ httpd-tools \\ pyOpenSSL \\ python-cryptography \\ python-lxml \\ python-netaddr \\ python-passlib \\ python-pip # 查看ansible版本（version>=2.4.0.0） ansible --version 克隆项目： git clone https://choerodon.io/gitlab/rdc_hip/kubeadm-ansible.git 修改hosts文件 编辑项目下的kubeadm-ansible/inventory/hosts文件 修改各机器的访问地址、用户名、密码，并维护好各节点与角色的关系 前面的名称为机器的hostname。该用户必须是具有root权限的用户。 注意：etcd节点和master节点需要在相同的机器。 比如 想要部署单节点集群 只需要这样配置(参考)： [all] node1 ansible_host=192.168.56.11 ansible_user=root ansible_ssh_pass=change_it ansible_become=true [kube-master] node1 [etcd] node1 [kube-node] node1 修改变量 编辑项目下的kubeadm-ansible/inventory/vars文件 修改变量k8s_interface的值为要部署机器的ipv4的网卡名称(centos默认是eth0) 如果不确定可使用ifconfig命令查看。 k8s_interface: \"eth0\" 注意:如果各个机器之间网卡名称不一致 请将k8s_interface变量从kubeadm-ansible/inventory/vars文件删掉，并在inventory/host文件中给每个机器加上ip地址，比如: [all] node1 ansible_host=192.168.56.11 ip=192.168.56.11 ansible_user=root ansible_ssh_pass=change_it ansible_become=true 如果所有机器以代理的方式访问外网 请配置以下几个变量 否则请不要配置: http_proxy: http://1.2.3.4:3128 https_proxy: http://1.2.3.4:3128 no_proxy: localhost 127.0.0.0/8 docker_proxy_enable: true 部署 执行: ansible-playbook -i inventory/hosts -e @inventory/vars cluster.yml 查看等待pod的状态为runnning: kubectl get po -n kube-system 如果部署失败，想要重置集群(所有数据) 执行： ansible-playbook -i inventory/hosts reset.yml 正式环境模式 注意：以下已以阿里云ECS为例进行讲解，目前只支持centos 7.2+ 在要执行ansible脚本的机器上安装ansible运行需要的环境： sudo yum install -y epel-release && \\ sudo yum install -y \\ ansible \\ git \\ httpd-tools \\ pyOpenSSL \\ python-cryptography \\ python-lxml \\ python-netaddr \\ python-passlib \\ python-pip # 查看ansible版本（version>=2.4.0.0） ansible --version 克隆项目： git clone https://choerodon.io/gitlab/rdc_hip/kubeadm-ansible.git 修改hosts文件 在阿里云的ECS的控制面板上修改ECS实例的hostname 名称最好只包含小写字母、数字和中划线。并保持与inventory/hosts中的名称与ECS控制台上的名称保持一致 重启生效。注意：etcd节点和master节点需要在相同的机器。 网段选择 如果ECS服务器用的是专有网络 pod和service的网段不能与vpc网段重叠，示例参考： # 如果vpc网段为`172.*` kube_pods_subnet: 192.168.0.0/20 kube_service_addresses: 192.168.255.0/20 # 如果vpc网段为`10.*` kube_pods_subnet: 172.16.0.0/16 kube_service_addresses: 172.19.0.0/20 # 如果vpc网段为`192.168.*` kube_pods_subnet: 172.16.0.0/16 kube_service_addresses: 172.19.0.0/20 flannel类型 在使用VPC网络的ECS上部署k8s时，flannel网络的Backend类型需要是ali-vpc。在本脚本中默认使用的是vxlan类型，虽然在vpc环境下网络能通 但是不稳定波动较大。所以推荐使用ali-vpc的类型。 因此 首先需要设置默认的flannel网络不安装，通过在inventory/vars文件中添加变量： flannel_enable: false 跑完ansible脚本后手动安装flannel网络插件 在其中一个master节点创建配置文件kube-flannel-aliyun.yml: kind: ClusterRole apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: flannel rules: - apiGroups: - \"\" resources: - pods verbs: - get - apiGroups: - \"\" resources: - nodes verbs: - list - watch - apiGroups: - \"\" resources: - nodes/status verbs: - patch --- kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: flannel roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: flannel subjects: - kind: ServiceAccount name: flannel namespace: kube-system --- apiVersion: v1 kind: ServiceAccount metadata: name: flannel namespace: kube-system --- kind: ConfigMap apiVersion: v1 metadata: name: kube-flannel-cfg namespace: kube-system labels: tier: node app: flannel data: cni-conf.json: | { \"name\": \"cbr0\" \"type\": \"flannel\" \"delegate\": { \"isDefaultGateway\": true } } net-conf.json: | { \"Network\": \"[PodsSubnet]\" \"Backend\": { \"Type\": \"ali-vpc\" } } --- apiVersion: extensions/v1beta1 kind: DaemonSet metadata: name: kube-flannel-ds namespace: kube-system labels: tier: node app: flannel spec: template: metadata: labels: tier: node app: flannel spec: hostNetwork: true nodeSelector: beta.kubernetes.io/arch: amd64 tolerations: - key: node-role.kubernetes.io/master operator: Exists effect: NoSchedule serviceAccountName: flannel initContainers: - name: install-cni image: registry.cn-hangzhou.aliyuncs.com/google-containers/flannel:v0.9.0 command: - cp args: - -f - /etc/kube-flannel/cni-conf.json - /etc/cni/net.d/10-flannel.conf volumeMounts: - name: cni mountPath: /etc/cni/net.d - name: flannel-cfg mountPath: /etc/kube-flannel/ containers: - name: kube-flannel image: registry.cn-hangzhou.aliyuncs.com/google-containers/flannel:v0.9.0 command: [ \"/opt/bin/flanneld\" \"--ip-masq\" \"--kube-subnet-mgr\" ] securityContext: privileged: true env: - name: POD_NAME valueFrom: fieldRef: fieldPath: metadata.name - name: POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace - name: ACCESS_KEY_ID value: [YOUR_ACCESS_KEY_ID] - name: ACCESS_KEY_SECRET value: [YOUR_ACCESS_KEY_SECRET] volumeMounts: - name: run mountPath: /run - name: flannel-cfg mountPath: /etc/kube-flannel/ volumes: - name: run hostPath: path: /run - name: cni hostPath: path: /etc/cni/net.d - name: flannel-cfg configMap: name: kube-flannel-cfg 请注意修改配置中的参数值： Network：为pod网段。 ACCESS_KEY_ID:必填 ACCESS_KEY_SECRET:必填 该ACCESS_KEY的用户需要拥有以下权限： 只读访问云服务器(ECS)的权限 管理专有网络(VPC)的权限 然后使用kubectl命令部署 部署成功后在vpc的路由表中会添加多条路由条目 下一跳分别为每个节点的pod ip段： kubectl apply -f kube-flannel-aliyun.yml 接下来需要在ECS安全组，在入方向规则中加上pod网段的地址。否则在pod容器中无法访问别的节点的pod的端口 比如: 授权策略 | 协议类型 | 端口范围 | 授权类型 | 授权对象 | ... ---|---|---|---|---|--- 允许 | 全部 | -1/-1 | 地址段访问 | 192.168.0.0/20 | ... 修改变量 编辑项目下的kubeadm-ansible/inventory/vars文件 修改变量k8s_interface的值为要部署机器的ipv4的网卡名称(centos默认是eth0) 如果不确定可使用ifconfig命令查看。 k8s_interface: \"eth0\" 注意:如果各个机器之间网卡名称不一致 请将k8s_interface变量从kubeadm-ansible/inventory/vars文件删掉，并在inventory/host文件中给每个机器加上ip地址，比如: [all] node1 ansible_host=192.168.56.11 ip=192.168.56.11 ansible_user=root ansible_ssh_pass=change_it ansible_become=true 如果所有机器以代理的方式访问外网 请配置以下几个变量 否则请不要配置: http_proxy: http://1.2.3.4:3128 https_proxy: http://1.2.3.4:3128 no_proxy: localhost 127.0.0.0/8 docker_proxy_enable: true 部署 执行: ansible-playbook -i inventory/hosts -e @inventory/vars cluster.yml 查看等待pod的状态为runnning: kubectl get po -n kube-system 如果部署失败，想要重置集群(所有数据) 执行： ansible-playbook -i inventory/hosts reset.yml "},"/docs/installation-configuration/minio":{"url":"docs/installation-configuration/minio","title":"Minio安装","description":"Minio安装","body":"minio安装 仓库设置 本地添加远程仓库 helm repo add c7n http://helm-charts.choerodon.io/c7n/base/ 更新本地仓库信息 helm repo update 安装Minio 注意： 启用持久化存储请执行提前创建PV和PVC，也可使用以下语句进行创建；可在安装命令中添加--debug --dry-run参数，进行渲染预览不进行安装。 创建minio所需PV和PVC helm install c7n/create-pv \\ --set type=nfs \\ --set pv.name=minio-pv \\ --set nfs.path=/u01/nfs/exports/io-choerodon/minio \\ --set nfs.server=nfs.exmple.choerodon.io \\ --set pvc.name=minio-pvc \\ --set size=3Gi \\ --set \"accessModes[0]=ReadWriteOnce\" \\ --name minio-pv --namespace=io-choerodon 进行安装部署 helm install c7n/minio \\ --set persistence.enabled=true \\ --set persistence.existingClaim=minio-pvc \\ --set env.open.MINIO_ACCESS_KEY=admin \\ --set env.open.MINIO_SECRET_KEY=password \\ --set ingress.enabled=true \\ --set \"ingress.hosts[0]\"=\"minio.exmple.choerodon.io\" \\ --name=minio --namespace=io-choerodon 参数： 参数 | 含义 --- | --- persistence.enabled|是否启用持久化存储 persistence.existingClaim|PVC的名称 ingress.enabled|是否启用ingress ingress.hosts[0]|域名 env.open.MINIO_ACCESS_KEY|用户名 env.open.MINIO_SECRET_KEY|密码 "},"/docs/installation-configuration/mysql":{"url":"docs/installation-configuration/mysql","title":"Mysql安装","description":"Mysql安装","body":"Mysql安装 仓库设置 本地添加远程仓库 helm repo add c7n http://helm-charts.choerodon.io/c7n/base/ 更新本地仓库信息 helm repo update 安装Mysql 注意：启用持久化存储请执行提前创建所指向的物理地址，PV和PVC可使用以下语句进行创建；可在安装命令中添加--debug --dry-run参数，进行渲染预览不进行安装。 创建mysql所需PV和PVC helm install c7n/create-pv \\ --set type=nfs \\ --set pv.name=mysql-pv \\ --set nfs.path=/u01/nfs/exports/io-choerodon/mysql \\ --set nfs.server=nfs.exmple.choerodon.io \\ --set pvc.name=mysql-pvc \\ --set size=3Gi \\ --set \"accessModes[0]=ReadWriteOnce\" \\ --name mysql-pv --namespace=io-choerodon 部署mysql helm install c7n/mysql \\ --set persistence.enabled=true \\ --set persistence.existingClaim=mysql-pvc \\ --set env.open.MYSQL_ROOT_PASSWORD=password \\ --set service.port=3306 \\ --name=choerodon-mysql --namespace=io-choerodon 参数： 参数 | 含义 --- | --- persistence.enabled|是否启用持久化存储 persistence.existingClaim|PVC的名称 persistence.subPath|设置将数据存储到的子目录 service.port|设置service端口号 service.externalIPs[0]|设置externalIPs env.open.MYSQL_ROOT_PASSWORD|设置数据库root用户密码 env.open.MYSQL_DATABASE|初始化创建的数据库名称 env.open.MYSQL_USER|初始化创建的用户名 env.open.MYSQL_PASSWORD|初始化创建的用户密码 创建数据库 创建choerodon所需数据库及用户并授权 CREATE USER 'choerodon'@'%' IDENTIFIED BY \"password\"; CREATE DATABASE devops_service DEFAULT CHARACTER SET utf8; CREATE DATABASE event_store_service DEFAULT CHARACTER SET utf8; CREATE DATABASE gitlab_service DEFAULT CHARACTER SET utf8; CREATE DATABASE iam_service DEFAULT CHARACTER SET utf8; CREATE DATABASE manager_service DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON devops_service.* TO choerodon@'%'; GRANT ALL PRIVILEGES ON event_store_service.* TO choerodon@'%'; GRANT ALL PRIVILEGES ON gitlab_service.* TO choerodon@'%'; GRANT ALL PRIVILEGES ON iam_service.* TO choerodon@'%'; GRANT ALL PRIVILEGES ON manager_service.* TO choerodon@'%'; FLUSH PRIVILEGES; "},"/docs/installation-configuration/redis":{"url":"docs/installation-configuration/redis","title":"Redis安装","description":"Redis安装","body":"Redis安装 仓库设置 本地添加远程仓库 helm repo add c7n http://helm-charts.choerodon.io/c7n/base/ 更新本地仓库信息 helm repo update 安装Redis 注意：启用持久化存储请执行提前创建所指向的物理地址，PV和PVC可使用以下语句进行创建；可在安装命令中添加--debug --dry-run参数，进行渲染预览不进行安装。 创建PV和PVC helm install c7n/create-pv \\ --set type=nfs \\ --set pv.name=framework-redis-pv \\ --set nfs.path=/u01/nfs/exports/io-choerodon/framework-redis \\ --set nfs.server=nfs.exmple.choerodon.io \\ --set pvc.name=framework-redis-pv \\ --set size=1Gi \\ --set \"accessModes[0]=ReadWriteOnce\" \\ --name framework-redis-pv --namespace=io-choerodon helm install c7n/create-pv \\ --set type=nfs \\ --set pv.name=devops-redis-pv \\ --set nfs.path=/u01/nfs/exports/io-choerodon/devops-redis \\ --set nfs.server=nfs.exmple.choerodon.io \\ --set pvc.name=devops-redis-pv \\ --set size=1Gi \\ --set \"accessModes[0]=ReadWriteOnce\" \\ --name devops-redis-pv --namespace=io-choerodon 部署认证服务所需Redis helm install c7n/redis --name=framework-redis --namespace=io-choerodon \\ --set persistence.enabled=true \\ --set persistence.existingClaim=framework-redis-pvc 部署Devops服务所需Redis helm install c7n/redis --name=devops-redis --namespace=io-choerodon \\ --set persistence.enabled=true \\ --set persistence.existingClaim=devops-redis-pvc 参数： 参数 | 含义 --- | --- persistence.enabled|是否启用持久化存储 persistence.existingClaim|PVC的名称 persistence.subPath|设置将数据存储到的子目录 "},"/docs/installation-configuration/zookeeper":{"url":"docs/installation-configuration/zookeeper","title":"Zookeeper安装","description":"Zookeeper安装","body":"Zookeeper安装 仓库设置 本地添加远程仓库 helm repo add c7n http://helm-charts.choerodon.io/c7n/base/ 更新本地仓库信息 helm repo update 安装Zookeeper 注意：启用持久化存储请执行提前创建所指向的物理地址，PV和PVC可使用以下语句进行创建；特别注意： 创建建的PV数量应与zookeeper副本数量一致！可在安装命令中添加--debug --dry-run参数，进行渲染预览不进行安装。 创建zookeeper所需PV和PVC helm install c7n/create-pv \\ --set type=nfs \\ --set pv.name=zookeeper-pv-00 \\ --set labels.app=zookeeper \\ --set nfs.path=/u01/nfs/exports/io-choerodon/zookeeper-00 \\ --set nfs.server=nfs.exmple.choerodon.io \\ --set pvc.enable=false \\ --set size=3Gi \\ --set \"accessModes[0]=ReadWriteOnce\" \\ --name zookeeper-pv-00 --namespace=io-choerodon helm install c7n/create-pv \\ --set type=nfs \\ --set pv.name=zookeeper-pv-01 \\ --set labels.app=zookeeper \\ --set nfs.path=/u01/nfs/exports/io-choerodon/zookeeper-01 \\ --set nfs.server=nfs.exmple.choerodon.io \\ --set pvc.enable=false \\ --set size=3Gi \\ --set \"accessModes[0]=ReadWriteOnce\" \\ --name zookeeper-pv-01 --namespace=io-choerodon helm install c7n/create-pv \\ --set type=nfs \\ --set pv.name=zookeeper-pv-02 \\ --set labels.app=zookeeper \\ --set nfs.path=/u01/nfs/exports/io-choerodon/zookeeper-02 \\ --set nfs.server=nfs.exmple.choerodon.io \\ --set pvc.enable=false \\ --set size=3Gi \\ --set \"accessModes[0]=ReadWriteOnce\" \\ --name zookeeper-pv-02 --namespace=io-choerodon 部署zookeeper helm install c7n/zookeeper \\ --set replicaCount=3 \\ --set persistence.enabled=true \\ --set persistence.selector.app=\"zookeeper\" \\ --name=zookeeper --namespace=io-choerodon 参数： 参数 | 含义 --- | --- replicaCount|设置副本数量 persistence.enabled|是否启用Zookeeper数据持久化 persistence.selector|Zookeeper创建的pvc选pv的选择器值，为pv的label "},"/docs/quick-start/":{"url":"docs/quick-start/","title":"快速入门","description":"","body":"快速入门 快速入门主要介绍了 Choerodon 的使用方法。从创建项目、创建应用和敏捷管理工具使用入手，结合用户故事地图、迭代和看板管理等功能，详细地介绍如何使用 Choerodon ，让读者能够熟悉使用Choerodon创建前端应用的步骤和流程。 目前，Choerodon 支持3种类型应用的创建。前端应用、 后端应用、Java 库。 创建一个项目 创建一个前端应用 创建一个后端应用 创建一个Java库 "},"/docs/quick-start/microservice-backend":{"url":"docs/quick-start/microservice-backend","title":"创建一个后端应用","description":"","body":"创建一个后端应用 概述 后端应用(Backend Application)的架构模式是将传统的单体应用拆分成多个小型应用，每个小型应用可以独立的编译和部署，应用之间的调用通过HTTP的restfull API方式进行通讯。它们彼此之间相互协作，作为一个整体对外开放。Choerodon 的应用后端采用SpringBoot、SpringCloud 作为应用的开发框架，利用丰富的文档、社区活跃和一套完整的应用框架解决方案提供技术支持。 目标 本章节将从创建后端应用、开发后端应用、生成版本、部署应用、.查看实例部署详情、配置网络等方面介绍，让读者能够熟悉使用Choerodon创建应用后端应用的步骤和流程，并且学会如何利用Choerodon部署应用等。 前置条件 1. 在操作之前保证系统配置已经配置完全。特别在本章节用到的角色、环境管理等配置。 2. 完成创建项目操作。本章节使用在前面章节创建的项目猪齿鱼研发。 3. 完成创建环境操作。 4. 在Choerodon平台下，项目启动依赖于基础服务： api-gateway(网关服务) gateway-helper(授权校验、权限校验、请求限流) manager-service(管理服务，配置管理、路由管理、swagger管理) oauth-server(认证服务，用户的认证与授权) register-server(注册服务，服务发现) iam-service(用户服务，组织、项目、用户信息管理等) 如果是本地开发，需要在api-gateway服务的application-default.yml配置文件配置路由信息 zuul: addHostHeader: true routes: test: path: /test/** serviceId: test-service [具体服务启动配置参考][1] 创建后端应用 1. 使用项目所有者或者源代码管理员的角色登录Choerodon系统，选择项目猪齿鱼研发。 2. 选择持续交付模块，点击开发流水线，点击应用，进入应用管理页面。 3. 点击创建应用，系统会从右边滑出页面，在页面中输入应用编码、应用名称，并且选择应用模板，点击创建，即可创建一个后端应用。 应用编码：choerodon-backend 应用名称：猪齿鱼后端应用 选择应用模板: MicroService 当应用模板不符合您的需求，您可手动创建一个应用模板。 4. 当应用创建成功，可在应用管理界面查看到新建的应用。 5. 在创建应用的同时，系统还会在Gitlab中创建一个仓库，点击 仓库地址 ，链接到Gitlab新建的仓库。 Gitlab 仓库的名称是 choerodon-backend，为应用编码。 开发后端应用 应用创建完成之后，开发后端应用。具体的操作步骤如下： 1. 创建Feature分支 点击应用，进入到应用管理界面，选择猪齿鱼后端应用。 点击右侧分支管理，点击创建分支，系统会从右边滑出页面，填写issue号，如feature-1。 点击创建，即可创建一个分支。 2. 拉取代码仓库 在Choerodon平台创建项目后，进入项目创建服务，服务名为gitlab平台的项目名，Choerodon后台将会自动为你生成模板代码，代码仓库地址可以在Choerodon平台查看。 通过git命令拉取生成的项目代码。 git clone -b develop http://git.choerodon.io/devopstest-projecttest/choerodon-backend.git 克隆成功后，进入应用根目录，执行命令git checkout feature-1，切换到新建分支feature-1，在此分支进行开发。 项目使用DDD领域驱动设计，目录结构如图所示 项目代码通过IDEA打开后，如图所示 3. 修改配置信息 pom.xml依赖 4.0.0 devopstest-projecttest choerodon-backend 1.0-SNAPSHOT io.choerodon choerodon-framework-parent 0.1.0 io.choerodon choerodon-starter-swagger 0.1.0 io.choerodon choerodon-starter-feign-replay 0.1.0 mysql mysql-connector-java io.choerodon choerodon-starter-core 0.1.0 io.choerodon choerodon-starter-hitoa 0.1.0 io.choerodon choerodon-starter-mybatis-mapper 0.1.0 io.choerodon choerodon-starter-oauth-resource 0.1.0 org.springframework.boot spring-boot-starter-actuator org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-tomcat org.springframework.boot spring-boot-starter-undertow org.springframework.cloud spring-cloud-starter-eureka org.springframework.boot spring-boot-configuration-processor true org.springframework.cloud spring-cloud-config-client org.springframework.boot spring-boot-starter-aop org.springframework.retry spring-retry org.springframework.cloud spring-cloud-starter-bus-kafka org.springframework.cloud spring-cloud-bus io.choerodon choerodon-starter-bus 0.1.0 org.springframework.boot spring-boot-starter-test test org.springframework.cloud spring-cloud-stream-binder-kafka org.springframework.cloud spring-cloud-netflix-hystrix-stream org.springframework.cloud spring-cloud-sleuth-stream app choerodon-snapshot-repository Choerodon Snapshot Repository http://nexus.choerodon.io/content/repositories/rdcsnapshot/ true choerodon-release-repository Choerodon Release Repository http://nexus.choerodon.io/content/repositories/rdc/ springBoot配置文件 Choerodon平台微服务都是采用yml配置文件的方式进行系统配置，通过修改application-default.yml文件修改数据库配置、端口配置等。 application-default.yml spring: datasource: url: jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=utf-8&useSSL=false username: root password: root http: encoding: charset: UTF-8 force: true enabled: true multipart: max-file-size: 30MB max-request-size: 30MB eureka: client: serviceUrl: defaultZone: ${EUREKA_DEFAULT_ZONE:http://localhost:8000/eureka/} swagger: oauthUrl: http://localhost:8080/oauth/oauth/authorize event: consumer: enabled: true enable-duplicate-remove: false kafka: bootstrapServers: localhost:9092 sessionTimeoutMs: 30000 feign: hystrix: enabled: true hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 30000 timeout: enabled: false ribbon: ConnectTimeout: 10000 ReadTimeout: 30000 serviceAccountId: 1 4. 数据库初始化脚本 修改数据初始化脚本 修改数据库配置 init-local-database.sh #!/bin/bash mkdir -p target if [ ! -f target/choerodon-tool-liquibase.jar ] then curl http://nexus.choerodon.io/content/repositories/rdc/io/choerodon/choerodon-tool-liquibase/0.1.0/choerodon-tool-liquibase-0.1.0.jar -o target/choerodon-tool-liquibase.jar fi java -Dspring.datasource.url=\"jdbc:mysql://localhost/test?useUnicode=true&characterEncoding=utf-8&useSSL=false\" \\ -Dspring.datasource.username=root \\ -Dspring.datasource.password=root \\ -Ddata.drop=false -Ddata.init=true \\ -Ddata.dir=src/main/resources \\ -jar target/choerodon-tool-liquibase.jar 数据库表结构groovy脚本 创建一个测试用户表，字段id、name、description、自维护字段（object_version_number、created_by、creation_date、last_updated_by、last_update_date）。自维护字段在项目mybatis依赖包中通过sql拦截器维护，文件命名方式：表名.groovy，存放路径如图所示 ![](/docs/quick-start/image/2.png) **test_user.groovy** package script.db databaseChangeLog(logicalFilePath: 'script/db/test_user.groovy') { changeSet(id: '2018-05-14-test-user' author: 'dinghuang123@gmail.com') { createTable(tableName: \"test_user\" remarks: '测试用户表') { column(name: 'id' type: 'BIGINT UNSIGNED' autoIncrement: true remarks: '主键') { constraints(primaryKey: true) } column(name: 'name' type: 'VARCHAR(255)' remarks: '用户名称') { constraints(nullable: false) } column(name: 'description' type: 'VARCHAR(255)' remarks: '描述') column(name: \"object_version_number\" type: \"BIGINT UNSIGNED\" defaultValue: \"1\") column(name: \"created_by\" type: \"BIGINT UNSIGNED\" defaultValue: \"0\") column(name: \"creation_date\" type: \"DATETIME\" defaultValueComputed: \"CURRENT_TIMESTAMP\") column(name: \"last_updated_by\" type: \"BIGINT UNSIGNED\" defaultValue: \"0\") column(name: \"last_update_date\" type: \"DATETIME\" defaultValueComputed: \"CURRENT_TIMESTAMP\") } } } 进入项目根目录通过gitBash执行 $ sh init-local-database.sh 执行成功后，数据库表初始化完成，如图所示 ![](/docs/quick-start/image/csh.png) 5. 示例代码 DO 文件存放在infra文件夹下的dataobject，文件命名规范：对象名+DO.java，DO代表UserDO对象是DDD领域设计的持久层对象，该对象直接与mybatis进行持久层交互，对象继承AuditDomain，AuditDomain是自维护字段。 @Id@GeneratedValue 2个注解分别对应主键和主键自增长，代码如下: package io.choerodon.test.infra.dataobject; import io.choerodon.mybatis.annotation.ModifyAudit; import io.choerodon.mybatis.annotation.VersionAudit; import io.choerodon.mybatis.domain.AuditDomain; import io.choerodon.test.infra.common.utils.StringUtil; import javax.persistence.GeneratedValue; import javax.persistence.Id; import javax.persistence.Table; import javax.validation.constraints.NotNull; /** * 测试用户表 * * @author dinghuang123@gmail.com * @since 2018-05-15 11:44:28 */ @ModifyAudit @VersionAudit @Table(name = \"test_user\") public class UserDO extends AuditDomain { /***/ @Id @GeneratedValue private Long id; /** * 用户名称 */ @NotNull(message = \"error.user.nameNotNull\") private String name; /** * 描述 */ private String description; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } @Override public String toString() { return StringUtil.getToString(this); } } Entity 文件存放在entity文件夹下，文件命名规范：对象名+E.java，E代表UserE对象是DDD领域设计的实体对象，该对象用来实现业务逻辑，DDD思想最重要的就是在没有数据库的情况下实现完整的业务逻辑，所以entity不操作持久层，在entity进行的逻辑都是内存操作。 代码如下所示 package io.choerodon.test.domain.test.entity; import io.choerodon.test.infra.common.utils.StringUtil; import org.springframework.context.annotation.Scope; import org.springframework.stereotype.Component; /** * 测试用户表 * * @author dinghuang123@gmail.com * @since 2018-05-15 11:44:28 */ @Component @Scope(\"prototype\") public class UserE { private Long id; private String name; private String description; private Long objectVersionNumber; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public Long getObjectVersionNumber() { return objectVersionNumber; } public void setObjectVersionNumber(Long objectVersionNumber) { this.objectVersionNumber = objectVersionNumber; } @Override public String toString() { return StringUtil.getToString(this); } } Mapper UserMapper.java package io.choerodon.test.infra.mapper; import io.choerodon.mybatis.common.BaseMapper; import io.choerodon.test.infra.dataobject.*; import org.springframework.stereotype.Repository; /** * 测试用户表 * * @author dinghuang123@gmail.com * @since 2018-05-15 11:44:28 */ public interface UserMapper extends BaseMapper { } UserMapper.xml Repository 文件存放在repository文件夹下，文件命名规范：对象名+Repository.java，Repository代表UserE对象是DDD领域设计的仓储，引入仓储的概念，是因为部分业务逻辑有涉及到持久层，需要通过仓储来实现。这样做的好处是，以后不论持久层框架是mybatis还是hibernate，业务逻辑不变，只需要修改仓储实现类。 UserRepository.java package io.choerodon.test.domain.test.repository; import io.choerodon.test.domain.test.entity.UserE; import java.util.List; /** * 测试用户表 * * @author dinghuang123@gmail.com * @since 2018-05-15 11:44:28 */ public interface UserRepository { /** * 更新测试用户表 * * @param userE userE * @return UserE */ UserE update(UserE userE); /** * 添加一个测试用户表 * * @param userE userE * @return UserE */ UserE create(UserE userE); /** * 根据id删除测试用户表 * * @param id id * @return int */ int delete(Long id); /** * 查询所有用户 * * @return List */ List queryList(); } UserRepositoryImpl.java package io.choerodon.test.infra.repository.impl; import io.choerodon.core.convertor.ConvertHelper; import io.choerodon.core.exception.CommonException; import io.choerodon.test.domain.test.converter.UserConverter; import io.choerodon.test.domain.test.entity.UserE; import io.choerodon.test.domain.test.repository.UserRepository; import io.choerodon.test.infra.dataobject.UserDO; import io.choerodon.test.infra.mapper.UserMapper; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import org.springframework.transaction.annotation.Transactional; import java.util.List; /** * 测试用户表 * * @author dinghuang123@gmail.com * @since 2018-05-15 11:44:29 */ @Component @Transactional(rollbackFor = CommonException.class) public class UserRepositoryImpl implements UserRepository { private static final String UPDATE_ERROR = \"error.User.update\"; private static final String INSERT_ERROR = \"error.User.insert\"; private static final String DELETE_ERROR = \"error.User.delete\"; @Autowired private UserMapper userMapper; @Autowired private UserConverter userConverter; @Override public UserE update(UserE userE) { UserDO userDO = userConverter.entityToDo(userE); if (userMapper.updateByPrimaryKeySelective(userDO) != 1) { throw new CommonException(UPDATE_ERROR); } return userConverter.doToEntity(userMapper.selectByPrimaryKey(userDO.getId())); } @Override public UserE create(UserE userE) { UserDO userDO = userConverter.entityToDo(userE); if (userMapper.insert(userDO) != 1) { throw new CommonException(INSERT_ERROR); } return userConverter.doToEntity(userMapper.selectByPrimaryKey(userDO.getId())); } @Override public int delete(Long id) { UserDO userDO = userMapper.selectByPrimaryKey(id); int isDelete = userMapper.delete(userDO); if (isDelete != 1) { throw new CommonException(DELETE_ERROR); } return isDelete; } @Override public List queryList() { List userDOlist = userMapper.selectAll(); return ConvertHelper.convertList(userDOlist UserE.class); } } domainService 领域层接口命名规范I+对象名+sercice，代码如下 IUserService.java package io.choerodon.test.domain.service; import io.choerodon.test.infra.dataobject.UserDO; import io.choerodon.mybatis.service.BaseService; /** * 测试用户表 * * @author dinghuang123@gmail.com * @since 2018-05-15 11:44:28 */ public interface IUserService extends BaseService { } IUserServiceImpl.java package io.choerodon.test.domain.service.impl; import io.choerodon.mybatis.service.BaseServiceImpl; import io.choerodon.test.domain.service.*; import io.choerodon.core.exception.CommonException; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import io.choerodon.test.infra.dataobject.UserDO; /** * 测试用户表 * * @author dinghuang123@gmail.com * @since 2018-05-15 11:44:29 */ @Service @Transactional(rollbackFor = CommonException.class) public class IUserServiceImpl extends BaseServiceImpl implements IUserService{ } DTO DTO是与前端进行数据交互定义的对象，命名为：对象名+DTO.java，在DDD设计中，这样的设计确保了数据的安全性，可以根据前端需要传输的信息进行DTO的编写，一部分可以确保重要信息的泄露，另一部分可以确保不必要字段的插入更新。 UserDTO.java package io.choerodon.test.api.dto; import java.util.Date; import io.choerodon.test.infra.common.utils.StringUtil; /** * 测试用户表 * * @author dinghuang123@gmail.com * @since 2018-05-15 11:44:28 */ public class UserDTO { private Long id; private String name; private String description; private Long objectVersionNumber; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public Long getObjectVersionNumber() { return objectVersionNumber; } public void setObjectVersionNumber(Long objectVersionNumber) { this.objectVersionNumber = objectVersionNumber; } @Override public String toString() { return StringUtil.getToString(this); } } Converter Converter是实现do、dto、entity之间的转换，本例只是简单实现，由spring进行管理。根据业务逻辑需求，若需要不同dto，dto的转换在assembler文件夹下实现entity与dto的转换。 UserConverter.java package io.choerodon.test.domain.test.converter; import io.choerodon.core.convertor.ConvertorI; import org.springframework.stereotype.Component; import org.springframework.beans.BeanUtils; import io.choerodon.test.api.dto.UserDTO; import io.choerodon.test.infra.dataobject.UserDO; import io.choerodon.test.domain.test.entity.UserE; /** * 测试用户表 * * @author dinghuang123@gmail.com * @since 2018-05-15 11:44:28 */ @Component public class UserConverter implements ConvertorI { @Override public UserE dtoToEntity(UserDTO userDTO) { UserE userE = new UserE(); BeanUtils.copyProperties(userDTO userE); return userE; } @Override public UserE doToEntity(UserDO userDO) { UserE userE = new UserE(); BeanUtils.copyProperties(userDO userE); return userE; } @Override public UserDTO entityToDto(UserE userE) { UserDTO userDTO = new UserDTO(); BeanUtils.copyProperties(userE userDTO); return userDTO; } @Override public UserDO entityToDo(UserE userE) { UserDO userDO = new UserDO(); BeanUtils.copyProperties(userE userDO); return userDO; } @Override public UserDTO doToDto(UserDO userDO) { UserDTO userDTO = new UserDTO(); BeanUtils.copyProperties(userDO userDTO); return userDTO; } @Override public UserDO dtoToDo(UserDTO userDTO) { UserDO userDO = new UserDO(); BeanUtils.copyProperties(userDTO userDO); return userDO; } } APP app层是对domain方法调用的封装，controller调用app中的service。 UserService.java package io.choerodon.test.app.service; import io.choerodon.test.api.dto.UserDTO; import java.util.List; /** * 测试用户表 * * @author dinghuang123@gmail.com * @since 2018-05-15 11:44:28 */ public interface UserService { /** * 查询所有用户 * * @return UserDTO */ List queryUserList(); } UserServiceImpl.java package io.choerodon.test.app.service.impl; import io.choerodon.core.convertor.ConvertHelper; import io.choerodon.test.api.dto.UserDTO; import io.choerodon.test.app.service.UserService; import io.choerodon.test.domain.test.repository.UserRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; /** * 测试用户表 * * @author dinghuang123@gmail.com * @since 2018-05-15 11:44:28 */ @Service public class UserServiceImpl implements UserService { @Autowired private UserRepository userRepository; @Override public List queryUserList() { return ConvertHelper.convertList(userRepository.queryList() UserDTO.class); } } controller 控制层结合了swagger进行RESTful的API规范进行设计，示例简单展示了通过GET请求获取所有用户信息。 UserController.java package io.choerodon.test.api.controller.v1; import io.choerodon.core.exception.CommonException; import io.choerodon.test.api.dto.UserDTO; import io.choerodon.test.app.service.UserService; import io.swagger.annotations.ApiOperation; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.*; import java.util.List; import java.util.Optional; /** * 测试用户表 * * @author dinghuang123@gmail.com * @since 2018-05-15 11:44:28 */ @RestController @RequestMapping(value = \"/v1/user\") public class UserController { @Autowired private UserService userService; @ApiOperation(\"查询所有用户\") @GetMapping public ResponseEntity> queryUserList() { return Optional.ofNullable(userService.queryUserList()) .map(result -> new ResponseEntity<>(result HttpStatus.CREATED)) .orElseThrow(() -> new CommonException(\"error.queryUserList.get\")); } } ExtraDataManager 编写该文件，可以节省在manager服务的数据库操作，如果是线上环境，可以省去在api-gateway服务的路由配置。 CustomExtraDataManager.java package io.choerodon.test.infra.common; import io.choerodon.core.swagger.ChoerodonRouteData; import io.choerodon.swagger.annotation.ChoerodonExtraData; import io.choerodon.swagger.custom.extra.ExtraData; import io.choerodon.swagger.custom.extra.ExtraDataManager; /** * @author dinghuang123@gmail.com */ @ChoerodonExtraData public class CustomExtraDataManager implements ExtraDataManager { @Override public ExtraData getData() { ChoerodonRouteData choerodonRouteData = new ChoerodonRouteData(); choerodonRouteData.setName(\"test\"); choerodonRouteData.setPath(\"/test/**\"); choerodonRouteData.setServiceId(\"test-service\"); extraData.put(ExtraData.ZUUL_ROUTE_DATA choerodonRouteData); return extraData; } } application TestServiceApplication.java package io.choerodon.test; import io.choerodon.resource.annoation.EnableChoerodonResourceServer; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; import org.springframework.cloud.netflix.feign.EnableFeignClients; import org.springframework.scheduling.annotation.EnableAsync; /** 1. 测试服务入口类 2. 3. @author dinghuang123@gmail.com */ @EnableFeignClients(\"io.choerodon\") @EnableChoerodonResourceServer @EnableAsync @EnableEurekaClient @SpringBootApplication public class TestServiceApplication { public static void main(String[] args) { SpringApplication.run(TestServiceApplication.class); } } 6. 测试结果 通过Junit进行单元测试。 UserTest.java package io.choerodon.test.test; import io.choerodon.test.api.dto.UserDTO; import io.choerodon.test.app.service.UserService; import org.junit.Test; import org.junit.runner.RunWith; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import java.util.List; /** * @author dinghuang123@gmail.com */ @RunWith(SpringRunner.class) @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) public class UserTest { @Autowired private UserService userService; private static Logger logger = LoggerFactory.getLogger(UserTest.class); @Test public void test() { List userDTOList = userService.queryUserList(); userDTOList.forEach(userDTO -> logger.info(userDTO.toString())); } } 数据库数据如图所示 测试结果如图所示 7. swagger调用api 本地服务启动如图所示 访问swagger地址：http://localhost:8080/manager/swagger-ui.html 如图所示 至此，后端服务一个简单的API完成。 8. 提交代码 # 将本地代码变动提交到暂存区 $ git add . # 提交代码并且为本次提交添加 commit 信息 # 注：[FIX]修改bug [ADD]新增 [IMP]完善 [DEL]删除 $ git commit –m “[ADD]readme: 新增代码示例” # 将本地提交推送至远程仓库对应分支 $ git push origin feature-1 9. 代码集成 基于feature分支运行CI。点击持续集成 查看 CI 执行情况。 10. 结束分支　 点击应用，进入应用管理，点击choerodon-backend的分支管理。 在分支列表找到feature-1，点击结束分支。 生成版本 应用版本是代码提交的历史记录，每提交一次修改后的代码，对应生成一个新的版本。具体的操作步骤如下： 1. 结束分支之后，feature-1分支的代码会合并到develop分支，并触发Gitlab CI。 2. 点击持续集成 查看CI执行情况。 Choerodon 缺省的 CI 流程有两个阶段: 克隆子库，编译打包 构建docker镜像 3. 当CI运行成功后，点击应用版本进行查看，确定应用版本已经生成。 部署应用 提供可视化、一键式部署应用，支持并行部署和流水线无缝集成，实现部署环境标准化和部署过程自动化。 1. 使用部署管理员的角色登录Choerodon系统，选择项目猪齿鱼研发。 2. 进入持续交付模块，选择部署管理，点击应用部署进入应用部署界面。 3. 点击部署应用，系统会从右侧滑出部署应用界面，输入如下信息： 选择应用：choerodon-backend 选择版本：刚才创建的应用版本 选择环境： 选择要部署的环境 配置信息：配置部署应用所需的信息 部署模式：新建实例（新建一个应用）或替换实例（滚动更新实例） 4. 点击部署按钮，即可完成部署。 查看实例部署详情 1. 使用部署管理员的角色登录Choerodon系统，选择项目猪齿鱼研发。 2. 进入持续交付模块，选择部署管理，点击应用部署进入应用部署界面。 3. 点击部署应用即可查看实例。有四种查看视图，分别为：部署实例、单环境、单应用、多应用。 如何判断某版本的应用已经部署成功并通过？当实例出现在列表中，且实例名称后没有报错提示icon即为部署成功生成实例；当容器状态条为绿色，数值显示为1/1时表示容器数量为1且通过健康检查，点击右侧的查看实例详情，可以查看到阶段信息及日志。 配置网络 为所选的应用配置网络。 1. 使用部署管理员的角色登录Choerodon系统，选择项目猪齿鱼研发。 2. 进入持续交付模块，选择部署管理，点击网络，进入网络配置界面。 3. 点击创建网络，系统从右侧滑出创建网络界面，输入如下信息： 环境名称：选择要部署的环境 应用名称：猪齿鱼前端应用 版本：刚才创建的应用版本 实例：刚才部署的实例 网络名称：名称默认为“应用编码-4位随机码”，且可手动修改 外部IP：需要外网时填写 端口号：应用开放端口 4. 点击创建按钮即可。 产品迭代 任何产品几乎都会经历产品的初创期、成长期、成熟期。在产品的初创期，需要通过快速试错探索出有用户黏性的功能；探索成功之后，就需要快速导入用户，这时候也会产生新的需求和新的问题，不断去完善产品；在产品的相对成熟期，则可以考虑产品的变现，和新功能的延展，以提升用户活跃。因此，当一个产品开发完成上线后，产品的周期化迭代就变得非常重要。固定的周期有助于为项目团队形成规范，从而提高开发效率。 Choerodon第一次发版前就准备好下个版本的需求。一般第一个版本上线后，开发人员就进入下一个版本的开发和测试。这样当问题暴露的时候，就可以迅速解决问题，优化到某个程度后，再放缓迭代节奏，这样就能更好的平衡好需求。 "},"/docs/quick-start/microservice-front":{"url":"docs/quick-start/microservice-front","title":"创建一个前端应用","description":"","body":"创建一个前端应用 概述 就前端主流技术框架的开发而言，过去几年里发展极快，在填补原有技术框架空白和不足的同时也渐渐趋于成熟。未来前端在已经趋向成熟的技术方向上面会慢慢稳定下来，并进入技术迭代优化阶段，但这并不代表前端领域技术就此稳定了，因为新的技术方向已经出现，并在等待下一个风口的到来。可能是虚拟现实也有可能是人工智能或者其他。 Choerodon 使用 React 作为前端的UI应用框架，并且对前端的展示做了一定的封装和处理，能够让用户方便快捷地进行前端应用的开发和部署。React和MobX是一对强力组合，React通过提供机制把应用状态转换为可渲染组件树并对其进行渲染。而MobX提供机制来存储和更新应用状态供React使用。 这种机制就是通过使用虚拟DOM来减少昂贵的DOM变化的数量。MobX 提供了优化应用状态与 React 组件同步的机制，这种机制就是使用响应式虚拟依赖状态图表，它只有在真正需要的时候才更新并且永远保持是最新的。 目标 本章节将从创建前端应用、开发前端应用、生成版本、部署应用、配置网络、配置域名等方面介绍，让读者能够熟悉使用Choerodon创建前端应用的步骤和流程，并且学会如何利用Choerodon创建并部署前端应用。 前置条件 1. 在操作之前保证系统配置已经配置完全。 2. 完成创建项目，本章节使用在前面章节创建的项目猪齿鱼研发。 3. 完成创建环境操作。 4. 完成了前端模板库的依赖安装并且成功启动项目。 创建前端应用 1. 使用项目所有者或者源代码管理员的角色登录Choerodon系统，选择项目猪齿鱼研发。 2. 选择持续交付模块，点击开发流水线，点击应用，进入应用管理页面。 3. 点击创建应用，系统会从右边滑出页面，在页面中输入相关信息，有应用编码、应用名称，选择应用模板。 应用编码：choerodon-front 应用编码输入只能包含字母，数字，下划线，空格， '_' '.' \"——\" 只能以字母，数字，下划线开头。 应用名称：猪齿鱼前端应用 选择应用模板: MicroServiceUI 当应用模板不符合您的需求，您可手动创建一个应用模板。 4. 点击创建，即可创建一个前端应用。 5. 当应用创建成功，可在应用管理界面查看到新建的应用。 6. 在创建应用的同时，系统还会在Gitlab中创建一个仓库，点击 仓库地址 ，链接到Gitlab新建的仓库。 Gitlab 仓库的名称是 choerodon-front，为应用编码。 开发前端应用 应用创建完成之后，开发前端应用。具体的操作步骤如下： 1. 创建分支 点击应用，进入到应用管理界面，选择猪齿鱼前端应用。 点击右侧分支管理，点击创建分支，系统会从右边滑出页面，填写issue号，如feature-1。 点击创建，即可创建一个分支。 2. 拉取代码仓库 在存放代码的文件夹下，打开git bash 输入命令git clone [仓库地址]，拉取所需应用的代码仓库。 3. 开发分支 克隆成功后，进入应用根目录，执行命令git checkout feature-1，切换到新建分支feature-1，在此分支进行开发。 创建目录 在 \\iam\\src\\app\\iam\\containers下新建organization文件夹 在organization下新建一个功能文件夹\\demo 在demo文件夹下新建index.js、DemoIndex.js和Demo.js三个文件 修改路由 在\\iam\\src\\app\\iam\\containers\\IAMIndex.js文件中配置我们新建的文件的访问路径： ... const DemoIndex = asyncRouter(() => import('./organization/demo/DemoIndex')); ... ... 完成后，我们就可以进行相关页面的开发了，开发完成后，访问/iam/demo即可查看。 相关代码如下： index.js import Demo from './DemoIndex'; export default Demo; DemoIndex.js ``` import React from 'react'; import { Route Switch } from 'react-router-dom'; import asyncRouter from '../../../../../util/asyncRouter'; const demo = asyncRouter(() => (import('./Demo'))); const DemoIndex = ({ match }) => ( ); export default DemoIndex; ``` Demo.js ``` import React { Component } from 'react'; import { Table } from 'antd'; import { withRouter } from 'react-router-dom'; class Demo extends Component { componentDidMount() { } render() { return ( hello world ); } } // withRouter添加history支持 export default withRouter(Demo); ``` 访问localhost:9090/#/iam/demo即可查看效果。 下面来尝试一下从更复杂的场景，从后端获取10条用户信息并用表格的形式呈现。 将上面的Demo.js的代码改为如下： Demo.js import React { Component } from 'react'; import { Table } from 'antd'; import axios from 'Axios'; import { withRouter } from 'react-router-dom'; const pretendUsers = [ { id: 1 name: '小明' description: '获取后端数据失败，此为模拟数据' } { id: 2 name: '小红' description: '获取后端数据失败，此为模拟数据' } ]; class Demo extends Component { constructor(props) { super(props); this.state = { users: [] }; } componentDidMount() { this.initUsers(); } initUsers() { this.loadUsers() .then((res) => { this.setState({ users: res }); }) .catch((error) => { this.setState({ users: pretendUsers }); }); } loadUsers() { // 此处url为后端接口 return axios.get('http://127.0.0.1:8080/test/v1/user'); } render() { const columns = [{ title: '用户编号' dataIndex: 'id' key: 'id' } { title: '用户名' dataIndex: 'name' key: 'name' } { title: '描述' dataIndex: 'description' key: 'description' }]; return ( record.id} /> ); } } // withRouter添加history支持 export default withRouter(Demo); 访问localhost:9090/#/iam/demo即可查看效果，至此，你已经掌握了简单的前后端搭配的开发方式了。 4. 提交代码 # 将本地代码变动提交到暂存区 $ git add . # 提交代码并且为本次提交添加 commit 信息 # 注：[FIX]修改bug [ADD]新增 [IMP]完善 [DEL]删除 $ git commit –m “[ADD]readme: 新增代码示例” # 将本地提交推送至远程仓库对应分支 $ git push origin feature-1 5. 代码集成 基于feature分支运行CI。点击持续集成 查看 CI 执行情况。 6. 结束分支 点击应用，进入应用管理，点击应用编码choerodon-front的分支管理。 在分支列表找到feature-1，点击结束分支。 生成版本 应用版本是代码提交的历史记录，每提交一次修改后的代码，对应生成一个新的版本。具体的操作步骤如下： 1. 结束分支之后，feature-1分支的代码会合并到develop分支，并触发Gitlab CI。 Choerodon 缺省的 CI 流程有两个阶段: 克隆子库，编译打包 构建docker镜像 2. 点击持续集成，查看CI执行情况。 3. CI运行完成以后，点击应用版本进行查看，确定应用版本已经生成。 部署应用 提供可视化、一键式部署应用，支持并行部署和流水线无缝集成，实现部署环境标准化和部署过程自动化。 1. 使用部署管理员的角色登录Choerodon系统，选择项目猪齿鱼研发。 2. 进入持续交付模块，选择部署管理，点击应用部署进入应用部署界面。 3. 点击部署应用，系统会从右侧滑出部署应用界面，输入如下信息： 选择应用：choerodon-front 选择版本：刚才创建的应用版本 选择环境： 选择要部署的环境 配置信息：配置部署应用所需的信息 部署模式：新建实例（新建一个应用）或 替换实例（滚动更新实例） 4. 点击部署按钮，即可完成部署。 查看实例部署详情 1. 使用部署管理员的角色登录Choerodon系统，选择项目猪齿鱼研发。 2. 进入持续交付模块，选择部署管理，点击应用部署进入应用部署界面。 3. 点击部署应用即可查看实例。有四种查看视图，分别为：部署实例、单环境、单应用、多应用。 如何判断某版本的应用已经部署成功并通过？当实例出现在列表中，且实例名称后没有报错提示icon即为部署成功生成实例；当容器状态条为绿色，数值显示为1/1时表示容器数量为1且通过健康检查，点击右侧的查看实例详情，可以查看到阶段信息及日志。 配置网络 为所选的应用配置网络。 1. 使用部署管理员的角色登录Choerodon系统，选择项目猪齿鱼研发。 2. 进入持续交付模块，选择部署管理，点击网络，进入网络配置界面。 3. 点击创建网络，系统从右侧滑出创建网络界面，输入如下信息： 环境名称：选择要部署的环境 应用名称：猪齿鱼前端应用 版本：刚才创建的应用版本 实例：刚才部署的实例 网络名称：名称默认为“应用编码-4位随机码”，且可手动修改 外部IP：需要外网时填写 端口号：应用开放端口 4. 点击创建按钮即可。 配置域名 为所选的应用配置域名。 1. 使用部署管理员的角色登录Choerodon系统，选择项目猪齿鱼研发。 2. 进入持续交付模块，选择部署管理，点击域名，进入域名管理界面。 3. 点击创建域名，系统会从右侧滑出界面，输入如下信息： 域名：测试域名 域名地址：choerodon.io 路径：choerodon-front 网络：配置的网络 4. 点击创建即可。 产品迭代 任何产品几乎都会经历产品的初创期、成长期、成熟期。在产品的初创期，需要通过快速试错探索出有用户黏性的功能；探索成功之后，就需要快速导入用户，这时候也会产生新的需求和新的问题，不断去完善产品；在产品的相对成熟期，则可以考虑产品的变现，和新功能的延展，以提升用户活跃。因此，当一个产品开发完成上线后，产品的周期化迭代就变得非常重要。固定的周期有助于为项目团队形成规范，从而提高开发效率。 Choerodon第一次发版前就准备好下个版本的需求。一般第一个版本上线后，开发人员就进入下一个版本的开发和测试。这样当问题暴露的时候，就可以迅速解决问题，优化到某个程度后，再放缓迭代节奏，这样就能更好的平衡好需求。 "},"/docs/quick-start/minjie":{"url":"docs/quick-start/minjie","title":"使用敏捷管理工具","description":"","body":"使用敏捷管理工具 概述 Choerodon认为软件交付过程的本质是用户价值的实现，而用户价值的实现是通过用户价值流动来体现的，Choerodon提供了一套工具来帮助用户通过敏捷的方式来管理用户价值的流动，使整个软件开发流程管理化规范化。 敏捷管理是以用户需求演变为中心，通过迭代方式来进行的软件开发。Choerodon敏捷管理的核心是需求，计划和执行。即通过故事地图、用户故事来管理用户故事和发布计划，通过迭代来管理冲刺，最后通过看板来可视化冲刺的执行。 目标 本页面主要介绍choerodon的敏捷管理，从创建用户故事地图、冲刺管理、敏捷看板等功能介绍使用方法，使用户阅读整个流程后，能够熟知整个操作流程。 创建用户故事地图 故事地图已经成为敏捷管理在需求规划中的一个重要的方法。Choerodon的故事地图可以将你的用户故事（user stories）像地图一样展现出来，而不是传统的简单列表形式。 1.创建角色 使用项目所有者或者源代码管理员的角色登录Choerodon系统，选择项目猪齿鱼研发。 选择敏捷管理模块，点击故事地图，点击创建角色按钮，将鼠标移动至角色列，此时鼠标变为十字形，点击即可创建一个角色； 再次点击创建项目，选中刚才创建的角色卡，输入角色名称，点击保存，可修改角色名称。 2.创建活动 点击创建活动按钮，将鼠标移动至活动列，此时鼠标变为十字形，点击即可创建一个活动； 再次点击创建活动，选中刚才创建的活动卡，输入活动名称，点击保存，可修改活动名称。 3.创建任务 点击创建任务按钮，将鼠标移动至任务列，此时鼠标变为十字形，点击即可创建一个活动； 再次点击创建任务，选中刚才创建的任务卡，输入任务名称，点击保存，可修改任务名称。 4.创建故事 点击发布计划按钮，将鼠标移动至发布计划列表下，点击创建故事，即可创建一个故事；选中刚才创建的故事卡，输入故事名称，点击保存，可修改故事名称。 当故事较多时，可点击添加故事列表进行添加。 2. 点击‘导出为图片’按钮可导出当前故事地图的图片。 故事地图页面的滑动轴可调整压面大小。 迭代冲刺 用迭代来管理冲刺，每一个迭代对应一次冲刺，也可以简单理解为每一次冲刺就是一个迭代周期。在固定的时间内，要完成需求分析、设计、实现、测试等一系列活动，在迭代周期完成的时候提供一个可工作的产品。每一次迭代完成的可能是一个或几个完整的用户故事，也可能是一个用户故事中的若干用户任务。 1.创建冲刺 选择敏捷管理模块，点击冲刺，进入冲刺管理页面，点击创建冲刺，会弹出一个侧边框，填写相关信息； 　　a 选择发布计划：选择刚才创建的发布计划 　　b 冲刺名称：填写冲刺名称 　　c 冲刺目标：填写冲刺目标 　　d 时长：选择冲刺时间 　　e 预计开始时间：选择预计开始时间 　　f 预计结束时间：选择预计结束时间 信息填写完成以后，点击创建即可。 2.导入用户故事 回到冲刺管理界面，可以查看刚才创建的冲刺，点击冲刺名称，进入冲刺详情界面。 点击导入用户故事，选择导入的冲刺和导入的用户故事，点击确定可导入之前创建的故事地图。故事地图会同步生成的ID显示在界面上。 冲刺管理界面中的待办事项可向冲刺里拖拽状态为product backlog的用户故事、任务、缺陷，拖拽后的issue会关联到该冲刺中。 冲刺里的issue都添加好之后，用户可点击开始冲刺按钮开启冲刺。 冲刺开启后，issue的信息会同步到看板中，之后用户可在看板中操作。 点击冲刺后可跳转到冲刺详情，该详情页面记录当前冲刺的用户故事、任务、缺陷的完成情况，以及故事点、工作量、进度等信息。冲刺燃尽图、时间前置图、累计流图是冲刺的三个统计图表。 冲刺下的用户故事、任务、缺陷详情页面可修改该issue的具体信息，包括优先级、负责人、工作预估、工作日志、描述等，用户之间还可在评论模板下对该issue展开讨论。 看板管理 我们都知道在软件开发过程中，短板或者瓶颈会直接的影响整个开发进程。看板方法是用于高效管理软件开发流程的新技术。Choerodon看板是Choerodon敏捷管理中执行部分，它的核心作用是可视化整个迭代的计划执行，并且暴露开发执行过程中的短板或者瓶颈。 1.选择模板 选择敏捷管理模块，点击看板，进入看板页面； 点击选择模板，选中相应的模板后，点击确定；您也可以自定义一个模板。 非sprint backlog列无卡片时可选择。 点击看板右上方的编辑按钮可进入到看板绘制页面，该页面可增删改看板列、泳道，设置在制品、起始列、终止列等，绘制完毕后点保存按钮即可。 2.创建修改故事卡片 看板中可创建卡片，创建后的卡片会同步到对应的冲刺与发布计划中。点击创建卡片键，如下图，填写相关信息，点击保存即可。 点击issue卡片，可查看issue详情，点击编辑，可对标题、负责人、需求类型等信息进行修改； 根据项目进度，可调整故事卡片的位置，拖拽故事卡片至相应的位置即可； issue下有子卡的，可将子卡拖拽到看板中，对应的子卡数量相应减少。 当此次迭代（冲刺）完成后，可到冲刺管理页面关闭冲刺，冲刺关闭后将生成历史看板，完整保存关闭冲刺时的看板页面，进入到历史看板中只可查看相关issue的信息，不可增删改等。 Issue管理 展示的是当前项目的所有用户故事、任务、缺陷，点击issue可查看、修改详情。 页面可创建卡片，创建后会同步到故事地图的未规划区中。 用户故事 选择敏捷管理模块，点击用户故事，进入故事管理页面； 点击创建故事，填写填写相关信息； 点击保存，即可创建一个用户故事； 任务管理 选择敏捷管理模块，点击任务，进入任务管理页面； 点击任务右侧详情，可查看修改详情。 缺陷管理 选择敏捷管理模块，点击漏洞，进入漏洞管理页面； 点击缺陷右侧详情，可查看修改缺陷。 总结 敏捷开发作为一种面临迅速变化的需求，快速开发出高质量软件产品的新方法，自问世以来，对软件开发起着积极而又重要的影响，颇受业内人士推崇。由于软件在规模、复杂度、功能上的极大扩展和提高，以及在需求和技术不断变化的过程中实现软件自身开发的需求，敏捷开发正逐渐成为软件开发的新模式。因此，我们应当更好的利用这种方法，适应快速的需求变化，达到完善需求分析，改进开发过程，提高软件项目管理水平的目的，扩展它的应用领域。 "},"/docs/quick-start/project":{"url":"docs/quick-start/project","title":"创建一个项目","description":"","body":"创建一个项目 目标 项目是 Choerodon 组织开发的基本形式，隶属于组织。一个项目包含与开发相关的资源、环境、敏捷管理，以及用户权限控制等。项目是进行应用创建开发，敏捷管理，持续交付的基础，必须先创建项目，才能够进行下一步的工作。 本章节将从创建项目、角色分配、创建环境等方面介绍 Choerodon 项目，让读者能够了解项目的基本概念，学会创建项目的基本操作，并且会为项目分配权限，创建环境等。 前置条件 1. 在操作之前保证系统配置已经配置完全。 2. 用户必须属于组织层，且属于唯一组织。 创建项目 具体操作步骤如下： 1. 使用项目创建者的角色登录Choerodon系统，系统会默认一个组织，点击该组织，弹出组织/项目选择界面。 2. 点击组织choerodon，选择组织管理模块。 3. 进入组织管理后，点击项目管理。 4. 进入项目管理页面后，点击创建项目，系统会从右侧滑出创建项目页面，输入项目编码和项目名称。 项目编码：choerodon-dev 项目名称：猪齿鱼研发 　 项目编码 必须输入，且编码只能包含字母，数字，下划线，空格， '_' '.' \"——\" 只能以字母，数字，下划线开头。 5. 填写完成后，点击创建，即可创建新的项目。 6. 当项目创建成功，Choerodon同时会在Gitlab中创建一个Group和Issue库。我们可以登录到Gitlab检查创建。 Gitlab Group 的名称是 choerodon-choerodon-dev，为组织编码 -项目编码。 角色分配 项目创建完成之后，需要为相关人员分配权限。具体的操作步骤如下： 1. 使用项目创建者的角色登录系统，并切换到已经创建的项目下，例如Choerodon下的猪齿鱼研发。 2. 选择项目设置模块，点击项目角色分配，进入角色分配操作界面。 3. 点击添加，系统会从右侧滑出添加成员角色页面，输入相关信息，有成员、角色。 4. 信息填写完成后，点击添加即可。 与项目相关的角色权限如下表： 角色 权限 层级 项目所有者 项目角色分配、项目信息、应用管理、分支管理、持续集成、应用版本、环境流水线（仅查看）、应用部署（仅查看）、网络管理（仅查看）、域名管理（仅查看）、容器管理 项目层 项目成员 应用管理（仅查看）、分支管理（仅有developer权限）、持续集成、应用版本、环境流水线（仅查看）、应用部署（仅查看）、网络管理（仅查看）、域名管理（仅查看）、容器管理 项目层 部署管理员 环境流水线、应用部署、网络管理、域名管理、容器管理 项目层 角色分配为项目所有者可操作。 创建环境 环境是一个应用被部署的地方。例如，项目A经过一个冲刺产生了应用B的最新版本1.0.1，此时在项目A下面定义了两个环境，即测试环境和正式环境，项目A按照既定的项目管理流程现将应用B的最新版本1.0.1在测试环境中部署，以供测试人员测试。当测试通过，再将1.01版本在正式环境中部署。 1. 前置条件 本机安装kubectl 本机安装helm helm需要先初始化。 2. 具体的创建步骤如下： 使用项目创建者角色登录系统，进入项目层，选择一个项目，例如choerodon下的猪齿鱼研发。 选择持续交付模块 ，点击部署管理，选择环境流水线。 点击创建，系统会滑出创建环境页面，输入相关信息，有环境编码、环境名称、环境描述。 环境编码：dev-env 环境名称：开发环境 环境描述：开发环境 根据用途配置不同的环境，常见的有开发环境，集成测试环境，用户访问测试环境及正式环境。 填写完成后，点击创建。 复制Kubectl命令至kubernetes中运行，与平台建立连接。 运行前需要先初始化helm helm init helm repo update。 helm 的版本必须与服务器上helm版本一致。 创建成功后，环境状态为运行中。 总结 项目是Choerodon最重要的概念，它是开发区组织资源的基本形式。通过本章节简单的学习，我们可以在Choerodon系统中创建自己的项目以及设置相关环境和权限等。用户可以根据自己具体的情况来创建项目，根据DevOps和敏捷管理的思想，Choerodon 建议按照一个Scrum中Develop团队的规模（6-9个人）来划分项目。例如，我们可能研发一个产品需要分成3个小团队，分别负责3个产品子模块，每个项目负责改模块下的后端及前端应用，具体情况需视产品大小及范围而定。 "},"/docs/quick-start/web-application":{"url":"docs/quick-start/web-application","title":"创建一个Java库","description":"","body":"创建一个Java库 概述 众所周知，Java 的生态环境相当庞大，包含了数量相当可观的官方及第三方库。利用这些库，可以解决在用 Java 开发时遇到的各类问题，让开发效率得到显著提升。大部分项目实际上还是需要进行单元测试、日志记录、序列化、代码规范化等工作，因此用一些相关的Java库区解决问题，还是一个不错的选择。 目标 本页面介绍以Choerodon平台为基础，通过创建Java库，开发Java等方面介绍，演示如何创建一个Java库，让用户熟知整个操作流程。 前置条件 1. 在操作之前保证系统配置已经配置完全。 2. 完成创建项目操作。本章节使用在前面章节创建的项目猪齿鱼研发。 3. 完成创建环境操作。 创建Java库 1. 使用项目所有者或者源代码管理员的角色登录Choerodon系统，选择项目猪齿鱼研发。 2. 选择持续交付模块，点击开发流水线，点击应用，进入应用管理页面。 3. 点击创建应用，系统会从右边滑出页面，在页面中输入相关信息，有应用编码、应用名称，选择应用模板。 应用编码：choerodon-jar 应用编码输入只能包含字母，数字，下划线，空格， '_' '.' \"——\" 只能以字母，数字，下划线开头。 应用名称：猪齿鱼jar应用 选择应用模板: JavaLib 当应用模板不符合您的要求，你可手动创建一个应用模板。 4. 当应用创建成功，可以在应用管理查看到新建的应用。 5. 在创建应用的同时，系统还会在Gitlab中创建一个仓库，点击 仓库地址 ，链接到Gitlab新建的仓库。 Gitlab 仓库的名称是 choerodon-jar，为应用编码。 开发Java库 Java库创建完成之后，开发Java库。具体的操作步骤如下： 1. 创建Feature分支 点击应用，进入到应用管理界面，选择猪齿鱼jar应用。 点击右侧分支管理，点击创建分支，系统会从右边滑出页面，填写issue号，如feature-1。 2. 拉取代码仓库 在存放代码的文件夹下，打开git bash，输入命令git clone [仓库地址]，拉取所需应用的代码仓库。 3. 开发分支 克隆成功后，进入应用根目录，执行命令git checkout feature-1，切换到新建分支feature-1，在此分支进行开发。 4. 提交代码 # 将本地代码变动提交到暂存区 $ git add . # 提交代码并且为本次提交添加 commit 信息 # 注：[FIX]修改bug [ADD]新增 [IMP]完善 [DEL]删除 $ git commit –m “[ADD]readme: 新增代码示例” # 将本地提交推送至远程仓库对应分支 $ git push origin feature-1 记得修改maven 仓库地址。 ５. 代码集成 基于feature分支运行CI。点击持续集成，查看 CI 执行情况。 6.结束分支 点击应用，进入应用管理界面，点击猪齿鱼jar应用的分支管理。 在分支列表找到feature-1，点击结束分支。 7. 创建Release分支 多次创建分支，待开发完成以后，发布Jar包。 点击应用，进入应用管理界面，选择猪齿鱼jar应用。 点击右侧分支管理， 选择创建分支；系统会从右边滑出页面，填写issue号。 点击创建按钮，即可创建一个Release分支。 在分支列表找到刚才创建的分支，点击结束分支。 点击持续集成，再次查看CI运行情况。 如果CI运行成功，去maven仓库地址查看是否打包成功。 生成的JAR包的信息如下： 　　　　groupId: 组织编码-应用编码(choerodon-choerodon-dev) 　　　　artifactId: 应用编码(choerodon-jar) 　　　　version: 1.0-SNAPSHOT(以pom文件内的版本为准) 8. pom依赖引用 choerodon-choerodon-dev choerodon-jar 1.0-SNAPSHOT 产品迭代 任何产品几乎都会经历产品的初创期、成长期、成熟期。在产品的初创期，需要通过快速试错探索出有用户黏性的功能；探索成功之后，就需要快速导入用户，这时候也会产生新的需求和新的问题，不断去完善产品；在产品的相对成熟期，则可以考虑产品的变现，和新功能的延展，以提升用户活跃。因此，当一个产品开发完成上线后，产品的周期化迭代就变得非常重要。固定的周期有助于为项目团队形成规范，从而提高开发效率。 Choerodon第一次发版前就准备好下个版本的需求。一般第一个版本上线后，开发人员就进入下一个版本的开发和测试。这样当问题暴露的时候，就可以迅速解决问题，优化到某个程度后，再放缓迭代节奏，这样就能更好的平衡好需求。 "},"/docs/user-guide/Assembly line/Assembly line":{"url":"docs/user-guide/Assembly line/Assembly line","title":"持续集成","description":"","body":"持续集成 持续集成是 Gitlab 自带的持续集成引擎，免去了第三方 CI 服务器只能定时检测 Git 仓库带来的延迟和对 Git Server 造成的性能压力。 菜单层次：项目层 菜单路径：持续交付 > 开发流水线 > 持续集成 默认角色：项目所有者、项目成员 查看持续集成详情 进入持续交付后，点击 持续集成 页签； 查看应用持续集成的完成情况； 查看应用持续集成的完成情况，只有 CI 各个阶段跑成功了才会生成一个应用版本。 版本命名方式：合并至 develop：develop. + 年月日时分秒。 Tag 生成：版本号（三位号码，如：1.1.0。release 修改前两位，hotfix 修改第三位）。 提交：每次提交代码的操作，自动生成 Commit ID，由于字数多，平时多取前八位。 列表字段： 状态：Job 的状态 Created，Pending，Running，Failed，Success，Canceled，Skipped，Manual。 标识：持续集成标识+持续集成触发者。 提交：提交的信息。 阶段：持续集成的阶段 分为单元测试和生成镜像两个阶段。单元测试阶段完成单元测试的运行并且对代码质量进行审查，生成镜像阶段通过 docker 把应用生成镜像。 时长：持续集成持续的时长。 创建时间：持续集成创建的时间。 ：当处于 Skipped、Canceled、Failed 状态时，可以重新运行 CI。 "},"/docs/user-guide/Assembly line/Branch management":{"url":"docs/user-guide/Assembly line/Branch management","title":"分支管理","description":"","body":"分支管理 Choerodon 采用 git-flow 工作流模式，有master和develop两个默认分支。在持续交付过程中对 feature、release、hotfix 等分支进行管理。结束分支可自动触发分支合并和持续集成，可在流水线查看代码集成情况。 菜单层次：项目层 菜单路径：持续交付 > 开发流水线 > 应用 > 分支管理 默认角色：项目所有者、项目成员 项目成员对分支管理仅有 Developer 权限。 分支类型 Master：默认分支，版本发布分支。 Develop：默认分支，日常开发分支。 Feature：适用于日常开发、bug 修复，基于开发分支生成，完成时合并至开发分支。 Release：适用于产品发布、产品迭代，基于开发分支生成，完成时合并至主分支和开发分支，并打上标签。 Hotfix：适用于产品发布后修复 bug，基于主分支生成，完成时先合并至主分支和开发分支，并打上标签。 分支使用流程 分支使用流程包括四个部分：创建分支、拉下分支至本地开发、开发完提交代码/解决冲突、结束分支。 创建分支 点击创建分支按钮，创建对应分支； 然后选分支类型，再输入Issue编码或版本号； 点击创建按钮。 Feature/Hotfix 分支创建时输入Issue编码作为分支名。 Release 分支创建时会自动生成下一个版本号，也可以手动输入需要的版本号。（版本号由三个数字组成，中间以小数点间隔。如：1.1.0。Release 版本号默认为末位清零，中间一位进一）。 结束分支 feature 分支在结束时会合并生成对应的服务版本； 版本命名方式：合并至 develop：develop. + 年月日时分秒；Tag 生成：版本号（三位号码，如：1.1.0。release 修改前两位，hotfix 修改第三位）。 Release 分支在结束时会生成对应的服务版本，版本号与创建时填写一致； Hotfix 分支在结束时会提示以最新版本的第三位加一作为版本号。如最新版本为1.1.5，则hotfix分支结束时生成新版本为1.1.6； 无提交时点击结束分支，将不创建合并请求，直接删除。 另外，创建分支及结束分支只能在平台界面进行操作，请勿随意在 Gitlab 界面创建合并请求和删除分支 示例：分支管理操作步骤 克隆代码到本地； # 在存放代码的文件夹下执行以下命令，拉取所需服务的代码仓库 git clone http://choerodon.io/choerodon-choerodon-dev/choerodon-backend.git # 拉取远程仓库成功后进入仓库 cd choerodon-backend.git 拉取最新代码和创建的分支； git pull 切换到分支； # 切换到创建分支，以 feature-1 为例 git checkout feature-1 开发； 根据分支对应的 Issue 需求修改代码，完成后详细检查本地代码改动。 提交代码； # 将本地代码变动提交到暂存区 git add . # 提交代码并且为本次提交添加 commit 信息 # 注：[FIX]修改bug [ADD]新增 [IMP]完善 [DEL]删除 $ git commit –m “[ADD]readme: 新增代码示例” # 将本地提交推送至远程仓库对应分支 $ git push origin feature-1 界面操作结束分支。 解决分支冲突 Feature 分支冲突 常见两种解决冲突的方式如下： 本地修改代码解决： # 确保当前正在 Feature 分支上，以 feature-1 为例 git checkout feature-1 # 拉取最新远程仓库 develop 分支代码 git fetch origin develop:develop # 将 Feature 分支重新设立起点于最新的 develop 代码 git rebase develop 执行完 rebase 操作后，会产生对应的冲突，解决冲突后执行如下代码。 git add . git rebase --continue 根据本次 Feature 分支上提交次数的不同，解决冲突可能会重复多次，只需要重复执行上述解决冲突操作。 完成后强制提交至远程仓库。 git push -f origin feature-1 Release&Hotfix 分支冲突 当分支对于 develop 和 master 分支中任意一个或以上存在冲突时，会提示当前存在冲突及建议做法。 若此时继续点击确定按钮，并且没有解决冲突，那么会提示分支冲突，无法继续操作。 解决冲突具体步骤可查看界面提示，说明如下： 只有对应 develop 的合并请求存在冲突，按界面提示解决冲突会导致分支对应 develop 分支的合并请求被合并。此时再进行结束分支操作，会处理分支对 master 的合并请求，然后生成对应版本号的 Tag 并删除分支。 只有对应 master 的合并请求存在冲突，按界面提示解决冲突会导致分支对应 master 分支的合并请求被合并。此时再进行结束分支操作，会处理分支对 develop 的合并请求，然后生成对应版本号的 Tag 并删除分支。 若分支对应 develop 和 master 分支的合并请求都存在冲突，按界面提示解决冲突会导致分支对应 develop 和 master 分支的合并请求依次都被合并。此时再进行结束分支操作，会生成对应版本号的 Tag 并删除分支。 "},"/docs/user-guide/Assembly line/":{"url":"docs/user-guide/Assembly line/","title":"开发流水线","description":"","body":"介绍 开发流水线中描述了集成 Gitlab 作为代码托管的仓库，以及采用 Gitflow 分支模型进行一个应用的管理。可以查看应用的所有版本信息、应用编码、应用名称及版本创建时间，并描述了应用的持续集成流水线信息。 功能 应用模板 是将同类型应用的代码库结构整理成模板，用于创建应用时能引用相应模板快速创建初始代码库。 应用管理 一个系统可以被解耦成很多应用，每一个应用都可以独立部署，每一个应用仅关注于完成一部分任务，每部分任务代表一个小的业务模块，因此各应用之间关系是松耦合的。另外，每创建一个应用，系统会自动在gitlab创建好对应的代码库。 分支管理 采用的 Gitflow 工作流模式，有Master和Develop两个默认分支。在持续交付过程中对 Feature、Release、Hotfix 等分支进行管理。结束分支可自动触发分支合并和持续集成，可在流水线查看代码集成情况。 持续集成 是 Gitlab 自带的持续集成引擎，免去了第三方 CI 服务器只能定时检测 git 仓库带来的延迟和对 Git Server 造成的性能压力。能够解决的问题有小步伐的产品迭代，高频率的版本发布，随时随地的系统集成等，达到效率极大增加的作用。 应用版本 由于 Choerodon 采用 Gitflow 的方式管理分支，所以对于版本的控制也是根据 Feature、Release、Hotfix 等分支上进行的。 "},"/docs/user-guide/Assembly line/application management":{"url":"docs/user-guide/Assembly line/application management","title":"应用管理","description":"","body":"应用管理 应用是满足用户某些需求的程序代码的集合，一个系统可以被解耦成很多应用，每一个应用都可以独立部署，每一个应用仅关注于完成一部分任务，每部分任务代表一个小的业务模块，因此各应用之间关系是松耦合的。另外，每创建一个应用，系统会自动在 Gitlab 创建好对应的代码库。 只有该项目的项目所有者才能创建应用，项目成员仅能查看应用。 菜单层次：项目层 菜单路径：持续交付 > 开发流水线 > 应用 默认角色：项目所有者、项目成员 项目成员对应用管理只有查看界面的权限，不可进行编辑修改。 创建应用 输入应用编码及名称，创建一个新的应用，步骤如下。您也可以选择一个应用模板，快速创建应用，平台会为您自动创建对应的 Git 库以便管理该应用代码。 点击 创建应用 按钮； 输入应用编码、应用名称、以及选择应用模板，点击 创建 按钮； 应用编码：应用中自定义的编码。 应用名称：应用中自定义的名称。 应用模板：系统预定义模板或组织自定义的模板快。 系统预定义模板：Java库-JavaLib;微服务-MicroService;web前端-MicroServiceUI 创建成功后，可去 Gitlab 中查看已创建的代码。 查看应用详情 点击应用，在应用管理界面，根据应用名称、应用编码、仓库地址、应用状态来查看应用详情。 列表字段 应用名称：应用的自定义名称； 应用编码：应用的自定义编码； 仓库地址：应用 Git 仓库地址； 应用状态：应用运行有三种状态，分别为启用、停用、创建中。 分支管理 点击分支管理→ 对应用信息进行分支管理。 修改应用信息 点击修改应用→ 对应用信息进行修改。 停用/启用应用 点击 停用→ ，如： “猪齿鱼研发” 已停用，应用详情不可查看。 点击 启用→ ，如： “猪齿鱼研发” 已启用，可对该应用进行相关操作。 "},"/docs/user-guide/Assembly line/application-template":{"url":"docs/user-guide/Assembly line/application-template","title":"应用模板","description":"","body":"应用模板 应用模板是将同类型应用的代码库结构整理成模板，用于创建应用时能引用相应模板快速创建初始代码库。每种应用模板至少都包括 CI 文件以及 Chart 目录文件。 平台提供默认的常用模板，用户可以根据实际情况自定义符合更多需求的应用模板。 菜单层次：组织层 菜单路径：持续交付 > 应用模板 默认角色：组织管理员 创建应用模板 输入应用模板编码，名称，描述，创建默认最简模板，步骤如下。您也可以通过复制于现有模板，以便节省部分共同操作，提升效率。 点击创建应用模板按钮； 输入应用相关信息，点击创建按钮； 本地克隆应用模板对应的代码库。一个正确的模板中应该包含: Spring-boot 项目+ Gitlab-ci.yml 文件+ Dockerfile 文件+ Charts 模块。 Spring-boot 项目: 生成应用时的初始项目 Gitlab-ci.yml 文件: 定义 Gitlab CI 的阶段 Dockerfile 文件: 用于应用部署时生成镜像 Charts 模块: 用于创建应用时生成创建 k8s 对象 如: Deployment job service ingress 部署时配置信息里的 Key-value 值会被应用到对应的 k8s 对象中用于部署。 创建前端应用模板 当应用模板不符合您的要求，你可手动创建一个应用模板。具体步骤如下： 在组织层的持续交付模块，选择应用模板； 点击创建应用模板，输入相关信息，点击创建，即可创建一个模板； 创建完成以后，会生成一个 Gitlab 地址，点击该地址； 进入 Gitlab 仓库，克隆代码； 创建一个 React 的前端UI项目； 编写一个Dockerfile； 将 Dockerfile 文件放在项目根目录下 FROM registry.choerodon.io/tools/nginx:stable RUN echo \"Asia/shanghai\" > /etc/timezone; ADD dist /usr/share/nginx/html COPY entrypoint.sh . ENTRYPOINT [ \"sh\" \"./entrypoint.sh\" ] entrypoint.sh文件如下 ``` #bin/bash set -e PRO_API_HOST=${PRO_API_HOST:-\"gateway.devops.saas.choerodon.com\"} PRO_CLIENT_ID=${PRO_CLIENT_ID:-\"devops\"} find /usr/share/nginx/html -name '*.js' | xargs sed -i \"s/localhost:8080/$PRO_API_HOST/g\" find /usr/share/nginx/html -name '*.js' | xargs sed -i \"s/localhost:clientId/$PRO_CLIENT_ID/g\" nginx -g 'daemon off;' exec \"$@\" ``` 编写 Gitlab-CI 文件 image: registry.choerodon.io/tools/devops-ci:1.1.0 image 指 CI 运行基础镜像。 stages: - node_build - docker_build stages指包含 node_build 和 docker_build 两个阶段 。 node_build_dev: stage: node_build script: - node_config - node_module iam - node_build devbuild - clean_cache only: - /^release-.*$/ - /^hotfix-.*$/ - develop - tags node_build_dev 指 job 名称。 stage 指对应的阶段。 script 指执行的命令。 only 指触发的分支。 .auto_devops: &auto_devops | curl -o .auto_devops.sh \\ \"${CHOERODON_URL}/devops/ci?token=${Token}&type=microservice\" source .auto_devops.sh .auto_devops: 从指定仓库地址中拉取 script 脚本 用于 docker-build 阶段。 before_script: - *auto_devops before_script 指 ci 执行前所执行的命令。 编写 charts 模块； 目录结构如下 |--charts ｜--model-service ｜--templates ｜--_helper.tpl ｜--deplopment.yaml ｜--.helmignore ｜--Chart.yaml ｜--values.yaml templates为模板文件，将模板文件渲染成实际文件，然后发送给 Kubernetes。 values.yaml为模板的预定义变量。 Chart.yaml包含 chart 的版本信息说明，您可以从模板中访问它。 deployment.yaml：创建 Kubernetes 部署的基本清单。 _helpers.tpl：放置模板助手的地方，您可以在整个 chart 中重复使用。 编写 config.js； 提交代码，即可完成模板创建。 创建后端应用模板 当应用模板不符合您的要求，你可手动创建一个应用模板。具体步骤如下： 在组织层的持续交付模块，选择应用模板； 点击创建应用模板，输入相关信息，点击创建，即可创建一个模板； 创建完成以后，会生成一个 Gitlab 地址，点击该地址； 进入 Gitlab 仓库，克隆代码； 创建一个 spring-boot 项目； 编写一个 dockerfile； 目录结构如下： |--src ｜--main ｜--docker ｜--dockerfile ``` FROM registry.choerodon.io/choerodon-cloud/base COPY app.jar /app.jar ENTRYPOINT [ \"java\" \"-jar\" \"/app.jar\"] ``` 编写 Gitlab-ci 文件 image: registry.choerodon.io/tools/devops-ci:1.1.0 image 指 ci 运行基础镜像。 stages: - maven-package - docker-build stages 指包含 maven-package 和 docker-build 两个阶段。 maven-feature: stage: maven-package script: - git_merge develop - update_pom_version - mvn package -U -DskipTests=false - mvn --batch-mode verify sonar:sonar -Dsonar.host.url=${SONAR_URL}- Dsonar.analysis.mode=preview -Dsonar.gitlab.commit_sha=${CI_COMMIT_SHA} -Dsonar.gitlab.ref_name=${CI_COMMIT_REF_NAME} -Dsonar.gitlab.project_id=${CI_PROJECT_ID} only: - /^feature-.*$/ maven-feature 指 job 名称。 stage 指对应的阶段。 only 指触发的分支。 .auto_devops: &auto_devops | curl -o .auto_devops.sh \\ \"${CHOERODON_URL}/devops/ci?token=${Token}&type=microservice\" source .auto_devops.sh .auto_devops: 从指定仓库地址中拉取 script 脚本 用于 docker-build 阶段。 before_script: - *auto_devops before_script：ci 执行前所执行的命令 编写 charts 模块 目录结构如下： |--charts ｜--model-service ｜--templates ｜--_helper.tpl ｜--deplopment.yaml ｜--pre-config-congig.yaml ｜--pre-config-db.yaml ｜--service.yaml ｜--.helmignore ｜--Chart.yaml ｜--values.yaml templates为模板文件，将模板文件渲染成实际文件，然后发送给 Kubernetes。 values.yaml为模板的预定义变量。 Chart.yaml包含 chart 的版本信息说明，您可以从模板中访问它。 deployment.yaml：创建 Kubernetes 部署的基本清单。 service.yaml：为您的部署创建服务端点的基本清单。 _helpers.tpl：放置模板助手的地方，您可以在整个 chart 中重复使用。 提交代码，即可完成模板创建。 创建Java库应用模板 当应用模板不符合您的要求，你可手动创建一个应用模板。具体步骤如下： 在组织层的持续交付模块，选择应用模板； 点击创建应用模板，输入相关信息，点击创建，即可创建一个模板； 创建完成以后，会生成一个 Gitlab 地址，点击该地址； 进入 Gitlab 仓库，克隆代码； 创建一个普通 Java 应用； 编写一个 Gitlab CI； stages: - mvn-package stages 定义 CI 中包含的阶段。 ``` stylus maven-branches: stage: mvn-package script: - update_pom_version - mvn clean && mvn package -U -DskipTests=false - mvn --batch-mode verify sonar:sonar -Dsonar.host.url=${SONAR_URL} -Dsonar.analysis.mode=preview -Dsonar.gitlab.commit_sha=${CI_COMMIT_SHA} -Dsonar.gitlab.ref_name=${CI_COMMIT_REF_NAME} -Dsonar.gitlab.project_id=${CI_PROJECT_ID} only: - develop - /^release-.*$/ - /^hotfix-.*$/ - /^feature-.*$/ except: - tags ``` maven-branches 指 job 名称。 stage 指对应的阶段。 script 指执行的命令。 only 指触发的分支。 except 指不会触发的分支。 ``` stylus .auto_devops: &auto_devops | curl -o .auto_devops.sh \\ \"${CHOERODON_URL}/devops/ci?token=${Token}&type=lib\" source .auto_devops.sh ``` .auto_devops：从指定仓库地址中拉取 script 脚本 用于 docker-build 阶段。 ```yaml before_script: - *auto_devops ``` before_script：指 ci 执行前所执行的命令。 提交代码。 查看应用详情 在详情界面根据应用模板名称、应用模板编码、应用模板描述、应用模板地址、应用模板来源来查看应用详情。 列表字段 应用模板名称：应用模板的自定义名称。 应用模板编码：应用模板的自定义编码。 应用模板描述：应用模板的自定义描述。 应用模板地址：应用模板的 Git 仓库地址。 应用模板来源：有预定义和自定义两种来源。预定义是 Choerodon 系统预置的模板；自定义是由用户自己创建的模板。 修改模板信息 点击修改模板→ 按钮 ，进行应用模板名称和描述的修改。 删除模板 预定义模板无法删除； 点击删除模板→ 按钮，进行模板的删除。 若删除模板，该条数据将被永久删除，不可恢复! "},"/docs/user-guide/Assembly line/service version":{"url":"docs/user-guide/Assembly line/service version","title":"应用版本","description":"","body":"应用版本 由于 Choerodon 采用 Git-flow 的方式管理分支，所以对于版本的控制也是根据 eature、Release、Hotfix 等分支上进行的。 菜单层次：项目层 菜单路径：持续交付 > 开发流水线 > 应用版本 默认角色：项目所有者、项目成员 查看应用版本详情 进入持续交付后，点击 应用版本 页签； 查看应用版本信息。 列表字段 应用版本：迭代升级中对应的不同版本。 应用编码：创建应用的自定义编码。 应用名称：创建应用的自定义名称。 创建时间：应用创建时的时间。 版本控制方式 基于 Develop 分支生成一个 Feature 分支，开发人员在 Feature 分支上开发，例如 Feature-101，其中编号101是新 Feature 对应的 ISSUE 编号。 将 Feature 分支合并到 Develop 分支，开发人员完成 Feature 开发，并删除 Feature 分支。 基于 Develop 分支生成一个 Release 分支，准备发布版本代码，每生成一个 Release 分支，中间版本号自动加1，末位清0，初始版本号是1.0.0，例如当前版本是1.1.0，生成一个 Release 分支，此分支为 Release-1.2.0，其中1.2.0是下一个版本的版本号。 将 Release 分支合并到 Develop 分支，完成发布版本代码准备。 将 Release 分支合并到 Master 分支，完成发布版本，生成新版本 tag，例如版本1.2.0。 4.和5.没有先后顺序，当4和5都完成系统会自动删除 Release 分支，例如 Release-1.2.0。 如果 Master 分支或者新版本存在 Bug，基于Master分支生成一个 Hotfix 分支，开发人员修复 Bug，末位版本号自动加1，例如当前版本是1.2.0，生成一个 Hotfix 分支，此分支为 Hotfix-1.2.1，其中1.2.1是热修复的版本号。 将 Hotfix 分支合并到 Develop 分支，完成 Bug 修复。 将 Hotfix分支合并到 Master 分支，更新 Bug 修复版本，生成新版本 tag，例如版本1.2.1。 注： 7.和8.没有先后顺序，当7.和8.都完成系统会自动删除 Hotfix 分支，例如 Hotfix-1.2.1。 "},"/docs/user-guide/":{"url":"docs/user-guide/","title":"用户手册","description":"","body":"用户手册 本用户手册介绍了 Choerodon 各环节的操作步骤。Choerodon 的用户可以通过此章节了解每个环节的概念定义、主要功能流程及其他注意事项。使用本教程，您可以了解： 系统配置 是为了让 Choerodon的用户更便捷、科学地使用平台，在用户使用前需要进行的系统配置，包括角色、用户、项 目、环境等。 开发流水线 以 DevOps 理念为指引，借助 Gitlab CI 作为持续集成工具，结合 Gitflow 分支管理模型，提供持续集成的流水线可以最大限度地减少代码冲突风险，降低修复错误代码的成本。 部署流水线借助 Choerodon 平台，用户可以方便地管理各种使用 Choerodon 开发部署的应用服务，包括应用启停、状态监控，以及应用对应的版本控制、容器管理等，同时还包括应用涉及到的各种资源管理，例如网络、域名、数据库服务、缓存服务等。 "},"/docs/user-guide/deploy/Application deployment":{"url":"docs/user-guide/deploy/Application deployment","title":"应用部署","description":"","body":"应用部署 提供可视化、一键式部署应用，支持并行部署和流水线无缝集成，实现部署环境标准化和部署过程自动化。 菜单层次：项目层 菜单路径：持续交付 > 部署管理 > 应用部署 默认角色：项目所有者、项目成员、部署管理员 项目所有者和项目成员对应用部署只有查看界面的权限，不可进行编辑修改。 部署应用 部署应用是将一个版本的应用部署至指定环境的操作，提供可视化、一键式部署应用，支持并行部署和流水线无缝集成，实现部署环境标准化和部署过程自动化。 操作流程 使用部署管理员角色，选择前期所创建的项目应用； 选择版本；（前期创建的应用版本） 选择环境；（若所选的环境为故障中，则不能完成部署应用操作） 确认配置信息； 选择部署模式；（部署模式有创建实例和替换实例两种） 点击 部署应用 按钮，完成部署。 部署模式 创建实例：建立新的实例。 替换实例：滚动更新实例。 应用实例 通过容器状态、实例、应用版本、环境的信息来观察应用的部署情况。分为四种视图，里面有实例状态、运行详情和部署详情。 四种分视图： 部署实例 通过容器状态、实例、应用版本、环境来观察部署的情况。 列表字段： a. 容器状态：容器当前的状态。数字代表已运行的容器数量，当数字为“0”时，容器状态为空；绿色代表已通过健康检查，红色代表未通过健康检查。颜色会根据容器数量的状态发生比例变化。例如：容器数量为2，一个通过健康检查，一个未通过健康检查，则颜色状态为一半红色，一半绿色。 b. 实例状态：在不同的操作类型中的实例状态不同。 c. 实例名称：实例的名称。 d. 应用：应用的名称及其版本号。 e. 环境：环境的名称和环境编码。 f. 点击页面右侧 按钮 ，再点击查看实例详情，进入实例详情后观察其运行详情和部署详情。 单环境 通过搜索单个环境名称来观察该环境应用中所部署的情况。 可查询字段： a. 环境名称：对环境进行选择。 b. 应用：选择相应环境下的应用。可以在环境中点击 按钮，对当前进行快速部署。 列表字段： a. 容器状态：容器当前的状态。(所代表含义与部署实例视图中容器状态相同) b. 实例状态：在不同的操作类型中的实例状态不同。 c. 实例名称：实例的名称。 d. 应用版本：应用的版本。 e. 点击页面右侧 按钮 ，再点击查看实例详情，进入实例详情后观察其运行详情和部署详情。 单应用 观察单个应用在不同环境下的部署情况。 可查询字段： a. 应用名称：选择应用的名称确定应用。 b. 应用版本：选择应用版本。 c. 环境：环境的状态和名称。可以在环境中点击 按钮，对当前进行快速部署。 列表字段： a. 容器状态：容器当前的状态。(所代表含义与部署实例视图中容器状态相同) b. 实例状态：在不同的操作类型中的实例状态不同。 c. 实例名称：实例的名称。 e. 点击页面右侧 按钮 ，再点击查看实例详情，进入实例详情后观察其运行详情和部署详情。 多应用 观察所有应用在不同环境下的部署情况，这里对实例详情不可查看。 列表字段： a. 应用：应用的名称。 b. 最新版本：最新的版本号。 实例状态 不同的实例状态，可以执行的操作不同。 实例状态 可执行操作 处理中 查看实例详情 运行中 查看实例详情，修改配置信息，停止实例，删除实例 失败 查看实例详情，修改配置信息，删除实例 已停止 查看实例详情，修改配置信息，重启实例，删除实例 已删除 界面不显示 运行详情 Chart 里定义的各个资源对象列表及参数信息。 资源对象 参数信息 Pod (环境) name，ready，status，restarts，age Deployment (部署) name，desired，current，uo-to-date，available，age Replicaset (副本集) name，desired，current ready，age Service （网络） name，type，cluster-ip，external-ip，port，age Ingress （域名） name，hosts，address，ports，age 部署详情 包括报错信息、配置信息、阶段及日志。 修改配置信息 点击页面右侧 按钮 ，再点击修改配置信息，进入修改配置信息界面后对实例配置信息进行修改后重新部署。 停止实例 点击页面右侧 按钮 ，再点击停止实例，该实例即为停止状态，且容器状态停止。容器状态为“0”时，实例存在。 停止实例后，停止实例按钮转变为重启实例按钮，点击重启实例按钮时，重启环境。 删除实例 点击页面右侧 按钮，再点击删除实例，该实例被删除。 "},"/docs/user-guide/deploy/Network management":{"url":"docs/user-guide/deploy/Network management","title":"网络管理","description":"","body":"网络管理 网络管理是指内部的负载均衡以及网络转发，会将网络流量定向转发到指定的单个或者多个实例容器组，您可以通过选择需要负载和代理的实例，系统会为这些实例生成对应的负载规则。应用可以访问的两个必要条件：网络注册、应用部署。 菜单层次：项目层 菜单路径：持续交付 > 部署管理 > 网络 默认角色：项目所有者、项目成员、部署管理员 项目所有者和项目成员对网络只有查看界面的权限，不可进行编辑修改。 创建网络 点击 创建网络 ； 选择环境，只可选择运行中的环境，故障中的环境不可选； 选择应用名称、版本及实例； 输入网络名称、外部IP及端口号； 外部IP为选填项，需要外部网络访问时填写。 点击 创建完成网络创建。 查看应用版本详情 进入持续交付后，点击网络管理 页签； 查看项目应用的网络配置信息。 修改网络信息 点击修改网络 → 对网络进行修改。 删除网络 点击删除网络 → 对网络进行修改。 若删除网络，该条数据将被永久删除，不可恢复! "},"/docs/user-guide/deploy/":{"url":"docs/user-guide/deploy/","title":"部署流水线","description":"","body":"介绍 部署流水线主要描述部署的环境、网络、域名、容器等，来告知用户如何部署和部署情况。 功能 环境流水线 是面向平台管理员、项目创建者和项目所有者根据不同用途配置相对应的环境信息。可以创建环境，删除环境，及对环境详情信息进行编辑修改。 应用部署 提供可视化、一键式部署应用，支持并行部署和流水线无缝集成，实现部署环境标准化和部署过程自动化。 网络管理 是指内部的负载均衡以及网络转发，会将网络流量定向转发到指定的单个或者多个实例容器组，您可以通过选择需要负载和代理的实例，系统会为这些实例生成对应的负载规则。 域名管理 可以将您已经预定义好的域名规则在平台中进行配置，使外部能够通过指定的域名访问到系统内部的实例和网络。 容器管理 便于您查看和管理系统中的容器化实例，可以实时查看相关 pod 的状态以确定应用是否正常运行，同时可以查看对应的 pod日志进行错误定位和状态监控。 "},"/docs/user-guide/deploy/container management":{"url":"docs/user-guide/deploy/container management","title":"容器管理","description":"","body":"容器管理 容器的含义为每个容器中都运行一个应用并为该应用提供完整的运行环境。 容器管理便于您查看和管理系统中的容器化实例，可以实时查看相关 Pod 的状态以确定应用是否正常运行，同时可以查看对应的 Pod 日志进行错误定位和状态监控。 菜单层次：项目层 菜单路径：持续交付 > 部署管理 > 容器 默认角色：项目所有者、项目成员、部署管理员 查看容器管理详情 进入容器界面，通过列表信息观察应用状态、可用情况、创建时间； 点击容器日志→ 查看容器日志。 列表信息 状态：容器的状态分为以下五种，分别为 Pending、Running、Succeeded、Failed 和 Unknown。 1）Pending：Kubernetes 已经开始创建容器，但是容器中的一个或多个容器还没有被启动。比如容器正处在应该被分配到哪个节点上这个调度过程中，或者 Kubernetes 还在从镜像仓库中下载容器中容器镜像这个下载过程中。 2）Running：Kubernetes 已经将容器分配到节点上，并且容器中的所有容器都启动了。还包括容器中至少有一个容器仍然在运行状态，或者正在重新启动状态。 3）Succeeded：容器中的所有容器都处在终止状态，并且这些容器是自主正常退出到终止状态的，也就是退出代码为0，而且 Kubernetes 也没有重启任何容器。 4）Failed：容器中的所有容器都处在终止状态，并且至少有一个容器不是正常终止的，也就是退出代码不为0，或者是由于系统强行终止的。 5）Unknown：由于一些特殊情况无法获取容器状态，比如由于网络原因无法同容器所在的主机通讯。 容器名称：容器的名称。 应用：容器中的应用。 容器地址：容器的地址。 已创建：容器创建的时间。 "},"/docs/user-guide/deploy/domain name":{"url":"docs/user-guide/deploy/domain name","title":"域名管理","description":"","body":"域名管理 域名管理可以将您已经预定义好的域名规则在平台中进行配置，使外部能够通过指定的域名访问到系统内部的实例和网络。 目前Web前端需配置域名，若不配置域名，不能进行外网访问该前端，只能查看系统提供的 Pod IP。 菜单层次：项目层 菜单路径：持续交付> 部署管理 > 域名 默认角色：项目所有者、项目成员、部署管理员 项目所有者和项目成员对域名只有查看界面的权限，不可进行编辑修改。 创建域名 点击 创建域名 ，选择需要配置域名的应用，并输入域名、域名地址、路径及选择网络，点击 创建 ； 创建成功后，域名将会出现在域名管理列表中。 编辑域名信息 点击页面右侧 按钮，进入修改域名界面后 对域名信息进行修改 最后保存。 删除域名 点击页面右侧 按钮，删除该域名。 若删除域名，该条数据将被永久删除，不可恢复! "},"/docs/user-guide/deploy/environment":{"url":"docs/user-guide/deploy/environment","title":"环境流水线","description":"","body":"环境流水线 环境是指一个应用可以被部署的地方。常见环境有开发测试环境、预生产环境、生产环境等。Choerodon 自动为您的项目生成一条环境流水线，用户可以根据需要调整顺序环境的顺序，通过环境流水线，用户可以清晰地定义和查看应用部署的顺序。 菜单层次：项目层 菜单路径：持续交付 > 部署管理 > 环境流水线 默认角色：项目所有者、项目成员、部署管理员 项目所有者和项目成员对环境流水线只有查看界面的权限，不可进行编辑修改。 创建环境 点击 创建 按钮； 输入 “环境编码” 、 “环境名称” 以及 “环境描述” ，点击 创建 按钮； 新环境默认新增在环境流水线的最后一个节点。 创建的环境可以任意拖拽，调换环境之间的位置。 查看环境流水线详情 进入持续交付后，点击 环境流水线 页签； 查看应用环境的运行情况。 在环境卡片中，点击复制指令→ ，复制代码至Kubernetes运行，与平台建立链接。 在环境卡片中，点击修改环境→ ，修改环境名称及描述。 在环境卡片中，点击禁用环境→ ，当点击确认后，该环境将被禁用。 环境停用区 可在环境停用区查看已被停用的环境，点击卡片右上角启用按钮 → 重新启用。 "},"/docs/user-guide/operating-manage/":{"url":"docs/user-guide/operating-manage/","title":"运营管理","description":"","body":"介绍 本节介绍系统监控组件 功能 系统指标 介绍系统各个部分的仪表盘界面监控数据。 "},"/docs/user-guide/operating-manage/application-monitoring/":{"url":"docs/user-guide/operating-manage/application-monitoring/","title":"应用监控","description":"","body":""},"/docs/user-guide/operating-manage/application-monitoring/elasticsearch":{"url":"docs/user-guide/operating-manage/application-monitoring/elasticsearch","title":"Elasicsearch监控","description":"","body":"Elasicsearch监控 操作指南 左上角 node 菜单可切换监控的节点 。如下图所示: 监控指标 堆栈监控: HEAP USED 用折线图显示堆栈已用的百分比。 GC监控: GC COUNT 统计节点进行内存回收的次数。 等待中任务监控: Pending task number 用折线图表示等待的任务数量。 任务最大等待时间: Max task wait time 表示任务的最大等待时间的折线图。 磁盘监控: Disk io bytes 表示实时的磁盘读写数据大小， Disk io operations 表示实时磁盘读写操作次数。 "},"/docs/user-guide/operating-manage/application-monitoring/kafka":{"url":"docs/user-guide/operating-manage/application-monitoring/kafka","title":"Kafka监控","description":"","body":"Kafka监控 操作指南 左上角 topic 菜单可切换监控的话题， consumergroup 菜单可切换消费组 。如下图所示： 监控指标 offset监控: offset增长速度 显示当前所选topic中消息增长速度。 消费延迟监控: 消费组延迟 显示订阅当前topic的消费组的消费进度，以延迟形式表示。 topic监控: topic消费总数 显示所选topic中全部消息数量（包括已清除的历史消息），topic分区数 显示选中topic中的分区数量，现存消息总量 显示所选topic中现存消息数量（不包括已清除的消息） 消费速率监控: 消费速率 显示所选消费组对当前topic的消费速度。 分区监控: 分区主节点ID 显示选定topic中每个分区的主节点id，分区ISR数量 显示每个分区的可用副本数量。 "},"/docs/user-guide/operating-manage/application-monitoring/kibana":{"url":"docs/user-guide/operating-manage/application-monitoring/kibana","title":"kibana监控","description":"","body":"Kibana基础入门 前言 Kibana是一个开源的分析与可视化平台，设计出来用于和Elasticsearch一起使用的。你可以用kibana搜索、查看、交互存放在Elasticsearch索引里的数据，使用各种不同的图表、表格、地图等kibana能够很轻易地展示高级数据分析与可视化。 演示 上图中，提示你所拥有的索引，并要求你编写一个对应的模式，我们需要手动配置。在 Index Pattern 下边的输入框中输入 access-*(Elasticsearch中存在的一个索引开头)，它是 Elasticsearch 中的一个索引名称开头。 Kibana 会自动检测在 Elasticsearch 中是否存在该索引名称，如果有，则下边出现 Create 按钮，我们点击进行创建并来到如下界面： Discovery 在Discovery 菜单界面中，通过查询语句，过滤结果，即可查看文档数据，可以看到相关的统计情况比如文档总数，字段总数，并通过可视化查看。 点击左侧 Discovery 菜单，来到如下界面： 点击标签，可以筛选数据的值。 不了解查询条件如何使用，点击 Uses lucene query syntax可以到语法页面，可参考使用。 Visualize Visualize 菜单界面主要用于将查询出的数据进行可视化展示，且可以将其保存或加载合并到 Dashboard 中。 点击左侧 Visualize 菜单，再点击界面中间的 Create a visualization 按钮： 本次测试选择柱状图演示，点击柱状图 点击右上角Save 按钮可以进行保存。笔者将该可视化保存为 “test-Visualize”。 Dashboard 在Dashboard 菜单界面中，可以组合在Visualize菜单中保存的可视化数据，并对其进行排列。 点击左侧 Dashboard 菜单，再点击界面中间的 Create a dashboard 按钮进行创建： Timelion Timelion 是一个时间序列数据的可视化，可以结合在一个单一的可视化完全独立的数据源。它是由一个简单的表达式语言驱动的，用来检索时间序列数据，进行计算，找出复杂的问题的答案，并可视化的结果。 Dev Tools Dev Tools 菜单界面使用户方便的通过浏览器直接与 Elasticsearch 进行交互，发送请求即可操作Elasticsearch中的数据 参考资料 https://www.elastic.co/guide/en/kibana/current/getting-started.html "},"/docs/user-guide/operating-manage/application-monitoring/mysql":{"url":"docs/user-guide/operating-manage/application-monitoring/mysql","title":"MySQL监控","description":"","body":"MySQL监控 操作指南 左上角 Interval 菜单可切换监控频率， host 菜单可切换主机地址 。如下图所示： 监控指标 运行时长: MySQL Uptime MySQL服务器自从上次重启运行到现在的时长。 每秒查询速率: Current QPS 根据使用MySQL的SHOW STATUS命令查询到的结果，它是服务器在最后一秒内执行的语句数量。这个变量包含在存储程序中执行的语句，与Questions变量不同。 InnoDB缓冲池: InnoDB Buffer Pool Size InnoDB维护一个称为缓冲池的存储区域，用于在内存中缓存数据和索引。了解InnoDB缓冲池如何工作，并利用它来将频繁访问的数据保存在内存中，这是MySQL调优最重要的方面之一。目标是将工作集保存在内存中。在大多数情况下，这个值应该处于主机上60％-90％的可用内存之间。 MySQL连接数: MySQL Connections 是自服务器启动以来同时使用的最大连接数。 客户端活动线程数: MySQL Client Thread Activity 未休眠线程数。 服务器执行的语句数: MySQL Questions 与QPS计算中使用的查询不同，只包括客户端发送到服务器的语句，而不包括存储程序中执行的语句。 线程缓存: MySQL Thread Cache 当客户端断开连接时，如果缓存未满，客户端的线程将被放入缓存中。 排序使用情况: MySQL Sorts 显示当前排序功能的使用情况。 慢查询使用情况: MySQL Slow Queries 显示当前慢查询功能的使用情况。 终止的连接数: MySQL Aborted Connections 当一个给定的主机连接到MySQL并且连接在中间被中断（例如由于凭证错误）时，MySQL会将该信息保存在系统表中。 表级锁使用情况: MySQL Table Locks MySQL因各种原因需要多个不同的锁。在这个图表中，我们看到MySQL从存储引擎请求了多少个表级锁。 网络流量: MySQL Network Traffic 在这里我们可以看到MySQL产生了多少网络流量。出站是从MySQL发送的网络流量，入站是MySQL收到的网络流量。 每小时网络流量: MySQL Network Usage Hourly 这里我们可以看到每小时MySQL产生多少网络流量。您可以使用条形图来比较MySQL发送的数据和MySQL收到的数据。 内存概述: MySQL Network Usage Hourly 数据库使用的内存情况。 表状态: MySQL Table Open Cache Status 正在打开的表的缓存大小。MySQL Open Tables 打开的表的数量。 MySQL Table Definition Cache 表定义缓存。 "},"/docs/user-guide/operating-manage/application-monitoring/zipkin":{"url":"docs/user-guide/operating-manage/application-monitoring/zipkin","title":"调用链监控","description":"","body":"zipkin操作指南 概念 Span:基本工作单元，一次链路调用(可以是RPC，DB等没有特定的限制)创建一个span，通过一个64位ID标识它， span通过还有其他的数据，例如描述信息，时间戳，key-value对的(Annotation)tag信息，parent-id等 其中parent-id 可以表示span调用链路来源，通俗的理解span就是一次请求信息 Trace:类似于树结构的Span集合，表示一条调用链路，存在唯一标识 Annotation: 注解 用来记录请求特定事件相关信息(例如时间)，通常包含四个注解信息 cs - Client Start 表示客户端发起请求 sr - Server Receive 表示服务端收到请求 ss - Server Send 表示服务端完成处理，并将结果发送给客户端 cr - Client Received 表示客户端获取到服务端返回信息 BinaryAnnotation:提供一些额外信息，一般已key-value对出现 页面介绍 上图是zipkin的筛选菜单 有以下几个过滤维度： 1，服务名 2，url 3 时间区间 start time - end time 4 Duration 只显示时长大于所填值的trace 5 条数限制 只显示当前排序规则下前N条数据 点击Find Traces按钮，将依据指定的过滤规则，过滤出结果; 使用Sort可以改变排序规则。有六种排序规则 点击JSON按钮，可以切换图标形式和Json形式 点击Find Traces按钮，列出了适合条件的trace标签。 详细介绍 点击某一trace，即可进入该trace的详细页面，可以看出调用链中的span顺序，每个span标注其所消耗的时间 点击每个span，可以看出其详细的API调用顺序，通过对sr ss cs cr时间的计算，可以得出每个调用的详细延迟，从而对调用链进行相应的分析。 "},"/docs/user-guide/operating-manage/basic-monitoring/":{"url":"docs/user-guide/operating-manage/basic-monitoring/","title":"服务指标","description":"","body":"服务指标 介绍 使用prometheus进行指标采集，然后使用grafana进行数据图形化展示。 grafana是基于JS开发的，功能齐全的度量仪表盘，可以对接多数据源，实现图形化实时监控。 模块 节点监控 显示 kubernetes 集群中的节点指标。 节点概述监控 显示 kubernetes 集群中的节点指标。 使用简介 登录后点击看板切换菜单即可切换监控模块。 菜单中 node 为节点监控模块 All Node 为节点概述监控模块 "},"/docs/user-guide/operating-manage/basic-monitoring/allnode":{"url":"docs/user-guide/operating-manage/basic-monitoring/allnode","title":"节点概述监控","description":"","body":"节点概述监控 操作指南 左上角 cluster 菜单可切换集群， node 菜单可切换要显示的节点（可以全选或选择指定节点），nic 菜单可以切换选中节点中的网卡，指定要监控那个网卡 。如下图所示： 监控指标 内存指标: (NodeName) Memory Used 表示节点内存使用量，展示了已用（绿色）和总共（黄色）两条指标。黄色线条表示总内存，绿色线条表示已用。 cpu指标: (NodeName) cpu 表示节点cpu使用百分比，展示了已用（绿色）和总共（黄色）两条指标。多核时总指标会大于100%（四核即为400%）。 网络指标: (NodeName) Network 表示节点指定网卡的用量，展示接收（绿色）、发送（黄色）两端的数据。 文件系统指标: (NodeName) FileSystem Used 表示节点磁盘用量。 交换区指标: (NodeName) Swap Used 表示节点内存交换区用量。 "},"/docs/user-guide/operating-manage/basic-monitoring/node":{"url":"docs/user-guide/operating-manage/basic-monitoring/node","title":"节点监控","description":"","body":"节点监控 操作指南 左上角 cluster 菜单可切换集群， node 菜单可切换集群中的节点 。如下图所示： 监控指标 内存指标: Memory Used 显示已用内存，Memory 显示节点机器总内存数。 CPU指标: CPU Used 显示已用CPU（每个核心），CPU CORES 显示节点机器CPU核心数。 内存交换指标: Swap Used 显示已用内存交换空间，Swap 显示内存交换区总大小。 硬盘指标: Disk on '/' Used 显示 '/' 路径下硬盘占用，File System 显示文件系统大小。 CPU占用折线图: (NodeName) cpu 使用折线图展示所选节点不同时间的cpu占用率。 Pod CPU使用折线图: Pod Cpu 使用折线图展示节点上运行的pod的cpu负载折线图。使用不同显色表示不同Pod。 Pod内存占用折线图: Pod Memory Percentage 使用折线图展示节点上运行的Pod的内存占用，以相对于节点内存的百分比形式展示。使用不同显色表示不同Pod。 Pod内存用量折线图: Pod Memory 使用折线图展示节点上运行的Pod使用了多少内存。使用不同显色表示不同Pod。 节点网络使用情况折线图: Node Network 使用折线图展示节点收发两端的带宽占用。绿色线条代表接收，黄色线条代表发出。 Pod网络用量折线图: Pod Network Receive 代表节点上不同Pod使用的下行带宽，Pod Network Trasmit 代表节点上不同Pod使用的上行带宽。使用不同显色表示不同Pod。 "},"/docs/user-guide/operating-manage/newTemplate/":{"url":"docs/user-guide/operating-manage/newTemplate/","title":"新建监控","description":"","body":"功能 使用grafana作为可视化工具，创建编排数据监控模块。 创建dashboard 使用管理员账号登录。 打开看板选择菜单，点击New Dashboard按钮以打开看板编辑页面。 在控件列表中选择所需的控件类型，添加新的控件，点击ADD ROW按钮以新建一行。 可以自由拖动控件以编排看板为所需的样式。 点击并命名保存看板。 编辑变量 点击->template打开变量编辑页面。 点击New按钮新建变量，打开表单。 完成表单内容 　　　　 Variable Name —— 变量名 Type —— 变量类型 　不同类型下的表单内容不同，这里以Query类型为例 　　 　 Query Options Data source —— 数据源，变量值范围的数据来源 Refresh —— 刷新频率 Query —— 对应数据源的查询，其返回的值集合即为变量值范围 创建新控件 点击 -> add panel 图标，打开控件选择列表，选择以添加控件。 点击控件->edit打开编辑页面， 　　　 General Title —— 控件标题 　　　 Metrics Data source —— 数据源选择 编辑Query栏以编辑查询语句，点击Add Query新建查询。 其余还有一些改变尺寸，增加报警的选项。 "},"/docs/user-guide/scrum/":{"url":"docs/user-guide/scrum/","title":"敏捷管理","description":"","body":"敏捷管理 介绍 敏捷管理服务简单说就是灵活+快速，既满足产品开发过程中需求的动态变化，又能通过短迭代管理监控项目的实时效果。敏捷管理方法充分考虑到了可能出现的不确定性因素，同时具有鲜明的创造性。它的结构是围绕着学习过程建立的，这样一来，团队既可以评估已经取得的成果，同样重要的是，也可以评估取得这些成果的方法。这种架构能够为团队提供更加高效的工作方式，帮助他们更好地自我组织，提高工作速度，改进工作质量。 功能 集成Gitlab，实现 用户故事、任务、漏洞、冲刺 等卡片的创建、更新、删除、查询。 项目创建后默认创建空白看板，可根据项目的需要选择合适的看板模板，用户也可自定义绘制看板。支持 看板 内卡片的拖动以及状态的实时更新。 根据项目的需求可创建冲刺，用户故事来源于故事地图里的发布计划。 用户可同时开启一个冲刺，对应的卡片会同步到看板中，实现冲刺与看板一对一的关系。 关闭冲刺后将当前看板保存为历史看板，以及将未完成的用户故事退回到故事地图中，同时将其下的任务、缺陷删除。 实现用户故事、任务、缺陷的全局查询，以及快捷方式创建、修改、删除。 集成文件服务、minio等对项目附件集中存储，提供附件的上传、下载、删除功能。 "},"/docs/user-guide/scrum/board":{"url":"docs/user-guide/scrum/board","title":"看板","description":"","body":"看板 开启冲刺之后才能使用看板的全部功能。看板可以取代物理看板，也可以可视化您的工作流，同时后台会记录所以操作的时间数据，帮您完成数据分析和记录工作。 菜单层次：项目层。 菜单路径：敏捷管理 > 看板。 默认角色：看板项目所有者、看板项目成员 选择模板 进入看板之后，先根据您的需要，选择一个看板模板，单击某个模板，可查看详情，双击就会为您选择当前模板并打开，看板界面没有卡片时，您也可以更换模板。 开启冲刺后看板展示 进入看板之后，您在当前开启的冲刺中添加的故事，会自动为您导入到当前看板，并放在SprintBacklog里面（第一列） 创建卡片 点击创建卡片→ ，出现卡片详情编辑的窗口，选择卡片类型，故事，任务，缺陷，可创建对应类型的卡片，创建的卡片会同步到故事地图界面，放在当前发布计划的第一个角色的第一个任务列里。 看板绘制 点击看板绘制→ 进入看板编辑界面： 1)增加列 2)绘制泳道 3)增加/减少列高 4)撤销/恢复 5)保存 6)在制品和起始列设置 拖动故事卡 点击故事卡，可按需在子卡处拖动任务卡或bug卡至看板对应位置。 "},"/docs/user-guide/scrum/bug":{"url":"docs/user-guide/scrum/bug","title":"漏洞","description":"","body":"漏洞 可以查看您创建的所有漏洞。 菜单层次：项目层 菜单路径：敏捷管理 > 漏洞 默认角色：看板项目所有者、看板项目成员 查看缺陷 在任务界面，您可以查看您所有创建的缺陷，并且可以高级搜索您要找的缺陷。 删除缺陷 可以在中完成删除缺陷。 "},"/docs/user-guide/scrum/sprint":{"url":"docs/user-guide/scrum/sprint","title":"冲刺","description":"","body":"冲刺 在冲刺中，可方便为您管理一个迭代周期内要完成的故事，并为您进行后台数据监测，可视化故事完成的情况，冲刺作为用户故事地图和看板的衔接环节，开启冲刺之后才能使用看板的全部功能。 菜单层次：项目层 菜单路径：敏捷管理 > 冲刺 默认角色：看板项目所有者、看板项目成员 创建冲刺 点击`创建冲刺，选择发布计划，输入冲刺名称，选择预计的冲刺起止时间(不必输)，即可创建一个新的冲刺。 搜索冲刺 可以在工具栏进行搜索。 开启/关闭冲刺 可以快捷开启或者关闭冲刺，完成状态切换。 点击开启冲刺可开启当前冲刺，开启之后，数据洞察就开始记录当前冲刺的数据。冲刺内添加的故事也会自动导入看板中，并放在第一列。 点击关闭冲刺可关闭当前冲刺，关闭之后不能再开启。 编辑冲刺信息 可以修改冲刺的具体信息，如冲刺名称，开始和结束时间，但是发布计划不允许修改。 添加故事 选择故事来源，从故事地图，或者未规划的故事中，勾选需要导入的故事，点击确定，添加到冲刺中，添加进冲刺的故事，在故事地图界面的颜色会与没有导入冲刺的颜色有一个变化。 创建任务 可以创建进入到冲刺中的用户故事下的具体任务。 创建缺陷 可以创建用户故事下或者任务下测试出现的bug。 筛选故事 可以对故事，任务和缺陷进行分类筛选。 移除故事 可以把导入冲刺的故事移除，移除后不会在故事地图里面删除，只是故事地图中的卡片颜色会变为未导入状态。也可以导入到其他冲刺中。 "},"/docs/user-guide/scrum/story map":{"url":"docs/user-guide/scrum/story map","title":"故事地图","description":"","body":"故事地图 在开规划会议之前 用户可以按照角色，活动，任务分类来规划roadmap，整理用户故事，记录的用户故事将会被同步到gitlab的issue上，项目干系人可以在issue下放进行评论，对用户故事展开讨论。 菜单层次：项目层 菜单路径：敏捷管理 > 故事地图 默认角色：看板项目所有者、看板项目成员 使用故事地图 添加角色 角色：提出的用户需求是基于哪类角色考虑的。例如敏捷开发有三种角色，po，master和项目开发人员。 点击创建角色→ 按钮鼠标光标会变为加号，当出现加号图标时，用户在角色这一行任意位置单击，即可添加角色。 添加活动 活动:基于某一个角色下，具体的用户场景。 点击创建活动→ 鼠标光标会变为加号，当出现加号图标时，用户在活动这一行任意位置单击，即可添加活动。 添加任务 任务：用户场景的细化。 点击创建任务→ 鼠标光标会变为加号，当出现加号图标时，用户在任务这一行任意位置单击，即可添加任务。 创建发布计划 点击创建发布计划→ ，即可在用户故事地图上面生成对应的发布计划，依次默认命名为发布计划1、发布计划2等，如果想修改发布计划名称或者删除发布计划，点击发布计划名称旁边的三点符号，可进行修改或者删除。处于安全考虑，已经有用户故事的发布计划，需要先删除里面的用户故事，才能删除整个发布计划。 创建卡片 用户故事：具体的需求。 在故事地图界面移动鼠标，见到卡片创建的提示时，点击提示卡中间的文字部分，也可以创建相应的卡片，比如角色，活动，任务，用户故事。 修改与删除卡片 修改卡片直接单击卡片，弹出卡片详情信息时即可修改标题。 删除卡片需要在没有子卡的情况下才能删除，否则提示相应报错信息。 故事地图工具栏介绍 未规划区的使用 点击未规划区，会出现一个侧边栏，如下图所示，在侧边栏中会放入您在其他界面创建的不属于任何发布计划的故事，比如您在用户故事界面创建了一个未选择发布计划的用户故事，就会以一张故事卡的形式出现在此处，顶部的搜索和过滤可以进行高级搜索，找到您想要的卡片，您考虑好此故事放在哪个发布计划下比较合适时，也可以拖动到具体的发布计划下。 数据统计 此项目下的数据进度的分析，可一键从此入口进入，也可去数据洞察界面选择具体项目查看。 导出为图片 点击导出为图片→ ，即可把当前的地图以图片形式保存下来，导出格式为png。 放大缩小 点击放大缩小标志，或者拖动放大缩小的滚动条，都可完成整个地图的放大缩小。 "},"/docs/user-guide/scrum/task":{"url":"docs/user-guide/scrum/task","title":"任务","description":"","body":"任务 可以查看您创建的所有任务，可视化您的任务流，同时后台会记录所以操作的时间数据，帮您完成数据分析和记录工作。 菜单层次：项目层。 菜单路径：敏捷管理 > 任务。 默认角色：看板项目所有者、看板项目成员 查看任务 在任务界面，您可以查看您所有创建的任务，并且可以高级搜索您要找的任务。 删除任务 可以在中完成删除，快捷创建缺陷的快捷操作 "},"/docs/user-guide/scrum/user story":{"url":"docs/user-guide/scrum/user story","title":"用户故事","description":"","body":"用户故事 用户故事界面是用户故事的列表展现形式，在这里可以集中查看您创建的所有的用户故事，以及其下的任务缺陷等，方便快捷。 菜单层次：项目层 菜单路径：敏捷管理 > 用户故事 默认角色：看板项目所有者、看板项目成员 创建用户故事 点击创建故事→ ，出现详情信息编辑的窗口，在窗口中进行编辑，编辑完成之后点击保存。 搜索用户故事 点击过滤可以进行高级搜索 删除用户故事 未进入冲刺的用户故事可以删除。 快捷创建任务 可以快捷创建用户故事下面的任务。 快捷创建缺陷 可以快捷创建用户故事下面的缺陷。 "},"/docs/user-guide/system-configuration/":{"url":"docs/user-guide/system-configuration/","title":"系统配置","description":"","body":"介绍 本页面介绍了用户使用系统功能前需要进行的系统配置，以便不同用户可以进行敏捷管理、持续交付的操作。该系统配置基本由平台管理员、项目创建者、项目所有者等高权限角色完成。每个模块都包含其概念定义、主要功能及其他注意事项。 功能 平台设置 对平台的菜单、角色、组织、平台角色进行设置，改设置的层级属于全局层。 租户设置 在一台服务器上运行单个应用实例，它为多个租户提供服务及管理。 项目设置 对项目进行管理，主要有项目信息的创建和项目角色分配。 个人中心 个人中心是用户管理个人设置的模块。 通用功能 是平台提供的基础功能，包括登录、登出、多租户切换。 "},"/docs/user-guide/system-configuration/common/":{"url":"docs/user-guide/system-configuration/common/","title":"通用功能","description":"","body":"通用功能 介绍 通用功能是平台提供的基础功能，包括登录、登出、多租户切换。 功能 登录 用户能使用登录名密码或邮箱密码登录平台。用户必须属于一个组织，如果用户为LDAP用户，则只能使用该组织所用的LDAP服务器中的登录信息进行登录。 登出 用户能退出登录。 多租户切换 用户能够进入被分配过角色的组织或项目。角色是权限的集合，在组织或项目给用户分配角色，用户则被赋予了访问权限。 "},"/docs/user-guide/system-configuration/common/common1_login":{"url":"docs/user-guide/system-configuration/common/common1_login","title":"登录","body":"登录 用户能登录平台。目前有登录名密码登录、邮箱密码登录这两种登录方式。 层级： 通用功能 LDAP用户的登录 LDAP用户的登录账户和密码从该用户所属的组织下配置的LDAP服务器进行获取。LDAP用户登录时，登录认证请求会转发到LDAP服务器进行校验。 登录名登录 用户的登录名在平台是唯一的。您能使用您的登录名进行登录。 邮箱登录 用户的邮箱在平台是唯一的。您能使用您的邮箱进行登录。 密码 如果您所属的组织启用了登录安全策略，您在使用密码认证登录时，将被此登录安全策略保护。 如果登录安全策略中开启了验证码，您的密码在输错一定次数后，将进行验证码验证。 如果登录安全策略中开启了锁定，您的密码在输错一定次数后，将锁定您的账户，在一定时间内无法登录平台。 "},"/docs/user-guide/system-configuration/common/common2_logout":{"url":"docs/user-guide/system-configuration/common/common2_logout","title":"登出","body":"登出 用户能退出登录。退出登录后，用户的访问信息不清除。再次登录时将访问您上一次访问的组织或项目。 层级： 通用功能 登出平台 点击导航栏您的用户头像 点击退出登录按钮，退出平台 "},"/docs/user-guide/system-configuration/common/common3_tenant_switch":{"url":"docs/user-guide/system-configuration/common/common3_tenant_switch","title":"组织项目切换","body":"组织项目切换 用户可以在导航栏选择组织或项目，并进入到某个组织或项目中进行操作。 层级： 通用功能 选择组织 您可以选择您被分配了角色的组织。如果您要进入某个组织，在组织选择框进行选择，在表格中双击该组织或选中该组织后点击打开按钮，可进入该组织。 选择项目 您可以选择您被分配了角色的项目。如果您要进入某个项目，在组织框中选择该项目的所属组织，在表格中双击该项目或选中该项目后点击打开按钮，可进入该项目。 搜索组织或项目 您可以输入组织或项目的名称或编码进行模糊搜索。 最近访问记录 平台会保存您的最近访问组织或项目的记录。最多可保存进10次访问记录。您可以切换到最近快速进入某个组织或项目。 "},"/docs/user-guide/system-configuration/person/":{"url":"docs/user-guide/system-configuration/person/","title":"个人中心","description":"","body":"个人中心 介绍 个人中心是用户管理个人设置的模块。在个人中心中，您可以管理您的个人信息，包括头像、用户名、邮箱，修改您的个性化设置，包括语言、时区，修改您的平台密码，查看您的组织信息、项目信息，管理授权。 在界面的“右上角圆形图标”进入个人中心界面。 功能 个人信息 用户个人信息的管理。 修改密码 非LDAP用户可以修改自己的登录密码。 "},"/docs/user-guide/system-configuration/person/information":{"url":"docs/user-guide/system-configuration/person/information","title":"个人信息","description":"","body":"个人信息 个人信息用于让用户管理自己的信息，包括头像、用户名、邮箱、语言、时区。 菜单层次：个人中心 菜单路径：个人中心 > 个人信息 默认角色：登录即可访问 修改个人信息 1.进入“个人中心”界面后，点击个人信息修改个人信息； 2.输入用户名、邮箱、语言、时区； 可修改字段： 用户名：用户的别称。 邮箱：填写真实正确的邮箱，可用于登录平台、密码找回。 语言：系统界面显示的语言。 时区：系统所有与时间有关的操作根据选择的时区进行转换。 3.点击保存完成个人信息的修改。 由于登录名是用户的标识，不可以修改登录名。 "},"/docs/user-guide/system-configuration/person/pro_info":{"url":"docs/user-guide/system-configuration/person/pro_info","title":"项目信息","body":"项目信息 用户可以在不同的项目中被分配角色。项目信息展示给该用户分配过角色的项目和用户在该项目下的角色。 项目信息列表 用户可以在不同的项目中被分配角色。折叠列表的一级分类为项目。每一行项目展开后为用户在该项目下的所有角色。 列表字段： 项目/角色：显示项目名称或角色名称。 编码：但为项目时，显示项目编码；当为角色时，显示角色编码。 类型：为项目或角色。 项目信息查询 可查询字段： 项目名称：可以根据项目名称查询项目。 项目编码：可以根据项目编码查询项目。 角色名称：可以根据角色名称查询用户所有项目层角色，即使为在不同项目的角色。 角色编码：可以根据角色编码查询用户所有项目层角色，即使为在不同项目的角色。 "},"/docs/user-guide/system-configuration/person/secret_change":{"url":"docs/user-guide/system-configuration/person/secret_change","title":"修改密码","body":"修改密码 非LDAP用户可以修改自己的登录密码。LDAP用户的密码从外部系统获取，所以无修改密码的功能。 菜单层次：个人中心 菜单路径：个人中心 > 修改密码 默认角色：登录即可访问 修改密码 1.进入“个人中心”界面后，点击修改密码； 2.输入原密码、新密码、确认密码； 可修改字段： 原密码：原密码须正确，否则无法修改密码。 新密码：如果密码策略的密码安全策略被启用，则新密码需符合密码安全策略。 确认密码：须与新密码输入一致。 3.点击保存完成密码的修改。 "},"/docs/user-guide/system-configuration/platform/":{"url":"docs/user-guide/system-configuration/platform/","title":"平台设置","description":"","body":"介绍 本页面介绍了用户使用系统功能前需要进行的平台配置，该系统配置基本由平台管理员、项目创建者、项目所有者等高权限角色完成。 在全局层界面中，点击管理按钮→ 进入平台设置界面。 功能 菜单管理 用于配置平台菜单。 角色管理 角色是一组特定权限的集合，通过给成员分配角色来赋予成员权限。 平台角色分配 对平台的角色进行分配。 "},"/docs/user-guide/system-configuration/platform/menu_configuration":{"url":"docs/user-guide/system-configuration/platform/menu_configuration","title":"菜单配置","body":"菜单配置 菜单配置用于配置平台菜单。 进入管理中心、某一个组织、某一个项目、个人中心都需要菜单进行功能导航。因此，菜单配置按层级划分为全局层、组织层、项目层、用户层，且某一层级下只能配置相同层级的菜单。 菜单层次：全局层 菜单路径：平台设置 > 菜单配置 默认角色：平台管理员 菜单配置列表 按菜单层级的方式查看菜单列表。一共分为 全局层、组织层、项目层、用户层，不同的层级对应不同的层级位置的菜单。 按全局层查看时，列表为用户在管理中心看到的菜单（默认该用户有全局层所有权限）； 按组织层查看时，列表为用户进入每一个组织看到的菜单（默认该用户有组织层所有权限）； 按项目层查看时，列表为用户进入每一个项目看到菜单（默认该用户有项目层所有权限）； 按用户层查看时，列表为用户进入到个人中心的菜单。 列表字段： 目录/菜单：目录、菜单的名称。预置目录、菜单的名称无法修改，自设目录的名称可修改。 图标：目录、菜单的图标。预置目录、菜单的图标无法修改，自设目录的图标可修改。 编码：目录、菜单的编码具有唯一性。 所属预置目录：只有菜单才有所属预置目录。 类型：分为目录和菜单两种，目录分为预置目录和自设目录两种。其中预置目录和菜单是系统定义的，用户无法修改，用户只能对自设目录进行创建、修改、删除。目录（包括预置目录和自设目录）和菜单为树型关系，菜单只能处于叶子位置，目录能处于根或分支的位置。预置目录和菜单的关系为从属关系，一个菜单必须属于一个预置目录，该关系为系统定义，用户无法修改。预置目录和自设目录为系统预定义目录和用户自定义目录的关系，预置目录无法创建、修改、删除，自设目录可以创建、修改、删除。 菜单详情 菜单是系统配置的，用户无法创建、修改菜单，只能查看菜单详情。 详情字段: 菜单名称：菜单的名称，根据菜单功能定义菜单名称。 菜单编码：菜单编码具有唯一性，是菜单的标识。 菜单层级：菜单有层级性，只能在相同的层级配置菜单。例如，在项目层只能配置菜单层级为项目层的菜单。 所属预置目录：一个菜单必须且只能属于一个预置目录。 菜单权限：要实现菜单里所有功能需要的权限。 创建自设目录 1.点击创建自设目录→创建一个自设目录； 2.输入目录名称、目录编码以及目录图表； 目录名称：用户可根据需要自定义名称。 目录编码：目录编码具有唯一性，是目录的标识。 目录图标：目录的图标可在系统提供的图标库中选择。 3.点击添加完成自设目录的创建。 修改自设目录 点击列表中编辑→ 进行自设目录的修改编辑。 目录编码具有唯一性，是目录的标识。所以目录一旦成功创建，不可修改。 可修改字段： 目录名称：用户可根据需要自定义名称。 目录编码：目录编码具有唯一性，是目录的标识。 目录图标：目录的图标可在系统提供的图标库中选择。 删除自设目录 点击列表中删除→，删除自设目录。 只有自设目录可删除，预置目录和菜单不可是系统定义的，无法删除。 如果目录下有菜单，则不可删除该目录；只有当目录下无菜单时，可删除该目录。例如，在一个目录A下有目录B，目录A可以被删除；在一个目录C下有目录D，目录D下有菜单1、菜单2，目录C、目录D不可被删除。 调整结构 将鼠标移至列表字段目录/菜单，会显示一个虚线框，该虚线框内则为鼠标长按拖动时可拖动的内容。如果一个目录下没有菜单，则不显示该目录。 如果鼠标悬停在目录上，虚线框内则为此目录和该目录下的所有目录/菜单，鼠标长按时可拖动此目录和该目录下的所有目录/菜单；若该目录下无目录/菜单，则虚线框内只有这个目录，鼠标长按时只可拖动这个目录。 如果鼠标悬停在菜单上，虚线框内只有这个菜单，鼠标长按只可拖动这个菜单。 "},"/docs/user-guide/system-configuration/platform/organization":{"url":"docs/user-guide/system-configuration/platform/organization","title":"组织管理","body":"组织管理 组织是项目的集合，组织管理是对组织信息和启用状态的管理。 组织下的项目、用户、客户端的管理需进入到一个特定的组织进行组织层的操作。一个项目只能属于一个组织，但一个组织下可以有多个项目。一个用户只能属于一个组织，但一个组织下可以有多个用户。 菜单层次：全局层 菜单路径：平台设置 > 组织管理 默认角色：平台管理员 组织列表 列表字段： 组织名称：组织的名称。 组织编码：组织编码具有唯一性，是组织的标识。 启用状态：启用状态有启用和停用两种。当启用状态为启用时，组织正常运行，可进入该组织中进行其他操作；当启用状态为停用时，无法进入该组织。一个新组织创建成功后，新组织的启用状态默认为启用。 组织查询 可查询字段： 组织名称：组织的名称。 组织编码：组织编码具有唯一性，是组织的标识。 启用状态：启用状态有启用和停用两种。当启用状态为启用时，组织正常运行，可进入该组织中进行其他操作；当启用状态为停用时，无法进入该组织。一个新组织创建成功后，新组织的启用状态默认为启用。 创建组织 1.点击创建组织→创建一个组织； 2.输入组织编码和组织名称； 组织名称：组织的名称。该字段是必输的。 组织编码：组织编码具有唯一性，是组织的标识。该字段是必输的 编码只能包含字母，数字，下划线，空格， '_' '.' \"——\" 只能以字母，数字，下划线开头 3.点击创建完成组织的创建。 编辑组织 点击列表中修改→进行组织信息的修改编辑。 组织创建成功后，组织编码不可更改。 可编辑字段： 组织名称：组织的名称。该字段是必输的 启用/停用组织 停用组织：点击列表中停用→，组织状态为停用状态。组织的启用状态为启用时，可进行停用组织的操作。停用组织后，组织的启用状态变为停用，不可进入该组织。 启用组织：点击列表中启用→，组织状态为启用状态。组织的启用状态为停用时，可进行启用组织的操作。启用组织后，组织的启用状态变为启用，可进入该组织进行组织的用户管理、项目管理等操作。 "},"/docs/user-guide/system-configuration/platform/role-assignment":{"url":"docs/user-guide/system-configuration/platform/role-assignment","title":"平台角色分配","body":"平台角色分配 平台角色分配时，可以给一到多个成员分配一到多个角色。角色是权限的集合，给成员分配角色即给成员赋予权限。权限与角色都具有层级性，且角色权限的层级必须与角色层级相同。角色分配具有层级性，角色分配中被分配的角色层级必须与角色分配的层级相同。即，在某一层级的角色分配中，只能给用户分配对应的层级的角色，只能给角色分配对应层级的权限。例如，在平台层角色分配中，只能给用户分配平全局层角色，分配后用户具有使用全局层权限。 菜单层次：全局层 菜单路径：平台设置 > 平台角色分配 默认角色：平台管理员 成员角色列表 列表查看方式： 按成员查看：列表项为成员信息和该成员的所有角色。可以直接对成员的角色进行更改操作。 按角色查看：列表项为角色。展开角色后，展示信息为角色下的成员信息。可以直接对角色下的成员进行更改操作。 列表字段-按成员查看时： 成员：若成员为用户，则为用户的登录名；若成员为微服务，则为微服务名称。 名称：若成员为用户，则为用户的用户名。 角色：角色名称。可以为一到多个。每一个角色都可以在列表中直接删除，或点击编辑，进入编辑成员角色的界面更改成员的角色。 成员类型：成员类型可以为用户、微服务。 列表字段-按角色查看时： 角色/成员：列表的列表项为角色名称。列表项展开后的子列表为角色下的成员 若成员为用户，则为用户的登录名；若成员为微服务，则为微服务名称。 名称：若子列表中的成员为用户，则名称为用户名。 成员角色查询 可查询字段: 成员：若成员为用户，按用户的登录名查找；若成员为微服务，按微服务名称查找。 名称：若成员为用户，按用户的用户名查找。 成员类型：分用户和微服务两种。 角色：按角色名称查找。 添加成员角色 1.点击添加→ 添加成员角色； 2.输入成员、选择一个角色； 添加新的成员角色之间的关联：如果成员已经被分配过角色，则将本次操作新增的与该成员有关的成员角色关联合并到已有关联列表，即已有的不变，新增的增加。 3.点击添加完成添加成员角色。 层级规则： 全局层角色分配的添加成员角色为，在平台中，给成员添加全局层的角色。例如，在Choerodon这个平台中，给登录名为123的用户添加管理员的角色，且管理员这个角色满足角色层级为全局层的条件。 对应规则： 成员输入一个到多个。如果成员为用户，则输入用户的登录名，若成员为应用，则输入应用名称。 角色选择一到多个。根据角色名称进行选择。可以对角色名称进行过滤。 移除成员角色 点击移除→ 移除成员角色； 可以进行批量删除，即可以一次性删除与某个成员或角色有关的所有成员角色关联。 按成员查看时：勾选一或多个成员，点击移除，批量删除所选成员和成员下所有角色的关联关系。 按角色查看时：勾选一或多个角色，点击移除，批量删除所选角色和角色下所有成员的关联关系。 删除成员角色 按成员查看时，点击删除→，可直接删除与该成员有关联的角色，即删除了一个成员角色关联。 按角色查看时，点击删除→，可直接删除与该角色有关联的成员，即删除了一个成员角色关联。 按成员或角色查看时，点击编辑图标，进入编辑成员的角色界面，点击删除→，可删除与成员有关联的一个角色。 修改成员的角色 点击编辑→，进入编辑一个成员的所有角色界面，可编辑该成员的角色关联。即可以删除角色，更改已有角色，添加其他角色。只有上一个角色已选时才可以继续添加其他角色。 "},"/docs/user-guide/system-configuration/platform/role":{"url":"docs/user-guide/system-configuration/platform/role","title":"角色管理","body":"角色管理 角色是一组特定权限的集合。因此，通过给成员分配角色来赋予成员权限。角色只有属于一个层级，给角色分配权限时只能分配相同层级的权限。在一个层级中给成员分配角色时，只能分配相同层级的角色。 菜单层次：全局层 菜单路径：平台设置 > 角色管理 默认角色：平台管理员 角色列表 列表字段： 角色名称：角色名称是根据角色权限的集合定义的。在角色分配中的角色列表里面显示的为角色名称。 角色编码：角色编码具有唯一性，是角色的标识。 角色层级:一个角色只能选择一个层级。一共有全局层、组织层、项目层三种层级可供选择。 角色来源：角色分为用户自定义角色和预置角色，所以角色来源有自定义和预定义两种。用户自定义角色是用户在角色管理界面所创建的角色。预置角色是系统内置的角色，只能查看预置角色，基于预置角色创建新的角色，不能编辑和停用预置角色。 启用状态：是否启用字段有'启用'和'停用'两种值。角色的是否启用字段的值为'启用'时，在角色分配中可以看到该角色，因而可以选择该角色；否则，为'停用'时，在角色分配中不可看到该角色，因而无法选择该角色。 角色查询 可查询字段： 角色名称：角色的名称。可以模糊搜索。 角色编码：角色的编码。是角色标识。可以模糊搜索。 角色层级：分全局层、组织层、项目层三种。 角色来源：分预定义和自定义两种。 启用状态：分启用和停用两种。 创建角色 1.点击创建角色→创建一个角色； 2.输入角色名称、角色层级、角色编码、角色标签以及角色权限； 必填字段： 角色名称：角色的名称应该根据角色权限集合特征定义。 角色层级：角色层级分为全局层、组织层、项目层三种。一个角色只能属于一个层级。 角色编码：角色编码具有唯一性，是角色的标识。用户可自定义。角色创建成功后生成的角色编码为role/层级/custom/用户自定义角色编码，其中role和custom为常量，role表示角色这个大类，custom表示角色来源为用户自定义，即用户在界面创建的角色；层级和用户自定义编码为变量，层级为用户所选的角色层级，用户自定义角色编码为用户在角色编码输入框中所填写的值。 角色权限：权限层级与角色层级相同。创建角色时，至少要选择一个角色权限。 选填字段： 角色标签：用于控制平台外部角色的权限。例如，在角色标签gitlab-master与Gitlab系统中的Master角色相关联，若角色A有角色标签gitlab-master 角色B有角色标签gitlab-master，则Gitlab系统中的Master角色就有角色A和B的所有权限。 3.点击创建完成角色的创建。 根据所选角色创建角色 1.点击列表中的图标→ ，选中基于该角色创建； 2.输入角色名称、角色层级、角色编码、角色标签以及角色权限； 可以选择多个角色，基于这些选择的角色创建一个新的角色。但是多选时，选择的角色只能为同一层级，不能为不同的层级。 不可填字段： 角色层级：新角色的层级与所选角色的层级相同，不可更改。 必填字段： 角色名称：角色的名称应该根据角色权限集合特征定义。 角色编码：角色编码具有唯一性，是角色的标识。用户可自定义。角色创建成功后生成的角色编码为role/层级/custom/用户自定义角色编码，其中role和custom为常量，role表示角色这个大类，custom表示角色来源为用户自定义，即用户在界面创建的角色；层级和用户自定义编码为变量，层级为用户所选的角色层级，用户自定义角色编码为用户在角色编码输入框中所填写的值。 角色权限：新角色的角色权限为所选角色权限的并集。可以后继删除或添加权限，至少要有一个角色权限。 选填字段： 角色标签：用于控制平台外部角色的权限。例如，在角色标签gitlab-master与Gitlab系统中的Master角色相关联，若角色A有角色标签gitlab-master 角色B有角色标签gitlab-master，则Gitlab系统中的Master角色就有角色A和B的所有权限。 3.点击创建完成角色的创建。 编辑角色 1.点击列表中的图标→ ，选中修改； 2.输入角色名称、角色层级、角色编码、角色标签以及角色权限； 预定义角色不可编辑，只能编辑用户自定义的角色。 不可编辑字段： 角色层级：因为权限的层级是根据角色层级而定的，如果角色层级更改，则与之前已选权限的角色层级不同，这与系统的角色-权限关联规则矛盾，所以角色一旦创建成功，角色层级不可更改。 角色编码：因为角色编码具有唯一性，是角色的标识，所以角色一旦创建成功，角色编码不可更改。 可编辑字段： 角色名称：应该根据角色的权限特性进行命名，这样分配角色的时候可以直观的选择角色。 角色标签：用于控制平台外部角色的权限。例如，在角色标签gitlab-master与Gitlab系统中的Master角色相关联，若角色A有角色标签gitlab-master 角色B有角色标签gitlab-master，则Gitlab系统中的Master角色就有角色A和B的所有权限。 角色权限：可以增加或删除角色的权限。 3.点击保存完成角色的创建。 启用/停用角色 点击列表中的图标→ ，选中停用； 预定义角色不可停用，只能启用/停用用户自定义角色。 停用角色：只能停用用户自定义角色。停用角色后，角色状态变为'未启用'。赋予给该角色的权限将失效，即使这个角色已经被分配给了用户。并在角色分配中，不再显示该角色。 启用角色：用户自定义角色被停用后，可以再次启用。启用角色后，角色状态变为'启用'。赋予该角色的权限生效。并在角色分配中，显示该角色。 "},"/docs/user-guide/system-configuration/project/":{"url":"docs/user-guide/system-configuration/project/","title":"项目设置","description":"","body":"介绍 本页面介绍了项目层的项目角色分配及项目信息的介绍。 在项目层界面中，进入“项目设置”界面。 功能 项目信息 进入一个项目后，可以修改项目信息和停用项目。 项目角色分配 对项目层角色的分配方法。 "},"/docs/user-guide/system-configuration/project/pro_info":{"url":"docs/user-guide/system-configuration/project/pro_info","title":"项目信息","body":"项目设置 进入一个项目后，可以修改项目信息和停用项目。 菜单层次：项目层 菜单路径：项目设置 > 项目信息 默认角色：项目所有者 修改项目信息 1.在项目信息界面输入 项目名修改项目信息； 2.点击保存，保存修改的设置。 可修改字段： 项目名称:可以对项目的名称进行修改。 项目编码是项目的标识，不可修改。 停用项目 点击停用→ 可以停用此项目。停用后，无法进入该项目。如果需要再次启用此项目，需要在项目管理中对该项目进行启用操作。 "},"/docs/user-guide/system-configuration/project/role-assignment":{"url":"docs/user-guide/system-configuration/project/role-assignment","title":"项目角色分配","body":"项目角色分配 项目角色分配时，可以给一到多个成员分配一到多个角色。角色是权限的集合，给成员分配角色即给成员赋予权限。权限与角色都具有层级性，且角色权限的层级必须与角色层级相同。角色分配具有层级性，角色分配中被分配的角色层级必须与角色分配的层级相同。即，在某一层级的角色分配中，只能给用户分配对应的层级的角色，只能给角色分配对应层级的权限。例如，在项目层角色分配中，只能给用户分配项目层角色，分配后用户具有使用项目层权限。 菜单层次：项目层 菜单路径：项目设置 > 项目角色分配 默认角色：项目所有者 成员角色列表 列表查看方式： 按成员查看：列表项为成员信息和该成员的所有角色。可以直接对成员的角色进行更改操作。 按角色查看：列表项为角色。展开角色后，展示信息为角色下的成员信息。可以直接对角色下的成员进行更改操作。 列表字段-按成员查看时： 成员：若成员为用户，则为用户的登录名；若成员为微服务，则为微服务名称。 名称：若成员为用户，则为用户的用户名。 角色：角色名称。可以为一到多个。每一个角色都可以在列表中直接删除，或点击编辑，进入编辑成员角色的界面更改成员的角色。 成员类型：成员类型可以为用户、微服务。 列表字段-按角色查看时： 角色/成员：列表的列表项为角色名称。列表项展开后的子列表为角色下的成员 若成员为用户，则为用户的登录名；若成员为微服务，则为微服务名称。 名称：若子列表中的成员为用户，则名称为用户名。 成员角色查询 可查询字段: 成员：若成员为用户，按用户的登录名查找；若成员为微服务，按微服务名称查找。 名称：若成员为用户，按用户的用户名查找。 成员类型：分用户和微服务两种。 角色：按角色名称查找。 添加成员角色 1.点击添加→ 添加成员角色； 2.输入成员、选择一个角色； 添加新的成员角色之间的关联：如果成员已经被分配过角色，则将本次操作新增的与该成员有关的成员角色关联合并到已有关联列表，即已有的不变，新增的增加。 3.点击添加完成添加成员角色。 层级规则： 项目层角色分配的添加成员角色为，在一个项目中，给成员添加组织层角色。例如，在Choerodon这个项目中，给登录名为123的用户添加项目管理员的角色，且项目管理员这个角色满足角色层级为项目层的条件。 对应规则： 成员输入一个到多个。如果成员为用户，则输入用户的登录名，若成员为应用，则输入应用名称。 角色选择一到多个。根据角色名称进行选择。可以对角色名称进行过滤。 移除成员角色 可以进行批量删除，即可以一次性删除与某个成员或角色有关的所有成员角色关联。 按成员查看时：勾选一或多个成员，点击移除，批量删除所选成员和成员下所有角色的关联关系。 按角色查看时：勾选一或多个角色，点击移除，批量删除所选角色和角色下所有成员的关联关系。 移除成员角色 点击移除→ 移除成员角色； 可以进行批量删除，即可以一次性删除与某个成员或角色有关的所有成员角色关联。 按成员查看时：勾选一或多个成员，点击移除，批量删除所选成员和成员下所有角色的关联关系。 按角色查看时：勾选一或多个角色，点击移除，批量删除所选角色和角色下所有成员的关联关系。 删除成员角色 按成员查看时，点击删除→，可直接删除与该成员有关联的角色，即删除了一个成员角色关联。 按角色查看时，点击删除→，可直接删除与该角色有关联的成员，即删除了一个成员角色关联。 按成员或角色查看时，点击编辑图标，进入编辑成员的角色界面，点击删除→，可删除与成员有关联的一个角色。 修改成员的角色 点击编辑→，进入编辑一个成员的所有角色界面，可编辑该成员的角色关联。即可以删除角色，更改已有角色，添加其他角色。只有上一个角色已选时才可以继续添加其他角色。 "},"/docs/user-guide/system-configuration/tenant/LDAP":{"url":"docs/user-guide/system-configuration/tenant/LDAP","title":"LDAP","body":"LDAP LDAP是对组织应用的LDAP信息设置的管理。LDAP 只针对 LDAP 用户，LDAP 用户的登录名和密码取自LDAP指向的外部系统中的数据。 菜单层次：组织层 菜单路径：组织管理 > LDAP 默认角色：组织管理员 修改LDAP 1.打开“修改LDAP”界面； 2.填写以下内容； 必填字段： LDAP 名称：通过应用 LDAP 访问 LDAP 目录服务器中注册的用户、群组条目，方便统一管理用户的密码登陆方式 选填字段： 服务器地址：LDAP 要访问的服务器地址 LDAP 属性名：要访问的数据的名称 加密方式：分为 SSL、TSL、STARTTLS 三种 基础DN：获取数据的路径 描述：对该 LDAP 得附加信息 3.点击保存完成 LDAP 的修改。 "},"/docs/user-guide/system-configuration/tenant/":{"url":"docs/user-guide/system-configuration/tenant/","title":"组织设置","description":"","body":"介绍 本页面介绍了组织设置，组织下的项目、用户、客户端的管理需进入到一个特定的组织进行组织层的操作。 在项目层界面中选择一个“组织”，进入“组织管理”界面。 功能 项目管理 是对项目的信息和启用状态的管理。 用户管理 是对用户进行系统的管理。 组织角色分配 是对组织层的角色进行分配。 客户端管理 是对多个客户端信息设置的管理。 LDAP 是对组织应用的LDAP信息设置的管理。 密码策略 是对组织应用的密码安全策略和登录安全策略的信息设置的管理。 "},"/docs/user-guide/system-configuration/tenant/client":{"url":"docs/user-guide/system-configuration/tenant/client","title":"客户端","body":"客户端 客户端是对多个客户端信息设置的管理。配置文件中应用指定的客户端后，登录后跳转页面指向的该客户端设定的网址。 菜单层次：组织层 菜单路径：组织管理 > 客户端 默认角色：组织管理员 客户端列表 列表字段： 客户端编码:客户端编码具有唯一性 是客户端的标识。 授权类型：客户端必须得到用户的授权（authorization grant），才能获得令牌（access token），进而凭令牌获取本平台资源。目前平台提供password、implicit、client_credentials、authorization_code和refresh_token五种授权方式。 客户端查询 可查询字段： 客户端编码:客户端编码具有唯一性 是客户端的标识。可根据客户端编码模糊搜索。 创建客户端 1.点击创建→创建客户端； 2.输入客户端名称、密钥和授权类型； 必填字段: 客户端编码:客户端编码具有唯一性 是客户端的标识。 密钥：使用客户端的密码。例如用户登陆需要用户名和密码，密钥相当于密码。 授权类型：客户端必须得到用户的授权（authorization grant），才能获得令牌（access token），进而凭令牌获取本平台资源。下面提供了五种授权方式： password：密码模式，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向\"服务商提供商\"索要授权。 implicit：简化模式，不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了\"授权码\"这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。 client_credentials：客户端模式，客户端以自己的名义，而不是以用户的名义，向\"服务提供商\"进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求\"服务提供商\"提供服务，其实不存在授权问题。 authorization_code：授权码模式，是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与\"服务提供商\"的认证服务器进行互动。 refresh_token：表示早前收到的更新令牌，如果用户访问的时候，客户端的\"访问令牌\"已经过期，则需要使用\"更新令牌\"申请一个新的访问令牌。 选填字段： 访问授权超时：access_token_validity assecc token的有效时间。 授权超时：refresh_token_validity refresh token的有效时间。 重定向地址：用户的登陆后从登陆界面跳转的地址。 附加信息：用json格式添加客户端的附加信息。如{ \"description\": \"string\"，\"name\": \"string\"}。 3.点击确定完成客户端的创建。 修改客户端 1.点击修改→，对客户端进行修改； 2.输入客户端ID、客户端名称、密钥和授权类型； 不可修改字段： 客户端编码:客户端编码具有唯一性 是客户端的标识。客户端创建成功后，客户端编码不可更改。 可修改字段： 密钥：使用客户端的密码。例如用户登陆需要用户名和密码，密钥相当于密码。 授权类型：客户端必须得到用户的授权（authorization grant），才能获得令牌（access token），进而凭令牌获取本平台资源。 访问授权超时：access_token_validity assecc token的有效时间。 授权超时：refresh_token_validity refresh token的有效时间。 重定向地址：用户的登陆后从登陆界面跳转的地址。 附加信息：用json格式添加客户端的附加信息。如{ \"description\": \"string\"，\"name\": \"string\"}。 3.点击确定完成客户端的修改。 删除客户端 点击删除图标→ ，即可删除客户端。 "},"/docs/user-guide/system-configuration/tenant/project":{"url":"docs/user-guide/system-configuration/tenant/project","title":"项目管理","body":"项目管理 项目管理是对项目的信息和启用状态的管理。进入某一个项目，在该项目下创建项目，则创建的项目属于该项目。在创建的项目中，可以在项目中给成员分配项目层角色。 菜单层次：组织层 菜单路径：组织管理 > 项目管理 默认角色：组织管理员 项目列表 列表字段： 项目名称：项目的名称。 项目编码：项目编码具有唯一性，是项目的标识。 启用状态：启用状态有启用和停用两种形态。当启用状态为启用时，项目正常运行，可进入该项目中进行其他操作；当启用状态为停用时，无法进入该项目。创建成功一个项目后，该项目的启用状态默认为启用。 项目查询 可查询字段： 项目名称：项目的名称。 项目编码：项目编码具有唯一性，是项目的标识。 启用状态：启用状态有启用和停用两种。当启用状态为启用时，项目正常运行，可进入该项目中进行其他操作；当启用状态为停用时，无法进入该项目。创建成功一个新项目后，新项目的启用状态默认为启用。 创建项目 1.点击创建项目→创建一个项目； 2.输入项目编码和项目名称； 必填字段： 项目名称：项目的名称。该字段是必输的。 项目编码：项目编码具有唯一性，是项目的标识。该字段是必输的 编码只能包含字母，数字，下划线，空格， '_' '.' \"——\" 只能以字母，数字，下划线开头。 3.点击创建完成项目的创建。 修改项目 1.点击修改→，对项目进行修改。 2.输入项目编码和项目名称； 不可修改字段： 项目编码：项目编码具有唯一性，是项目的标识。项目创建成功后，项目编码不可更改。 可修改字段： 项目名称：项目的名称。该字段是必输的 3.点击保存完成项目的修改。 启用/停用项目 停用项目：点击列表中停用→，项目的启用状态为启用时，可进行停用项目的操作。停用项目后，项目的启用状态变为停用，不可进入该项目。 启用项目：点击列表中启用→项目的启用状态为停用时，可进行启用项目的操作。启用项目后，项目的启用状态变为启用，可进入该项目进行项目设置、项目角色分配等操作。 "},"/docs/user-guide/system-configuration/tenant/role-assignment":{"url":"docs/user-guide/system-configuration/tenant/role-assignment","title":"组织角色分配","body":"组织角色分配 组织角色分配时，可以给一到多个成员分配一到多个角色。角色是权限的集合，给成员分配角色即给成员赋予权限。权限与角色都具有层级性，且角色权限的层级必须与角色层级相同。角色分配具有层级性，角色分配中被分配的角色层级必须与角色分配的层级相同。即，在某一层级的角色分配中，只能给用户分配对应的层级的角色，只能给角色分配对应层级的权限。例如，在组织层角色分配中，只能给用户分配组织层角色，分配后用户具有使用组织层权限。 菜单层次：组织层 菜单路径：组织管理 > 组织角色分配 默认角色：组织管理员 成员角色列表 列表查看方式： 按成员查看：列表项为成员信息和该成员的所有角色。可以直接对成员的角色进行更改操作。 按角色查看：列表项为角色。展开角色后，展示信息为角色下的成员信息。可以直接对角色下的成员进行更改操作。 列表字段-按成员查看时： 成员：若成员为用户，则为用户的登录名；若成员为微服务，则为微服务名称。 名称：若成员为用户，则为用户的用户名。 角色：角色名称。可以为一到多个。每一个角色都可以在列表中直接删除，或点击编辑，进入编辑成员角色的界面更改成员的角色。 成员类型：成员类型可以为用户、微服务。 列表字段-按角色查看时： 角色/成员：列表的列表项为角色名称。列表项展开后的子列表为角色下的成员 若成员为用户，则为用户的登录名；若成员为微服务，则为微服务名称。 名称：若子列表中的成员为用户，则名称为用户名。 成员角色查询 可查询字段: 成员：若成员为用户，按用户的登录名查找；若成员为微服务，按微服务名称查找。 名称：若成员为用户，按用户的用户名查找。 成员类型：分用户和微服务两种。 角色：按角色名称查找。 添加成员角色 1.点击添加→ 添加成员角色； 2.输入成员、选择一个角色； 添加新的成员角色之间的关联：如果成员已经被分配过角色，则将本次操作新增的与该成员有关的成员角色关联合并到已有关联列表，即已有的不变，新增的增加。 3.点击添加完成添加成员角色。 层级规则： 组织层角色分配的添加成员角色为，在一个组织中，给成员添加组织层角色。例如，在运营组织这个组织中，给登录名为123的用户添加组织管理员的角色，且组织管理员这个角色满足角色层级为组织层的条件。 对应规则： 成员输入一个到多个。如果成员为用户，则输入用户的登录名，若成员为应用，则输入应用名称。 角色选择一到多个。根据角色名称进行选择。可以对角色名称进行过滤。 移除成员角色 点击移除→ 移除成员角色； 可以进行批量删除，即可以一次性删除与某个成员或角色有关的所有成员角色关联。 按成员查看时：勾选一或多个成员，点击移除，批量删除所选成员和成员下所有角色的关联关系。 按角色查看时：勾选一或多个角色，点击移除，批量删除所选角色和角色下所有成员的关联关系。 删除成员角色 按成员查看时，点击删除→，可直接删除与该成员有关联的角色，即删除了一个成员角色关联。 按角色查看时，点击删除→，可直接删除与该角色有关联的成员，即删除了一个成员角色关联。 按成员或角色查看时，点击编辑图标，进入编辑成员的角色界面，点击删除→，可删除与成员有关联的一个角色。 修改成员的角色 点击编辑→，进入编辑一个成员的所有角色界面，可编辑该成员的角色关联。即可以删除角色，更改已有角色，添加其他角色。只有上一个角色已选时才可以继续添加其他角色。 "},"/docs/user-guide/system-configuration/tenant/secret_policy":{"url":"docs/user-guide/system-configuration/tenant/secret_policy","title":"密码策略","body":"密码策略 密码策略是对组织应用的密码安全策略和登录安全策略的信息设置的管理。当应用密码安全策略时，同组织下用户的密码设定和修改都要遵守该密码规则；当应用登录安全策略时，同组织下用户登录系统时的密码输入情况要遵守该登录规则。 菜单层次：组织层 菜单路径：组织管理 > 密码策略 默认角色：组织管理员 密码安全策略 密码安全策略为用户的密码创建或更改时需要满足的规则。修改完密码安全策略后，点击保存，修改的内容生效。 是否启用：如果启用，密码安全策略的其他字段保存后生效；否则，不生效。 不可与登录名相同：选择是，则用户的密码不能有用户的登录名相同；否则，可以与登录名相同。 最小密码长度：设置密码时，密码长度不能小于填入的最小密码长度。 最大密码长度：设置密码时，密码长度不能大于填入的最大密码长度。为空时，表示没有最大密码长度，即密码长度可以无限大。 最少小写字母数：密码中至少应包含的小写字母数。 最少大写字母数：密码中至少应包含的大写字母数。 最少特殊字符数：密码中至少应包含的特殊字符数。 最大近期密码数：与最近使用的n次密码不能相同。例：若填入数值为3，则表示不能与最近3次历史密码相同。 密码正则：定义针对给定文本检查的匹配模式，通过填入特定的正则表达式来制定密码规则。 登录安全策略 登录安全策略为用户使用密码登录平台时的规则。修改登录安全策略后，点击保存，修改的内容生效。 是否启用：如果启用，登录安全策略的其他字段保存后生效；否则，不生效。 开启验证码：如果开启，当用户密码输错次数大于设置的输错次数的值时，出现验证码；如果不开启，则不会出现验证码。 输错次数：密码输错次数超过填写的输错次数后，出现验证码。 开启锁定：如果开启，当用户密码输错次数大于设置的输错次数的值时，用户将会被锁定，无法登录系统。 输错次数：当用户密码输错次数大于设置的输错次数的值时，用户将会被锁定，无法登录系统。 锁定时长：用户被锁定后，经过输入的密码输错锁定时间后，系统自动将该用户解锁，该用户可重新进行输入密码登入系统的操作. "},"/docs/user-guide/system-configuration/tenant/user":{"url":"docs/user-guide/system-configuration/tenant/user","title":"用户管理","body":"用户管理 一个组织下可以有多个用户，一个用户必须且只能属于一个组织。在某个组织下创建用户，则这个用户属于该组织。 菜单层次：组织层 菜单路径：组织管理 > 用户管理 默认角色：组织管理员 用户列表 列表字段： 登录名：登录名具有唯一性，是用户的标识。在登录平台时，可用登录名密码方式登录。在给用户分配角色时，需要输入用户的登录名。 用户名：用户的昵称。 认证来源：为LDAP用户时，密码将从LDAP所访问的外部系统中获取；非LDAP用户无法在本平台设置密码。 启用状态：用户的启用状态为启用时，用户可以登陆平台；启用状态为停用时，用户无法登陆平台。 安全状态：当登录安全策略启用时，如果用户输错密码次数大于登陆安全策略里的最大密码输错次数，则用户被锁住，在一定时间内无法登录平台，安全状态为\"锁住\"；否则，安全状态为“正常”。 用户查询 可查询字段： 登录名：登录名具有唯一性，是用户的标识。 用户名：用户的昵称。 认证来源：分为LDAP用户和非LDAP用户两种。 启用状态：分为启用和停用两种。 安全状态：分为正常和锁住两种。 创建用户 1.点击创建用户→创建一个组织； 2.输入登录名、用户名、邮箱、密码、确认密码、语言和时区； 必填字段： 登录名：登录名具有唯一性，是用户的标识。在登录平台时，可用登录名密码方式登录。在给用户分配角色时，需要输入用户的登录名。 用户名：用户的昵称。 邮箱：一个邮箱只能被一个用户使用。用户需填写真实有效的邮箱。邮箱可用于登录平台、找回密码。 语言:默认为简体中文。 时区：默认为北京时间。 3.点击创建完成用户的创建。 修改用户 1.点击修改→，对用户进行修改。 2.填写输入登录名、用户名、邮箱、密码、确认密码、语言和时区； 不可修改字段： 登录名：登录名具有唯一性，是用户的标识。用户创建成功后，不可更改登录名。 可修改字段： 用户名：用户的昵称。 邮箱：一个邮箱只能被一个用户使用。用户需填写真实有效的邮箱。邮箱可用于登录平台、找回密码。 语言:默认为简体中文。 时区：默认为北京时间。 3.点击保存完成用户的修改。 启用/停用用户 用户不可以被删除，可以被启用/停用。 停用用户：点击列表中停用→ 用户被停用之后，无法被分配角色，无法登录系统。 启用用户：点击列表中启用→ 用户被启用之后，可以被分配角色，可以登录系统。 解锁用户 当密码策略中的登录安全策略被启用时，如果用户输错密码的次数大于登录安全策略中设置的最大密码输错次数，则用户被锁住，在一定时间内无法登录平台。 当用户的安全状态为锁住时，可以解锁该用户。解锁成功后，用户的安全状态变为正常，用户可以被分配角色，可以正常登录系统。 "}}